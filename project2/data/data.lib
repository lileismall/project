<doc>
    <docid>0</docid>
    <url>http://coolshell.cn/articles/17524.html</url>
    <title>如何读懂并写出装逼的函数式代码</title>
    <content>今天在微博上看到了 有人分享了下面的这段函数式代码，我把代码贴到下面，不过我对原来的代码略有改动，对于函数式的版本，咋一看，的确令人非常费解，仔细看一下，你可能就晕掉了，似乎完全就是天书，看上去非常装逼，哈哈。不过，我感觉解析那段函数式的代码可能会一个比较有趣过程，而且，我以前写过一篇《函数式编程》的入门式的文章，正好可以用这个例子，再升华一下原来的那篇文章，顺便可以向大家更好的介绍很多基础知识，所以写下这篇文章。
先看代码
这个代码平淡无奇，就是从一个数组中找到一个数，O(n)的算法，找不到就返回 null。
下面是正常的 old-school 的方式。不用多说。
//正常的版本
function find (x, y) {
  for ( let i = 0; i &lt; x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）：
//函数式的版本
const find = ( f =&gt; f(f) ) ( f =&gt;
  (next =&gt; (x, y, i = 0) =&gt;
    ( i &gt;= x.length) ?  null :
      ( x[i] == y ) ? i :
        next(x, y, i+1))((...args) =&gt;
          (f(f))(...args)))

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
为了讲清这个代码，需要先补充一些知识。

Javascript的箭头函数
首先先简单说明一下，ECMAScript2015 引入的箭头表达式。箭头函数其实都是匿名函数，其基本语法如下：

(param1, param2, …, paramN) =&gt; { statements } 
(param1, param2, …, paramN) =&gt; expression
     // 等于 :  =&gt; { return expression; } 

// 只有一个参数时,括号才可以不加:
(singleParam) =&gt; { statements }
singleParam =&gt; { statements }

//如果没有参数,就一定要加括号:
() =&gt; { statements }

下面是一些示例：
var simple = a =&gt; a &gt; 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) =&gt; a &gt; b ? a : b;

// Easy array filtering, mapping, ...

var arr = [5, 6, 13, 0, 1, 18, 23];
var sum = arr.reduce((a, b) =&gt; a + b);  // 66
var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]
var double = arr.map(v =&gt; v * 2);       // [10, 12, 26, 0, 2, 36, 46]
看上去不复杂吧。不过，上面前两个 simple 和 max 的例子都把这箭头函数赋值给了一个变量，于是它就有了一个名字。有时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。比如下在这个例子：
function MakePowerFn(power) {
  return function PowerFn(base) {
    return Math.pow(base, power);
  } 
}

power3 = MakePowerFn(3); //制造一个X的3次方的函数
power2 = MakePowerFn(2); //制造一个X的2次方的函数

console.log(power3(10)); //10的3次方 = 1000
console.log(power2(10)); //10的2次方 = 100
其实，在 MakePowerFn 函数里的那个 PowerFn 根本不需要命名，完全可以写成：
function MakePowerFn(power) {
  return function(base) {
    return Math.pow(base, power);
  } 
}
如果用箭头函数，可以写成：
MakePowerFn = power  =&gt; {
  return base =&gt; {
    return Math.pow(base, power);
  } 
}
我们还可以写得更简洁（如果用表达式的话，就不需要 { 和 }， 以及 return 语句 ）：
MakePowerFn = power =&gt; base =&gt; Math.pow(base, power)
我还是加上括号，和换行可能会更清楚一些：
MakePowerFn = (power) =&gt; (
  (base) =&gt; (Math.pow(base, power))
)
好了，有了上面的知识，我们就可以进入一个更高级的话题——匿名函数的递归。
匿名函数的递归
函数式编程立志于用函数表达式消除有状态的函数，以及for/while循环，所以，在函数式编程的世界里是不应该用for/while循环的，而要改用递归（递归的性能很差，所以，一般是用尾递归来做优化，也就是把函数的计算的状态当成参数一层一层的往下传递，这样语言的编译器或解释器就不需要用函数栈来帮你保存函数的内部变量的状态了）。
好了，那么，匿名函数的递归该怎么做？
一般来说，递归的代码就是函数自己调用自己，比如我们求阶乘的代码：

function fact(n){
  return n==0 ? 1 :  n * fact(n-1);
};
result = fact(5);

在匿名函数下，这个递归该怎么写呢？对于匿名函数来说，我们可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了。 如下所示：
function combinator(func) {
  func(func);
}
这个是不是有点作弊的嫌疑？Anyway，我们再往下，把上面这个函数整成箭头函数式的匿名函数的样子。
（func) =&gt; (func(func)) 
现在你似乎就不像作弊了吧。把上面那个求阶乘的函数套进来是这个样子：
首先，先重构一下fact，把fact中自己调用自己的名字去掉：
function fact(func, n) {
  return n==0 ? 1 :  n * func(func, n-1);
}

fact(fact, 5); //输出120

然后，我们再把上面这个版本变成箭头函数的匿名函数版：

var fact = (func, n) =&gt; ( n==0 ? 1 :  n * func(func, n-1) )
fact(fact, 5)

这里，我们依然还要用一个fact来保存这个匿名函数，我们继续，我们要让匿名函数声明的时候，就自己调用自己。
也就是说，我们要把 
(func, n) =&gt; ( n==0 ? 1 :  n * func(func, n-1) )
这个函数当成调用参数，传给下面这个函数：
(func, x) =&gt; func(func, x) 
最终我们得到下面的代码：
 
( (func, x) =&gt; func(func, x) ) (  //函数体
  (func, n) =&gt; ( n==0 ? 1 :  n * func(func, n-1) ), //第一个调用参数
  5 //第二调用参数
); 
好像有点绕，anyway, 你看懂了吗？没事，我们继续。
动用高阶函数的递归
但是上面这个递归的匿名函数在自己调用自己，所以，代码中有hard code的实参。我们想实参去掉，如何去掉呢？我们可以参考前面说过的那个 MakePowerFn 的例子，不过这回是递归版的高阶函数了。
HighOrderFact = function(func){
  return function(n){
    return n==0 ? 1 : n * func(func)(n-1);
  };
};
我们可以看，上面的代码简单说来就是，需要一个函数做参数，然后返回这个函数的递归版本。那么，我们怎么调用呢？
fact = HighOrderFact(HighOrderFact);
fact(5); 
连起来写就是：
HighOrderFact ( HighOrderFact ) ( 5 )
但是，这样让用户来调用很不爽，所以，以我们一个函数把  HighOrderFact ( HighOrderFact )  给代理一下：
fact = function ( hifunc ) {
  return hifunc ( hifunc );
} (
  //调用参数是一个函数
  function (func) { 
    return function(n){
      return n==0 ? 1 : n * func(func)(n-1);
    };
  }
);

fact(5); //于是我们就可以直接使用了
用箭头函数重构一下，是不是简洁了一些？
fact = (highfunc =&gt; highfunc ( highfunc ) ) (
  func =&gt; n =&gt;  n==0 ? 1 : n * func(func)(n-1)
);
上面就是我们最终版的阶乘的函数式代码。
回顾之前的程序
我们再来看那个查找数组的正常程序：
//正常的版本
function find (x, y) {
  for ( let i = 0; i &lt; x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}
先把for干掉，搞成递归版本：
function find (x, y, i=0) {
  if ( i &gt;= x.length ) return null;
  if ( x[i] == y ) return i;
  return find(x, y, i+1);
}
然后，写出带实参的匿名函数的版本（注：其中的if代码被重构成了 ？号表达式）：
( (func, x, y, i) =&gt; func(func, x, y, i) ) (  //函数体
  (func, x, y, i=0) =&gt; (
      i &gt;= x.length ?  null :
         x[i] == y  ?  i : func (func, x, y, i+1)
  ), //第一个调用参数
  arr, //第二调用参数
  2 //第三调用参数
)
最后，引入高阶函数，去除实参：
const find = ( highfunc =&gt; highfunc( highfunc ) ) (
   func =&gt; (x, y, i = 0) =&gt; (
     i &gt;= x.length ?  null :
           x[i] == y  ?  i : func (func) (x, y, i+1)
   )
);
注：函数式编程装逼时一定要用const字符，这表示我写的函数里的状态是 immutable 的，天生骄傲！
再注：我写的这个比原来版的那个简单了很多，原来版本的那个又在函数中套了一套 next， 而且还动用了不定参数，当然，如果你想装逼装到天上的，理论上来说，你可以套N层，呵呵。
现在，你可以体会到，如此逼装的是怎么来的了吧？。
其它
你还别说这就是装逼，简单来说，我们可以使用数学的方式来完成对复杂问题的描述，那怕是递归。其实，这并不是新鲜的东西，这是Alonzo Church 和 Haskell Curry 上世纪30年代提出来的东西，这个就是 Y Combinator 的玩法，关于这个东西，你可以看看下面两篇文章：
《The Y Combinator (Slight Return)》，
《Wikipedia: Fixed-point combinator》
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2013年12月27日 函数式编程2014年03月20日 Python修饰器的函数式编程2012年09月20日 C/C++语言中闭包的探究及比较2011年10月31日 API设计：用流畅接口构造内部DSL2010年01月21日 最为奇怪的程序语言的特性2013年12月03日 Lua简明教程2011年08月15日 对象的消息模型2012年02月27日 再谈javascript面向对象编程 
</content>
</doc><doc>
    <docid>1</docid>
    <url>http://coolshell.cn/articles/17497.html</url>
    <title>什么是工程师文化？</title>
    <content>四年前，我在QCon上演讲了一个《建一支强大的小团队》（整理后的PPT分享于这里）提到了工程师文化，今天，我想在这里再写一篇关于工程师文化的文章，一方面是因为我又有了一些想法和体会，另一方面，因为我也正走在创业的道路，毫无疑问，要建一个有浓重的工程师文化的团队或公司，所以有必要把自己的相关想法形有成白底黑字的“字据”，以供打自己的脸——“要是未来没有做到，这篇文章就打我未来的脸” || “这篇文章太幼稚了，未来的我会打我现在的脸”，当然，如果要打脸，我希望是前者。
Again，这篇文章不是招人的贴子，因为我觉得，招聘第一重要的事，不是发招聘广告或是找猎头挖人，而是先得让自己变成一个能配得上真正工程师的公司，然后再谈吸引人的事。
为什么要工程师文化
看看最近二十年来社会的发展，计算机和互联网已经渗透到了这个社会的每一个角落，各式各样的计算机技术成为了整个世界发展的强大引擎，各式各样的创新，无论是业务创新还是技术创新，都是依托于技术的快速演进，技术成了解放生产力提高社会运作的效率的中坚力量。以美帝为首的技术创新公司着着实实的改变着这个世界和人类的生活和生产习惯。
今天，每个从事计算机行业的技术人员都应该感到幸运，因为，我们不但选对了行业，也出生在了正确的时代，可以感受到前所未有的刺激和变化，相比起我们的父辈，我们的人生，能经历这样的时代，实在是一种幸运。所以，选对了职业并出生在了正确的年代的我们，此时只需要思考的一个问题，那就是，我是否呆在了正确的地方用正确的方式做事？

在我看来，这个世界上有三种商业公司，

运营或销售驱动型的公司。这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。


产品驱动型的公司。这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。


技术驱动型的公司。这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。

这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。
无论你有多么的看不起技术人员，你都无法否认，你今天的生活相当的依赖这帮工程师，没有他们，你恐怕都不知道怎么生活了。邓爷爷几十年前就说过——“科学技术是第一生产力” ，无论什么样的科学技术的理论要落地都会依赖于工程技术有多先进。
所以，在今天，作为一个IT或互联网公司，“工程师文化”不是一个问题，而是一个常识！
工程师文化的特征
我下面罗列的这些特征，来源于：Google的《重新定义公司》，我在Amazon的工作经历，37Signals的《Rework》，Quora上的 What Makes Good Engineering Culture?  Slideshare上的 What Makes Good Engineering Culture，以及我最近这半年来的一些实践。
简单说来，我可以简单的把这多的工程师文化的总结成两大类：“自由” 和 “效率”。
本来还应该有个“创新”，但我个人认为，创新的前提是——在自由的环境下对提高效率的痴迷，就一定会发生创新。
创新不是凭空出现新的东西，其实，观察一下人类的发展史，不难发现，几乎所有的创新基本上跳出原来的思维模式用新的思维模式对原有问题的效率进行质的提升。比如：通信、交通、医疗、教育、生活……几乎全都是在优化效率。
所以，如果你的精神不自由，你很难跳出老的思维模式，你用老的思维模式你一定不会想到新的方法和方式，如果不是对效率的提升，这个创新可能会不接地气。
因此，我认为，工程师文化就是自由加效率！
自由
首先，工程师文化意味的创新文化，工程师都是有创新冲动的人，因为手里有创造技能的人通常都会有想创造点什么的冲动。而创新的源泉水来源于精神的解放，精神自由才会引发各式各样的奇思怪想，才会有常人觉得不可能的疯狂想法和想像力，而这些想法和想像力导致了创新。
精神上的自由具体表现在：

自我驱动。自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。


灵活的工作时间和地点。工程师们更多的是脑力工作，而不是体力工作，工作上时间和地点的自由安排可以让工程师们的脑力工作更有效。Remote是一个很不错的工作方式，开源社区基本上都是这钟方式。和Remote有关的话题可参看37Signals的这本书《Remote》


信息平等。这意味着，全体员工得到的是原始信息，而不是被管理者们层层加工消化后的信息，信息的屏蔽很容易造成误解和完全错误的行为。信息的平等，大的包括战略、方向、目标、财务，小的包括文档、代码、和知识的共享等。同样，也表现在意见表达上，任何人都有可能表达自己的意见和建议的平等机会，这样才会激发出更多的思路和思辩，从而有不同的更好的思路出现。而不是，大家都看到了问题，而没有人敢说。在Google除了代码全员共享，还有Thanks God, It&#8217;s Friday的文化，每周五，高管们会出来，任员工提各种尖锐的问题，在Amazon，代码和文档基本上全员开放，包括财务报表也对员工开放，另外，除了所有的NB的Principle SDE隔三岔五都会有一个Principle Talk（有很多Talk相当令人开脑洞），还有Amazon内部的Up the River文化，每年会选出一批公司最聪明最有想法的人集思会，讨公司下一步的和战略，并可以把相应的KPI直接按给Senior VP。


不害怕错误。处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。


宽松的审批系统甚至没有审批系统。审批通常暗示着三件事，1）对人的不完全信任，2）繁琐的流程，3）思维上的束缚。这些都是创新和想像力的天敌。一个公司的监管、审批、流程越重，这个公司的活力也就越差。


20%的自由时间。这是Google公司提出来的，员工有20%自由的时间做自己想做的项目，Gmail就是这么出来的。

效率
工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。
一方面，这个工具可以共享重用，更多的人可以从中受益，这次我花5个小时开发这个工具，下次只用1小时改一下就可以用在别的地方，这是着眼于未来而不是眼下的成本。更重要的是，这是一种文化，一种提高效率的文化，他会鼓励和激发出更多的这样的事情发生。如果你因为一个程序员花大量的时间开发自动化的工具，而认为这个程序员没有效率，对之批评甚至惩罚的话，那么你就扼杀了提高效率的文化（关于效率，大家可以看看我的另一篇文章《关于加班和效率》，你会真正了解什么是效率）
人类之所以比别的动物聪明就是会使用和发明工具，而古语也有云：“工欲善其事，必先利其器”，看看美军的装备你就知道战争工具的好坏有多重要了，一个公司的强大之处在执行力，而执行力的强大之处在于你有什么样的支持工具。这些，已经不是工程师文化，而是人类发展的文化。
针对于工程师文化来说，尤其是软件工程，提升工程效率的具体表现如下：

简化。简化不是简陋，简单的东西通常意味着用户更好理解，也意味着更容易的维护和运维。就像阿里推行的“小而美”，就像乔布期推崇的“没有产品手册简单易用的产品”，就像Amazon推行的Working Backwards里说的那样，一个新的产品或功能，产品经理需要写三个文档：媒体公关文、用户手册、常见问题，三个文档总共加起来不超过两页A4纸，且不准用任何图片说明，目的就是为了让产品简化和容易使用。


残酷无情的推行自动化。编写程序的最本质的目的就是自动化，看看人类发展史上自动化了多少东西。对于自动化来说，不仅仅只是消除人肉的重复劳动，更重要的是，很多事情人完全干不过机器。比如：加一台机器，程序在秒级就可以完成，而人是永远不可能达到这样的速度的，再比如：电商中用程序管理数量巨大的订单的自动化系统，加再多的人都完成的不可能像机器那样完成的又好又快。自动化需要大力开发提高生产力的工具，比如：持续集成，持续部署，自动化运维，基础自动化运维，甚至自动化的运营工具。（Amazon的软件工程中对自动化和简代相当迷恋）


避免无效率的组织架构和无效率的管理。这体现在这些方面：1）扁平化的组织架构，2）努力用自动化工具取代支持型的工作，3）不超过10个人的全栈小团队，4）不按人员的技能分工而是按其负责的产品或功能分工（关于分工，请参看《让我们来谈谈分工》），5）开会不是解决问题，开会是表决提案，6）通过产品的目标或信条Tenets来减少沟通和决策过程（Amazon里的每个部门，每个团队，每个产品都有自己的Tenets，这个Tenets标明了要什么不要什么，这样可以避免很多扯皮和难缠的trade-off的决择，比如：AWS的几个信条：运维是最高优级的——这意味着只要是会让运维变得复杂的需求都可能会工程团队被拒掉，Throughput &amp; Latency不能更差——这意味着，功能要为性能让路，因为性能变差了，用户就要买更多的资源）


正确的组件抽象。抽象是简化的一部份，一方面，抽象意味着重用和通用，另一方面抽象意味着强大的扩展性，以适配各种可能性。最重要的是，抽象意味着技术能力的输出，无论是内部的其它团队还外部的团队。比如：Google的MapReduce/BigTable/ProtoBuffer，FaceBook的Thrift，还有Amazon内部的WebService框架Coral Service、处理日志监控的Timber，以及全线AWS产品都用到的Amazon Lock Framework（一个分布式锁框架）……


开发高质量的产品。因为高质量的代码，不但可以容易的修改和维护，还可以因为少处理线上故障，从而有更多的时间去为未来做更多创造性的工作。这意味着需要有非常严谨的Design Review，Code Review，以及测试，关于Code Review，可以参看这篇文章《从Code Review 谈如何做技术》，关于严谨的测试，可以参看这篇文章《如何做性能测试》


不断的提高标准以及招聘最好的人。取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也。如果一个公司或一个团队想变得越来越好，越来越强大的话，就必需要不断的提高自己的工作标准，提高工作标准意味着要不断地培养和招聘更好的人。在Amazon和Google的招聘官中都有一个叫Bar Rasier的人，这个人就是为了提高招聘标准而设立的。


创建一个持续改善的文化。一个好的组织，一个好的团队，是需要不断反思前进的，这需要全体员工一起来的。微观层面上，在项目做完后需要有一个总结会分析项目中的得失，在故障出现后，需要有故障分析会，反思得失，在Amazon，严重的故障，需要写一个COE（Correction of Errors）的文档，其中有一节叫“Ask 5 Whys”，让你自己问自己至少5个为什么。在宏观层面，一个公司每年都应该做一定的工作数据分析或是员工调查，比如，是否招聘到了不错的人、工作的投入产出比，员工在哪些地方花时间了，等等，然后不断的用技术手段来改善。（Amazon每年的工程师员工调查表是我活那么大见过的最细最细的调查表了， 问题除了对公司、经理、文化的，还有从，日常工作、开发环境、持结集成，测试自动化、产品质量、软件架构、软件维护、线上问题处理、年度计划、数据仓库建设、通用工具投票……这个员工调查直接导致公司的对工程的投资方向）

工程师文化如何落地
如果你要让任何文化在公司内得到执行，你有下面几个手段可以选择：

通过政治手段：你需要把住三个地方——招聘、绩效考核 &amp; 升职。比如，你要落地工程师文化中的简化和自动化，那你你在招聘的时候，你需要把懂简化和喜欢自动化的人招进来，然后在绩效考核和升职的地方设置上一条硬性指标——你今年简化了什么？自动化了什么？如果没有，对不起不但不能升职，绩效可能还不达标。


通过经济手段：让不做这事的成本 &gt; 要做这个的成本。然后，正常的人类都会选择成本低的方案。比如，如果你要推行Design/Code Review/UT以提高质量，你就把QA和OPS团队全挪到一边去，让Dev团队自己测试，自己负责，这样等这些Dev重复多次手动测试，处理多次线上的弱智故障，他们就会自然而然的写自动化测试和做Code Review了，而QA和OPS团队只是帮Dev你做工具罢了，而测试和运维的事全是你DEV的Ownership，出了故障也是Dev自己负责，于是，他们就会发现，不做Code Review和UT的成本远远大于做C Code Review/UT的成本，他们就会去做成本低的事的。

最后，工程师文化要落地，还有几个小条件，

第一，团队要小，Ownership很重要，Eat Your Own Dog Food。 没有人帮你擦屁股，自己的屎自己吃，没有痛苦，不会产生想进步的动力。


第二，热爱学习和尝试，学习尝试新的技术，开拓眼界，学习尝试新的思维方式，否则，呆在原地，原有的思维方式只会让你在原地打转转。


第三，老板更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题。

其它
说了这么多，时代还在发展，不过，这是我这么多年经历或看到的工程师文化的东西了。最后吐几个槽——
对于996和加班这个事，对于工程师来说从来都不是问题，在解决技术问题或是创造的时候，工程师是个很自觉的群体，基本不需要有别人驱动，工程师是最乐意Work Hard的人了。我相信几乎所有走上编程这个职业的人来说，基本上都是兴趣所至，觉得编程很有趣，但却被各个公司996搞得对编程毫无兴趣。为什么，你们这些公司要向中国的教育学习呢？人家本来对这事有比较高的兴趣的，但就是要通过考试/KPI/996这些东西把人家的兴趣一点一点的磨灭掉，把人变成机器、奴隶、牲口，让人对学习和工作产生了厌倦和讨厌，会是你们这些管理者们所希望的？是不是只有把人变得不思进取了，你们才会管理？就像《软件开发中的两种管理方式》中说的第一种人一样？
另外，我不知道，为什么我一说这些东西，就会有很多人（包括程序员自己）来和我说我是个理想主义者，这些已经不是什么理想了，已被很多成功的公司用了很多很多年了。只是你没有见到过罢了。还有的人说，因为中国的国情不同。这更让我费解了。这让我想到了当年大清朝派了一堆人出国考察后回来后，说外国的那套共和的东西不符合中国国情，最终也在历史的潮流中被淹没掉了。另外，什么叫“中国的国情不同”？中国有全世界数一数二的互联网用户，也有全世界数一数二的市场，不再是以前那个一穷二白的年代了，中国的国情到底有哪些不同呢？
我不知道各位工程师是为什么活的？但我觉得，我们选择了一个刺激的职业，也赶上了这个行业大发展的时代，我们不妨扪心自问一下，你是否愿意让自己的能力、青春和热情就这样被磨灭了？
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2013年03月11日 《Rework》摘录及感想2014年04月12日 从Code Review 谈如何做技术2011年10月25日 多些时间能少写些代码2011年07月06日 软件公司的两种管理方式2014年06月09日 开发团队的效率2013年07月24日 加班与效率2015年12月13日 让我们来谈谈分工2012年08月16日 对技术的态度
</content>
</doc><doc>
    <docid>2</docid>
    <url>http://coolshell.cn/articles/17459.html</url>
    <title>关于高可用的系统</title>
    <content>在《这多年来我一直在钻研的技术》这篇文章中，我讲述了一下，我这么多年来一直在关注的技术领域，其中我多次提到了工业级的软件，我还以为有很多人会问我怎么定义工业级？以及一个高可用性的软件系统应该要怎么干出来？这样我也可以顺理成章的写下这篇文章，但是没有人问，那么，我只好厚颜无耻的自己写下这篇文章了。哈哈。
另外，我在一些讨论高可用系统的地方看到大家只讨论各个公司的技术方案，其实，高可用的系统并不简单的是技术方案，一个高可用的系统其实还包括很多别的东西，所以，我觉得大家对高可用的系统了解的还不全面，为了让大家的认识更全面，所以，我写下这篇文章。
理解高可用系统
首先，我们需要理解什么是高可用，英文叫High Availability（Wikipedia词条），基本上来说，就是要让我们的计算环境（包括软硬件）做到full-time的可用性。在设计上一般来说，需要做好如下的设计：


对软硬件的冗余，以消除单点故障。任何系统都会有一个或多个冗余系统做standby
对故障的检测和恢复。检测故障以及用备份的结点接管故障点。这也就是failover
需要很可靠的交汇点（CrossOver）。这是一些不容易冗余的结点，比如域名解析，负载均衡器等。

听起似乎很简单吧，然而不是，细节之处全是魔鬼，冗余结点最大的难题就是对于有状态的结点的数据复制和数据一致性的保证（无状态结点的冗余相对比较简单）。冗余数据所带来的一致性问题是魔鬼中的魔鬼：

如果系统的数据镜像到冗余结点是异步的，那么在failover的时候就会出现数据差异的情况。


如果系统在数据镜像到冗余结点是同步的，那么就会导致冗余结点越多性能越慢。

所以，很多高可用系统都是在做各种取舍，这需要比对着业务的特点来的，比如银行账号的余额是一个状态型的数据，那么，冗余时就必需做到强一致性，再比如说，订单记录属于追加性的数据，那么在failover的时候，就可以到备机上进行追加，这样就比较简单了（阿里目前所谓的异地双活其实根本做不到状态型数据的双活）。
下面，总结一下高可用的设计原理：

要做到数据不丢，就必需要持久化
要做到服务高可用，就必需要有备用（复本），无论是应用结点还是数据结点
要做到复制，就会有数据一致性的问题。
我们不可能做到100%的高可用，也就是说，我们能做到几个9个的SLA。

高可用系统的技术解决方案
我在《分布式系统的事务处理》中引用过下面这个图：这个图来自来自：Google App Engine的co-founder Ryan Barrett在2009年的Google I/O上的演讲《Transaction Across DataCenter》（视频： http://www.youtube.com/watch?v=srOgpXECblk）

这个图基本上来说是目前高可用系统中能看得到的所有的解决方案的基础了。M/S、MM实现起来不难，但是会有很多问题，2PC的问题就是性能不行，而Paxos的问题就是太复杂，实现难度太大。
总结一下各个高可用方案的的问题：

对于最终一致性来说，在宕机的情况下，会出现数据没有完全同步完成，会出现数据差异性。
对于强一致性来说，要么使用性能比较慢的XA系的两阶段提交的方案，要么使用性能比较好，但是实现比较复杂的Paxos协议。

注：这是软件方面的方案。当然，也可以使用造价比较高的硬件解决方案，不过本文不涉及硬件解决方案。
另外，现今开源软件中，很多缓存，消息中间件或数据库都有持久化和Replication的设计，从而也都有高可用解决方案，但是开源软件一般都没有比较高的SLA，所以，如果我们使用开源软件的话，需要注意这一点。
高可用技术方案的示例
下面，我们来看一下MySQL的高可用的方案的SLA（下图下面红色的标识表示了这个方案有几个9）：

图片来源：MySQL High Availability Solutions
简单解释一下MySQL的这几个方案（主要是想表达一个越多的9就越复杂）

MySQL Repleaction就是传统的异步数据同步或是半同步Semi-Sync（只要有一个slave收到更新就返回成功）这个方式本质上不到2个9。
MySQL Fabric简单来说就是数据分片下的M/S的读写分离模式。这个方案的的可用性可以达到99%
DRBD通过底层的磁盘同步技术来解决数据同步的问题，就是RAID 1——把两台以上的主机的硬盘镜像成一个。这个方案不到3个9
Solaris Clustering/Oracle VM ，这个机制监控了包括硬件、操作系统、网络和数据库。这个方案一般会伴随着节点间的“心跳机制”，而且还会动用到SAN（Storage Area Network）或是本地的分布式存储系统，还会动用虚拟化技术来做虚拟机的迁移以降低宕机时间的概率。这个解决方案完全就是一个“全栈式的解决方案”。这个方案接近4个9。
MySQL Cluster是官方的一个开源方案，其把MySQL的集群分成SQL Node 和Data Node，Data Node是一个自动化sharing和复制的集群NDB，为了更高的可用性，MySQL Cluster采用了“完全同步”的数据复制的机制来冗余数据结点。这个方案接近5个9。

那么，这些2个9，3个9，4个9，5个9是什么意思呢？又是怎么来的呢？请往下看。
高可用性的SLA的定义
上面那些都不是本文的重点，本文的重点现在开始，如何测量系统的高可用性。当然是SLA，全称Service Level Agrement，也就是有几个9的高可用性。
工业界有两种方法来测量SLA，

一个是故障发生到恢复的时间
另一个是两次故障间的时间

但大多数都采用第一种方法，也就是故障发生到恢复的时间，也就是服务不可用的时间，如下表所示：



系统可用性%
宕机时间/年
宕机时间/月
宕机时间/周
宕机时间/天


90% (1个9)
36.5 天
72 小时
16.8 小时
2.4 小时


99% (2个9)
3.65 天
7.20 小时
1.68 小时
14.4 分


99.9% (3个9)
8.76 小时
43.8 分
10.1 分钟
1.44 分


99.99% (4个9)
52.56 分
4.38 分
1.01 分钟
8.66 秒


99.999% (5个9)
5.26 分
25.9 秒
6.05 秒
0.87 秒



比如，99.999%的可用性，一年只能有5分半钟的服务不可用。感觉很难做到吧。
就算是3个9的可用性，一个月的宕机时间也只有40多分钟，看看那些设计和编码不认真的团队，把所有的期望寄托在人肉处理故障的运维团队， 一个故障就能处理1个多小时甚至2-3个小时，连个自动化的工具都没有，还好意思在官网上声明自己的SLA是3个9或是5个9，这不是欺骗大众吗？。
影响高可用的因素
老实说，我们很难计算我们设计的系统有多少的可用性，因为影响一个系统的因素实在是太多了，除了软件设计，还有硬件，还有每三方的服务（如电信联通的宽带SLA），当然包括“建筑施工队的挖掘机”。所以，正如SLA的定义，这不仅仅只是一个技术指标，而是一种服务提供商和用户之间的contract或契约。这种工业级的玩法，就像飞机一样，并不是把飞机造出来就好了，还有大量的无比专业的配套设施、工具、流程、管理和运营。
简而言之，SLA的几个9就是能持续提供可用服务的级别，不过，工业界中，会把服务不可用的因素分成两种：一种是有计划的，一种是无计划的。
无计划的宕机原因
下图来自Oracle的 《High Availability Concepts and Best Practices》
&nbsp;
有计划的宕机原因
下图来自Oracle的 《High Availability Concepts and Best Practices》

&nbsp;
我们可以看到，上面的宕机原因包括如下：
无计划的

系统级的故障 &#8211;  包括主机、操作系统、中间件、数据库、网络、电源以及外围设备
数据和中介的故障 &#8211; 包括人员误操作、硬盘故障、数据乱了
还有：自然灾害、人为破坏、以及供电问题。

有计划的

日常任务：备份，容量规划，用户和安全管理，后台批处理应用
运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护
升级相关：数据库、应用、中间件、操作系统、网络、包括硬件升级

真正决定高可用系统的本质原因
从上面这些会影响高可用的SLA的因素，你看到了什么？如果你还是只看到了技术方面或是软件设计的东西，那么你只看到了冰山一角。我们再仔细想一想，那个5个9的SLA在一年内只能是5分钟的不可用时间，5分钟啊，如果按一年只出1次故障，你也得在五分钟内恢复故障，让我们想想，这意味着什么？
如果你没有一套科学的牛逼的软件工程的管理，没有牛逼先进的自动化的运维工具，没有技术能力很牛逼的工程师团队，怎么可能出现高可用的系统啊。
是的，要干出高可用的系统，这TMD就是一套严谨科学的工程管理，其中包括但不限于了：

软件的设计、编码、测试、上线和软件配置管理的水平
工程师的人员技能水平
运维的管理和技术水平
数据中心的运营管理水平
依赖于第三方服务的管理水平

深层交的东西则是——对工程这门科学的尊重：

对待技术的态度
一个公司的工程文化
领导者对工程的尊重

所以，以后有人在你面前提高可用，你要看的不是他的技术设计，而还要看看他们的工程能力，看看他们公司是否真正的尊重工程这门科学。
其它
有好些非技术甚至技术人员和我说过，做个APP做个网站，不就是找几个码农过来写写代码嘛。等系统不可用的时候，他们才会明白，要找技术能力比较强的人，但是，就算你和他们讲一万遍道理，他们也很难会明白写代码怎么就是一种工程了，而工程怎么就成了一门科学了。其实，很多做技术的人都不明白这个道理。
包括很多技术人员也永远不会理解，为什么要做好多像Code Review、自动化运维、自动化测试、持续集成之类这样很无聊的东西。就像我在《从Code Review 谈如何做技术》中提到的，阿里很多的工程师，架构师/专家，甚至资深架构师都没有这个意识，当然，这不怪他们，因为经历决定思维方式，他们的经历的是民用级的系统，做的都是堆功能的工作，的确不需要。
看完这些，最后让我们都扪心自问一下，你还敢说你的系统是高可用的了么？ ;-)
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2014年01月20日 分布式系统的事务处理2013年07月05日 IoC/DIP其实是一种管理思想2011年10月25日 多些时间能少写些代码2011年06月10日 软件真的好难做啊2011年09月08日 千万不要把 bool 设计成函数参数2012年03月09日 Bret Victor &#8211; Inventing on Principle2014年04月12日 从Code Review 谈如何做技术2016年09月18日 什么是工程师文化？
</content>
</doc><doc>
    <docid>3</docid>
    <url>http://coolshell.cn/articles/17446.html</url>
    <title>这多年来我一直在钻研的技术</title>
    <content>因为我是看到tinyfool 《那些年我赶过的时髦技术趋势》，在赞叹的时候，也让我对我有好些回忆，所以想写一篇回忆贴，本来觉得回忆是件挺让人沮喪的事，因为是老了的表现，但我写着写着，就歪了楼。看来，我还不老，还在拼博。下面是很多我的唠叨，你喜欢就读读，不喜欢就TLDR &#8211; Too Long, Don&#8217;t Read!
自从98年毕业，到今天，参加工作有18个年头了，加上在大三的时候就为两个在外面接活的老师程序，到今天，写的程序被用到生产线也有18个年头了。
背景经历
要说明我技术上的“性取向”，还得我说说的我的一些背景和经历。
我这18年，大约分三个阶段：

1996年-2000年：入门乱来期，大三大四加在银行工作的两年。

用Powerbuilder/Delphi在WindowsNT/SQL Server上做了好多个MIS管理软件，有酒店的，有送水的，有OA的。
 用Java的Applet做了一个Web的教学课件，用于在Win95/IE3.0中演示操作系统中的各种调度和算法的动画，得了个全国大学生挑战者杯的鼓励奖。
 用Delphi的ISAPI技术以及PHP/ASP给一些公司和大学做过几个网站。





2000年-2010年：技术学习期，这十年，我主要的编程语言是C/C++。

前两年在银行用C语言在Unix（AIX/Solaris/Sco Unix/HP-UX..）写各种银行业务（用C语言写），用C写操作SQL，操作界面，写业务交易逻辑，一切都用C……，这是一个C语言的年代，当时，全国的银行都在做大集中，银行是当时行业里最大的软件系统了，所以，我确定了C/C++/Unix的技术方向，我当时的网上签名是，C/C++/Unix才是大规模杀伤性武器。
然后，2002年在Platform做一个全平台的（包括Unix/Linux/Windows）高性能计算的软件产品，很像今天的Hadoop，当时叫Grid Computing，主要用低廉的x86集群进行大规模的并行计算，主要用于芯片设计行业，如：ARM和德州仪器，或是科研，如NASA，或是国家安全，如美国国防部的影像分析，或是3D动画渲染，如怪物史瑞克……从05年以后，发现很多用户开始从Unix迁移到Linux，于是开始更为关注Linux的Kernel知识。Platform有一套很严谨的软件工程体系，我对严谨的软件工程以及很多的基础的技术的认识在这里形成。
2007年在路透做路透全球金融数据Real-Time网络的高性能调优（我在《性能测试应该怎么做？》一文中透露过这个公司的性能要求，是一个实时的数据网络，对于99.9%的网络传输在100K的tps下要低于1ms，技术挑战是很大的），在路透，我只干一个事，就是性能优化，我把我负责的几个系统的性能都提升了8倍到15倍的样子，09年年底的时候，我已把未来3年的优化的活都干完了。所以，这个时期，我也开始了我的经理生涯。我对性能调优，高可用系统架构，研发管理的很多是在这里形成的。


2010年到今天，技术沉淀期，这个时间段，主要的编程语言是Java。

这段时间，我加入了Amazon和Alibaba，也就是所谓的互联网公司。在Amazon干了两个事，一个是把Amazon全球的marketplace连起来，跨大洲的数据中心的通信，还有一个是第一次接触大数据和机器学习——用户需求预测系统。在Alibaba干过电商云平台聚石塔和阿里云，去阿里最主要的是经历双十一。
这段时间，对我影响比较大的是Amazon，技术不再是我的瓶颈，大规模的系统，对我也不是问题，而让我收获最大的是，世界前沿的软件设计架构和解决方案，以及做技术的态度和工程的方法，我的眼界、脑洞和视野都巨大的打开，并且在技术管理、工程管理、产品管理、人员管理、公司管理等等管理方面的思维有了质的提升。这段时间，才是我真正技术沉淀的时期。



我的这个背景本来可以更好一些，只可惜运气不太好，本来可以走的更快的，无奈在最关键的时候遇到了两次金融危机，本来可以去硅谷更牛更好的公司见世面，无奈父母身体欠安，只能放弃。
经历决定思维方式
通过我的背景经历，大家不难看到，我基本上都是做一些规模比较大的系统和软件，而且，主要用C/C++/Unix/Linux这样比较晦涩的语言和操作系统。我们知道用C和C++开发，基本上要处理的错误都是和系统底层相应的东西，而上规模的系统和软件，又总是会遇到很多“稀奇古怪”的问题，这些问题，都会逼着我要去了解很多的操作系统、计算机系统、网络、数据库、中间件等等的各种基础或底层技术。
而且我经历的基本上都是非常严谨的软件工程，不能马虎，我有几次马虎的经历，给我造成了非常大的心理影响，比如，曾经被定性为不适合写代码，因为我的代码太烂，或是出了严重的故障，几乎要跑路去了。另外，全球gloabl式的oncall，经常让我在凌晨被电话叫起来解决问题，这个经历比较痛苦。所以，我的整个经历，让我养成了，在软件开发上必需也不得不严谨的习惯和价值观体系。
大家想想，用C/C++开发一个几乎不能出故障的软件系统，你需要多仔细和多严谨的态度才能达到要求？因此，我的经历让我不能马虎，也不能应付工作，更不能在标准上有所妥协，还需要不断地提高标准，所以，时间一长，我必然，会有如下的习惯：

要做到——知其然，知其所以然。所以，只能不断的学习基础知识以及和这个技术关联的知识，就像Wikipeida一样，当你进入一个词条的时候，就会伴随时一堆新词条，于是，当多年后，我看到 “知识广度是深度的副产品”这句话时，简直就是说到我的心里去了。


要做出工业级的软件。从银行到Platform到Thomson Reuters再到Amazon，软件开发上都会有SLA的要求。我认为，一个软件是工业级还是民用级的，除了功能正确之外，最重要的一个指标之一就是在性能和稳定性上有没有SLA。绝大多数的互联网公司和开源软件都没有SLA。所以，达不到工业级的标准。要达到工业级的标准，就需要花费时间、人力和财力进行非常繁琐的设计、测试评估以及运维管理。


工业级的软件来自工业级专业人员和专业软件工程。

专业的人员。为什么绝大多数的外国公司需要的是CS（Computer Science）背景毕业的工程师？因为他们要做的是工业级的软件，这是一门科学，即然是科学，就需要受过良好的科学教育的CS专业的人。
专业的工程。工业级的软件需要有工业级的软件工程，比如，严谨的Design/Code Review，严格的测试，以及完备的线上运维。
专业的工具。这个时候，你就会发现，要做到高级别的SLA，比如包括5个9以上的SLA，人肉干活的能力已经完全跟不上了，你需要大量的专业的与之配套工具。人类之所以聪明是因为会发明工具，所以，这也是工业级的另一个标准——你有多少现代化的支撑工具？



在之前的《开发团队的效率》一文中，我说过——你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。
认真是痛苦和艰难的，也是需要苦苦坚持的，因为人太容易妥协了，这对每个人来说都是一种不小的挑战。老实说，我与很多人对“认真”的标准不一样，所以，产生了很多分歧，很多人说我太理想了。其实，我能理解他们，一方面是因为我的标准是比较高了，另一方面是他们只做过民用级的软件。
另外，在一开始，做惯了工业级软件的我极度地不适应于那些糙快猛的开发方式。不过，我也在调整自己，毕竟，世界不只一种价值观，有的是工业级的软件，有的则是民用级的，还有的只是个玩具，而且还有Java这门语言非常有效地屏蔽了很多底层和基础知识，所以，也不可一概而论，我也在适应一些民用级的软件开发的方式。
后记
从去年我从阿里离开到现在14个月了，这段时间内，我给大约40多家公司做过相应的技术咨询和解决过很多技术问题，绝大多数公司都是因为性能和稳定性的问题来找我的，我给这些公司解决问题的时候，基本都是这样的Pattern：

一开始，发现都是一些技术知识点的问题，
然后，马上进入到系统架构方面方面的问题，
当再解决架构问题的时候，我发现，已经是软件工程的问题，
而软件工程问题的后面，又是公司管理上的问题
而公司管理的问题，结果又到了人的问题上
而人的问题，又到了公司文化的问题……

你看，很多问题，一环扣一环，最终都不是一个简单的技术问题。我倒不是说，我在抱怨这些问题，我更不是在说能解决这些问题，因为，就像软件工程没有银弹一样，无论你给什么样的解决方案都会有问题，没有问题才是不科学的。我能做的是，观察这个公司的业务形态、和相关的思维方式，以及现有的资源和相应的技术实力，帮助他们从技术到管理上缓解或改善现有的问题。
所以，我基本上来说，这近20年来，我只在专心研究一个事——如何做出一个性能高稳定性好的大规模的系统。在这个方向中，除了很多的基础和底层技术我需要吃透，我还需要在软件的开发工艺，软件工具，以及软件的线上运维，以及相关的管理上不断学习和思考，因为，只有技术、工具、工程、运维、人员这几个方面搞好了，才可能出现一个性能高且稳定性好的系统。
之前对于我来说，我一直在鼓吹先进的管理和软件工程以及技术和工具。今天，对我来说，遇到最大的问题就是，在没有这些所谓的先进的东西的时候，除了我自己上手外，我是否还能解决相应的问题？因为我自己已经完全Scale不开了。
有问题就有挑战，我每天都在思考，如何在不完美甚至残缺的环境下，解决这些公司的技术问题。每个人都要给自己一个目标。目前，我给自己的目标是——在残缺的环境下，能让用户不改一行代码，不动任何的架构，不改变用户很糟糕的软件开发的习惯，也不让用户作任何管理上的调整，能提升用户的软件系统的性能和稳定性。
因为我相信技术，我相信有更好的技术，可以为用户完全透明的提升性能和稳定性，我大致找到了相应的解，现在，我正在实践的路上，这也许是笔大买卖，所以我不知天高地厚地注册了自己的公司……
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2011年04月07日 程序员的谎谬之言还是至理名言？2013年03月11日 《Rework》摘录及感想2013年11月13日 编程能力与编程年龄2014年06月09日 开发团队的效率2013年07月24日 加班与效率2014年04月12日 从Code Review 谈如何做技术2012年08月16日 对技术的态度2015年12月13日 让我们来谈谈分工
</content>
</doc><doc>
    <docid>4</docid>
    <url>http://coolshell.cn/articles/17416.html</url>
    <title>缓存更新的套路</title>
    <content>看到好些人在写更新缓存数据代码时，先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。然而，这个是逻辑是错误的。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。
我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。
这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。
更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。

Cache Aside Pattern
这是最常用最常用的pattern了。其具体逻辑如下：

失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。


命中：应用程序从cache中取数据，取到后返回。


更新：先把数据存到数据库中，成功后，再让缓存失效。



注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。
一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。
这是标准的design pattern，包括Facebook的论文《Scaling Memcache at Facebook》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》，主要是怕两个并发的写操作导致脏数据。
那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。
所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。
Read/Write Through Pattern
我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。
Read Through
Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。
Write Through
Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）
下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。

Write Behind Caching Pattern
Write Behind 又叫 Write Back。一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。所以，基础很重要，我已经不是一次说过基础很重要这事了。
Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。
但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。
另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。
在wikipedia上有一张write back的流程图，基本逻辑如下：

&nbsp;
再多唠叨一些
1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略，所以这也就是，工程学上所谓的Best Practice，遵从就好了。
2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I/O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。
3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子。千万不要似是而非地，想当然的做软件设计。
4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit/rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《分布式系统的事务处理》一文。
（全文完）
&nbsp;
&nbsp;
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2012年05月03日 用Unix的设计思想来应对多变的需求2013年02月01日 从面向对象的设计模式看软件设计2012年03月26日 需求变化与IoC2013年07月05日 IoC/DIP其实是一种管理思想2013年07月30日 7个示例科普CPU Cache2009年03月02日 101个设计模式2011年05月03日 读书笔记：对线程模型的批评2010年11月26日 JDK里的设计模式
</content>
</doc><doc>
    <docid>5</docid>
    <url>http://coolshell.cn/articles/17391.html</url>
    <title>为什么我不在微信公众号上写文章</title>
    <content>很多朋友问我为什么不在微信公众号上写文章。我都没有直接回答，老实说，我也是扭扭捏捏的，才去开了个个人的微信的公众号，而且还只能搜索我博客这边的文章，我承认现在的阅读都在移动端，而且微信的公众号是国内移动端的文章流量及分享的入口，但是我还是更愿意使用blog这样的方式分享文章，最多也是在blog这边写好文章后，再去微信公众号那边贴一下。这个原因，不是因为我是一个老顽固，有习惯思维，而是，我不觉得微信公众号是一个好的信息传播和交流的平台。
我下面的言论仅仅代表我的个人观点，我不想强加给别人，我只是想说明一下为什么我不把我的blog迁移到微信公众号上。
首先，互联网是开放和共享的，不是封闭的。信息的传播更是需要开放的，大家可以看看互联网之子。

我希望我的文章能够被rss feed到各种阅读器中。
我希望我的文章可以被搜索引擎所检索到。
我希望我的文章能被别人整理，与其它人的文章放在一起互补。
我希望我的文章能被修改，因为文章会有错误，也会需要时常更新。

然而，微信公众号都不能很好的支持。我希望我的文章能成为生态圈的里的一部份。所谓生态圈是相互融合，不是唯我独尊。这个和做开源软件的道理一样，开源软件不是把源代码开出来就好了，而是要去和已有的其它软件互相融合，互相兼容，互相支持，这本就是软件设计的真谛（参看《UNIX编程艺术》）。所以，我想，写文章也一样。
下面是我觉得文章传播的姿势。

文章传播的姿势
我希望我的文章是被检索的，这意味着，就算文章写过了好多年，它依然可以被检索到，而不是在社交圈上被大众转了3-4天后就完了，然后再也没有然后了。
今天，我十多年前写的文章依然可以被检索到，依然对后来的新人有帮助。因为我的文章被搜索引擎检索了，我的文章被转载fork出去了，被人引用和标注，所以，可以长期被传播。
今天的酷壳（CoolShell.cn）已经很长时间没有更新了，然而里面的很多文章依然在被转发着，在被搜索着，在被重复阅读和被人推荐着，文章不断的被后来的人阅读。这就是被检索被共享被转载的好处。
同时，我并不希望成为某个平台写文章的苦力。在微信公众号下，你需要不断的更新才会积累起人气（订阅者），而文章的保鲜期非常有限，因为不能被检索，所以，你写的越多，你过去的文章也会被遗忘的越快。而微信公众平台让能写文章的人好像成为了这个平台的一个写作的奴隶，而不是让他们的文章中的内容和观点可以有长时间的影响力。换言之，在社交网络上，如果你要有影响力，你就要使劲写，需要更多的粉丝和订阅者。我个人认为这是违反了信息传播规律的。
最重要的是，我希望我的文章和观点是有讨论的，希望我的文章能被指正和批评，最好是引发讨论和思辨，这样才会让我们每一个人都可以在交流中成长。很多时候，文章本身并没有什么太大的价值，而引发的讨论和思辨才更有价值，这是我认为文章传播最正确的姿势。而微信的公众号在讨论方面人为的阻止或大大消弱了大家的沟通和讨论。虽然我承认有些讨论也是无效的，而且还有漫骂和跑题，但是我依然觉得讨论的利大于弊。
我私以为，信息的传播正确姿势，是被检索、讨论、引用、整理、补充和更新，而不是社交网络的转发、点赞、粉丝、订阅和打赏。
换句话说，我关注的是的文章的长期价值，而不是短期的表象。
关于文章的版权
很多人认为，封闭的平台有个比开放平台天然的优势，就是盗版和抄袭的问题，可以通过平台举报和惩罚对方。我以前也受到一些被抄袭和盗用的困扰，还曾经拿起来法律的武器维护自己的权利。
可能是我经历这样的事情比较早，所以，我今天在这个问题上不纠结了。
1、好的有价值的文章总是被人盗用抄袭的，这也算是对作者的一种认可吧。
2、我从来没有见过有人靠抄袭和盗用别人文章而成功的，无非就是收获几个赞罢了。
3、原创文章被人过抄袭和盗用，反而容易得到更多的关注。
微信公众号的原创保护也只是局限在微信上，微信之外的平台，它也无能为力，所以，对于我的文章会被转到很多地方的这种情况来看，微信公众号的原创保护也非常有限。
现在，我倒是不纠结有人会盗用和抄袭我的文章，因为，一方面，你可以有一些小伎俩来保护你的文章，比如在文章内容中放入一些你自己特有的标识，另一方面，我的文章被人盗用了抄袭的时候，总有一些网友能在盗用者那边指出来原文章是什么，并批评之。所以，还是应该把主要精力放在文章的内容和质量上，并让文章可以被检索和被更多的地方所引用，这样，你的文章才会得到最大的保护。
另外，既然别人对我的文章有抄袭和盗用的需求，要不我就让别人干得更体面一些。所以，我的文章完全可以自由的转载，但不得用于商业目的，只需要注明作者和出处就好了。
&nbsp;
关于写文章挣钱
首先，如果你觉得写文章出书是可以挣钱的，那么你可以洗洗睡了，尤其是在中国，这几乎是不可能的。
当然，你要挣点小钱是可以有的，但是，你需要写软文中植入广告，或是消费热点主题，比如前段时间的魏则西事件，有的公众号被打赏了一些钱。
老实说，这对我来说完全无感，因为，我的逻辑是这样的：我觉得一个人有一定的影响力，其中有很大一部份原因来自他的独立性，如果我开始写软文了，相当于我把自己卖了。
所以，我现在从来不通过写文章挣钱，因为我会写代码，我还是通过我的技能挣钱，通过给一些公司做咨询、培训、企业服务挣钱，老实说，靠自己的能力挣钱，比写文章挣钱挣得多多了，因为我觉得，像我写的这类的文章本来就是用来分享和传播的，不是用来挣钱的。写文章的目的是分享和影响，不是挣钱。
关于独立性，这里说两个花絮吧——
我在Amazon的时候，我和公司讲，我想在我的博客上写几篇关于亚马逊的文章，介绍亚马逊的技术和一些做事的方法，也算是个宣传，让我的团队也好招人，但是，我当时的老板和我说，你的博客之所以有影响力是因为你的独立性，不要写亚马逊的，这样会把你自己卖了，千万别这么做。
然而，我在Alibaba的时候，我的大老板要求我用我的博客和微博帮阿里云做营销，我非常委婉地拒绝了，结果，团队合作的价值观不达标了。呵呵。
P.S. 本来酷壳上是不做广告的，今天，酷壳上也广告，但是广告费是全部捐给Wikipedia的，广告主的钱是没有到我的手的。
微信公众号上的文章都有软文和广告植放，我觉得这不是我的调调，我害怕微信公众平台的整体格调影响了我的格调。就好像我认为我的网络被百度检索到了会我的网站的格调下降好几个档次。所以，我还是保持一定的距离吧。
这么说吧，我写文章不是为了挣钱，我也不认为写文章能挣到钱，我写文章就是为了分享和影响，我会借助社交网络，但不会寄宿在社交网络上，更不会被社交网络所绑架。
谢谢看我的唠叨！
（全文完）
&nbsp;
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2012年10月24日 TF-IDF模型的概率解释2009年06月30日 Top 200的全球开发者BLOG2012年08月12日 InfoQ的ArchSummit大会对我的采访2009年03月10日 怎样做一个 Program Manager2010年10月26日 你和你的工作2010年10月09日 Google未公开API：转MAC地址为经纬度2016年08月18日 这多年来我一直在钻研的技术2011年01月17日 Linux的cycle日历（你懂的）
</content>
</doc><doc>
    <docid>6</docid>
    <url>http://coolshell.cn/articles/17381.html</url>
    <title>性能测试应该怎么做？</title>
    <content>偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。
首先，这份测试报告里的主要问题如下：
1）用的全是平均值。老实说，平均值是非常不靠谱的。
2）响应时间没有和吞吐量TPS/QPS挂钩。而只是测试了低速率的情况，这是完全错误的。
3）响应时间和吞吐量没有和成功率挂钩。

为什么平均值不靠谱
关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，平均工资，平均房价，平均支出，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）
软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。
我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。
另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。
当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP &#8211; Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。
比如：我们有一组数据：[ 10ms,  1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4*0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4*0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。
我以前在路透做的金融系统响应时间的性能测试的要求是这样的，99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。
为什么响应时间（latency）要和吞吐量（Thoughput）挂钩
系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。
我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。

所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。
&nbsp;
为什么响应时间吞吐量和成功率要挂钩
我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是
40%，那么，这10万的并发完全就是一个笑话了。
性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。
&nbsp;
如何严谨地做性能测试
一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU/MEM/IO/Bandwidth&#8230;），成功率，系统稳定性。
下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。
一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。
二，在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。
三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能
四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。
五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。
六、低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。
（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）
是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。
欢迎大家也分享一下你们性能测试的经验和方法。
（全文完）
&nbsp;
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2012年06月20日 性能调优攻略2012年11月20日 如何测试洗牌程序2012年12月19日 Web工程师的工具箱2014年01月20日 分布式系统的事务处理2013年05月30日 无锁HashMap的原理与实现2014年04月17日 从LongAdder看更高效的无锁实现2012年01月16日 由12306.cn谈谈网站性能技术 2012年03月13日 多版本并发控制(MVCC)在分布式系统中的应用
</content>
</doc><doc>
    <docid>7</docid>
    <url>http://coolshell.cn/articles/17295.html</url>
    <title>让我们来谈谈分工</title>
    <content>昨天，我看到一个新闻——雅虎取消了QA团队，工程师必须自己负责代码质量，并使用持续集成代替QA。 同时，也听到网友说，“听微软做数据库运维的工程师介绍，他们也是把运维工程师和测试工程师取消了，由开发全部完成。每个人都是全栈工程师”。于是，我顺势引用了几年前写过一篇文章《我们需要专职的QA吗？》，并且又鼓吹了一下全栈。当然，一如既往的得到了一些的争议和嘲弄;-)。
有人认为取消QA基本上是公司没钱的象征，这个观点根本不值一驳，属于井底之蛙。有人认为，社会分工是大前提，并批评我说怎么不说把所有的事全干的，把我推向了另外一个极端。另外，你千万不要以为有了分工，QA的工作就保得住了。
就像《乔布斯传》中乔布斯质疑财务制度的时候说的，有时候，很多人都不问为什么，觉得存在的东西都是理所应当的东西。让我们失去了独立思考的机会。分工也是一样。
所以，为了说完整分工这个逻辑。请大家耐住性子，让我就先来谈谈“分工的优缺点”吧。

分工的优点和缺点
首先，分工（Division of Labour）应该是由 Adam Smith 在1776年的《国富论》中提出来的，Adam在那时候就观察到分工对于手工业生产效率的提高。他将效率提高的原因归结于三点：

熟练程度的增加。当一个工人单纯地重复同一道工序时，其对这道工序的熟练程度会大幅增加。表现为产量和质量的提高。
如果没有分工，由一道工序转为另一道工序时会损失时间，而分工避免了这中间的损失。
由于对于工序的了解和熟练度的增加，更有效率的机械和工具被发明出来，从而提高了产量。

分工的确是提高生产力。我想到了福特公司一开始做出来的汽车几乎卖不出去，原因有两个，一个是成本太高，另外是生产太复杂，产能太低。于是福特公司开始把制造一辆汽车的工序分解开来，进行分工，分工给福特公司带来的好处是：

很多工作可以并行了，而且因为事情变得简单后，执行力也变强了
一个非常复杂和高深的汽车制造因为分工后，很多工作不需要很NB的人来干了，只需要一般劳动者经过简单的培训就可以干了。而且，越干越熟练，越干越专业，最终可能让合适的人合适的事。
分工后导致了很多重复劳动可以用技术来解决，于是福特公司出现生产流水线的技术（你是否还记得卓别林《摩登时代》里的工业生产流水线的场景，那取自福特公司）。

于是，福特公司的生产效率大大提高，最终实现了让每个美国家庭都能买得起汽车的理想，同时让美国成为了轮子上的国家。
不过，我们需要注意的是，在《国富论》中，Adam他同时也提到，分工如果过细，同样会带来问题——简单重复的劳动会让人变成一个不会思考的机器，从而越来越笨，进而变成平庸的无技能的人。自“分工”出现以后，争论就没有停止过。
Karl Max同样认为分工越来越细，会导致人的技术越来越差，同时，大量的重复劳动也会导致人对工作的失出热情，产生厌倦和抵触心理，最终会导致生产力的下降。
同时，还有一些经济学家也同样表明分工的一些缺点：

导致人只关注整个事情中的一小块，缺乏全局视角，导致视野受限，没有完全领会工作的意义和目标，从而导致各种返工。


对于组织而言，分工也会导致出现大量的沟通协同成本，并出现碎片的生产方式，以及组织的孤岛形式，并不利于提高生产力。

当然，奥地利经济学家Ludwig von Mises 并不这么认为，他认为，在分工所得到的好处面前，这些副作用不算什么。并且，他认为在资本主义的制度下，完全是可以平衡分工的各种优点和各种缺点，从而可以达到提高生产力和提高人员素质的双赢解的。
比如说，分工中的各种沟通问题是可以通过一个标准协议来解的，造灯泡的，造开关的，造灯座的完全不知道对方的存在，他们只所以可以让做出来的东西拼在一起，完全是通过了一种标准协议完成的。这也是为什么这个世界上有各种各样的标准化的组织。
还有很多经济学家对分工都有自己的见解和想法。不过基本上就是上面这些Pros和Cons了。下图是一个PPT的两个slids，可以点击看大图（来源）








全球化下的分工
分工带来问题在全球化的浪潮下变得尤为突出。其委婉地被讲成是比较优势（Comparative Advantage）
比较优势（又叫相对优势）是经济学的概念，解释了为何在拥有相对的机会成本的优势下生产，贸易对双方都有利。当一方（一个人，一间公司，或一国）进行一项生产时所付出的机会成本比另一方低，这一方面拥有了进行这项生产的比较优势。于是，一个国家倘若专门生产自己相对优势较大的产品，并通过国际贸易换取自己不具有相对优势的产品就能获得利益。
于是乎，分工本来想要的是——合适的人干合适的事，但是在比较优势的情况下，商业社会把分工变成了——不是选择合适的人、公司或国家，而是选择成本低的人、公司或国家。
经济合作与发展组织OECD最近（2015年6月28日）对全球化这样建议的——
“有效率的政策的本质不是阻止失业而是鼓励就业，如果各个国家都在收获全球化的利益而不是开放贸易的话，那么一些地方就会失去工作机会，当然也伴随着在另一些地方出现新的工作机会，这是全球化进程不可避免的，而我们面对的挑战是怎么能流畅调整我们的流程，能为那些新出现的工作机会找到合适的技能匹配的工人”。
通过上面的说明，我想你可以知道，为什么中国成为了世界劳动力大国，而为什么当初美国科技公司进入中国的时候，首先把测试的工作放到了中国。这就是所谓的全球化分工。同时我们也可以看到，像我们中国这样技术能力的确非常不足的国家，的确是可以通过分工这种形式，让我们这些技能一般的技术人员参与一个复杂的有技术含量的项目当中。这其中就是分工的光明面和阴暗面。
那么，我们想一想，随着中国的人力成本的越来越大，国际化的分工因为商业资本的因素，必然不会选择中国，只会选择人力成本更低的国家，比如印度、越南、甚至人力成本更低的国家。美国雅虎和Adobe不是离开中国了么？再看看中国因为人民币的汇率或是人力成本的上升，我们在早几年关了多少个Made in China的工厂，这就是全球化的分工，商业上来说，他不是找最合适的人，而是找成本最低的人。
所以，你千万不要以为我一提倡全栈了，你QA的工作就保不住了，就算没有全栈，就算是你还在坚持的社会化的分工，也可能让你的QA的工作就保不住了，除非，你能提供更低的价格。（想想这其中的逻辑吧，人家美国人把一些技术工作（比如测试）外包到中国的原因不是因为中国人聪明，想得周全，适合干这个测试这个事，而是因为中国人廉价，所以，当中国不在廉价了，自然就会找更廉价的地方了）
为什么国家要从Made in China转型？不就是因为中国早期拿到的国际化分工就是这些没有技术含量的支持性的分工么？也因此而造就了大量的技能很一般的工人。为了能在全球化分工中能拿到更有质量的工作，我们必然要从劳动密集型转向成知识密集型，必然要从支持性的工作转变为产出性的工作，必然需要单一技能型的技工转变为复合型的人才。
分工的温床和天敌
分工的温床主要有两个，

一个是成本和效率，资本家或企业主或一个国家为了追求更快成本更底的生产方式，他们必然会进行大规模的分工，伴随着分工，他们也会把一些知识或技术密集型的工作生生地变成劳动密集型的工作。然后层层外包。


一个是组织的大小，当一个组织的人数不断的变大，那么，你只能把工作和任务分得更细。这是被人数逼的，而不是实际需要的。这就是为什么我们可以看到很多大公司里要么人浮于事，要么瞎忙。

分工的天敌主要有一个——那就是技术！
每当新技术出现的时候，一些复杂的工序会被一台机器或是一种高超的技术所取代，不管是被技术自动化，还是被技术所简化，总之，以前本来需要数十人或是数百人才能干的事，突然之间只需要一个人就可以干完了。生产力得到了巨大的释放。所以，你这就是我们常听的——科技是第一生产力！
说到这里，让我们再来看看雅虎的那条新闻——
在软件开发流程中去掉QA团队会发生什么？更少的代码错误，更快的开发周期。这是雅虎工程师过去一年的实验结果。雅虎的Warp Drive计划将程序开发从批发布转移了持续交付模式，工程师的代码不经过QA团队的人工检查而是直接发布。开发模式的转变导致了处理问题理念的根本性改变，迫使工程师开发自动检查工具去识别原来由人工检查发现的错误。雅虎的技术团队现在全部是工程师，而不再有QA团队容身之处。雅虎的首席架构师 Amotz Maimon说，他们本来预计可能会发生严重问题，结果出乎意料，每个曾经对此抱有怀疑态度的人都说新做法很有效。
所以，当你面对一些难题的时候，比如线上的故障，或是一个复杂的软件生产活动，你是要加更多的流程更多的人呢，还是要用技术解决问题呢？一边是温床，一边是天敌，你想好了吗？
什么样分工才是好的
分工是必然的，因为很简单，你不可能一个人干完所有的事情，所以必需要分工，分工不是问题，而问题则变成了——什么样的分工是理想的，是优雅的，是有效率的？
华君武漫画《科学分工？》
对于分工来说，一般来是一种组织和管理形为。就目前来说，现代的公司有两种分工模式，分别是Control 和 Commitment 这两种分工。

Control就是控制型的管理，它是一种是基于工作技能的分工，于是员工会被这种分工分配到一个比较窄的技能里去完成一个非常明确的工作。


而Commitment则是面向员工的责任心和所承担的目标来分工并完成工作的。相比起前者来说，这样的分工在完成工作时，需要的不仅仅是技能，还需要更多的责任感。

这么说吧，

对于基于工作技能的分工，你会看到，这样的公司会把技术人员按编程语言来分，比如：Java、PHP、C/C++，或是分成：Web端、iOS端、Android端、后端、算法、数据。或是分成：开发，测试，运维。


对于基于Commitment的分工，你会看到他们这样分的，软件工程师（不分前后端，不分语言，不分运维，测试），因为这样的公司认为，他招的不是只有特定语言技能的Coder，而是而学多种语言多种技术能保证软件质量以及能对软件维护的软件工程师。这种公司的软件工程师是各种团队都可以去的，而他们的分工更多的是按软件的功能，软件的模块，或是软件的产品线来分工。

基于技能的分工已是过去时，而基于 Commitment 的分工是更有效率的分工的未来。你可以参看McAlister-Kizzier, Donna. 的文献 &#8220;Division of Labor.&#8221; 。
小结
我说了这么多，不知道你看懂了我想表达什么没有？我不强加我的价值观，只希望你自己问自己几个问题：
1）作为工作的人，在分工中你会怎样选择？是成为一颗棋子，一颗螺丝钉，还是成为一个多面手？
2）作为工作的人，当你选择工作或任务的时候，你是选择做支持性的工作，还是做产出性的工作？你是选择做劳动密集型重复工作，还是做知识密集型的创新性的工作？
3）作为老板，你是想要什么样的员工？听话的只会加班和干重复工作的劳动力，还是有责任心的为企业和产品负责的员工？
4）作为老板，你是想通过分工释放低端员工的生产力，还是通过科技或技术去创造更NB的生产力？
5）作为老板，分工中的问题，你找到比较优的解了吗？比如，对于不同团队间的协议，你找到了吗？
可能，在不同的情况下你会有不同的答案。但是对我来说呢，无论是什么情况，我都只会有一个答案。
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2013年07月24日 加班与效率2013年03月11日 《Rework》摘录及感想2011年10月25日 多些时间能少写些代码2016年09月18日 什么是工程师文化？2013年07月05日 IoC/DIP其实是一种管理思想2014年04月12日 从Code Review 谈如何做技术2012年04月11日 我们需要专职的QA吗？2011年07月06日 软件公司的两种管理方式
</content>
</doc><doc>
    <docid>8</docid>
    <url>http://coolshell.cn/articles/17225.html</url>
    <title>Cuckoo Filter：设计与实现</title>
    <content>（感谢网友 @我的上铺叫路遥 投稿）

对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。
索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。
时下一个非常流行的哈希索引结构就是bloom filter，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（来源wikipedia），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。


但是，bloom filter的这种位图模式带来两个问题：一个是误报（false positives），在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是漏报（false nagatives），同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。
关于元素删除的问题，一个改良方案是对bloom filter引入计数，但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。
Cuckoo Hashing
为了解决这一问题，本文引入了一种新的哈希算法——cuckoo filter，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。先说明一下，这个算法的思想来源是一篇CMU论文，笔者按照其思路用C语言做了一个简单实现（Github），附上对一段文本数据进行导入导出的正确性测试。
接下来我会结合自己的示例代码讲解哈希算法的实现。我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。如下图所示（图片来源）：

&nbsp;
我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？
一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（CMU论文数据据说达到90%以上，应该是扩大了slot关联数目所致）。

Cuckoo Filter设计与实现
cuckoo hashing的原理介绍完了，下面就来演示一下笔者自己实现的一个cuckoo filter应用，简单易用为主，不到500行C代码。应用场景是这样的：假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。

#define SECTOR_SIZE    (1 &lt;&lt; 10)
#define DAT_LEN        (SECTOR_SIZE - 20)  /* minus sha1 size */

/* The log entries store key-value pairs on flash and the
 * size of each entry is assumed just one sector fit.
 */
struct log_entry {
        uint8_t sha1[20];
        uint8_t data[DAT_LEN];
};

顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。
以上是flash的存储结构，至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。

enum { AVAILIBLE, OCCUPIED, DELETED, };

/* The in-memory hash bucket cache is to filter keys (which is assumed SHA1) via
 * cuckoo hashing function and map keys to log entries stored on flash.
 */
struct hash_slot_cache {
        uint32_t tag : 30;  /* summary of key */
        uint32_t status : 2;  /* FSM */
        uint32_t offset;  /* offset on flash memory */
};

乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。
至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。

#define ASSOC_WAY  (4)  /* 4-way association */

struct hash_table {
    struct hash_slot_cache **buckets;
    struct hash_slot_cache *slots;
    uint32_t slot_num;
    uint32_t bucket_num;
};

int cuckoo_filter_init(size_t size)
{
    ...
    /* Allocate hash slots */
    hash_table.slot_num = nvrom_size / SECTOR_SIZE;
    /* Make rehashing happen */
    hash_table.slot_num /= 4;
    hash_table.slots = calloc(hash_table.slot_num, sizeof(struct hash_slot_cache));
    if (hash_table.slots == NULL) {
        return -1;
    }

    /* Allocate hash buckets associated with slots */
    hash_table.bucket_num = hash_table.slot_num / ASSOC_WAY;
    hash_table.buckets = malloc(hash_table.bucket_num * sizeof(struct hash_slot_cache *));
    if (hash_table.buckets == NULL) {
        free(hash_table.slots);
        return -1;
    }
    for (i = 0; i &lt; hash_table.bucket_num; i++) {
        hash_table.buckets[i] = &amp;hash_table.slots[i * ASSOC_WAY];
    }
}

下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num &#8211; 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。

#define cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] &amp; (count - 1))
#define cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] &amp; (count - 1))

终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。
static int cuckoo_hash_get(struct hash_table *table, uint8_t *key, uint8_t **read_addr)
{
    int i, j;
    uint8_t *addr;
    uint32_t tag[2], offset;
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table-&gt;bucket_num);
    tag[1] = cuckoo_hash_msb(key, table-&gt;bucket_num);

    /* Filter the key and verify if it exists. */
    slot = table-&amp;gt;buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        if (slot[i].status == OCCUPIED) {
            offset = slot[i].offset;
            addr = key_verify(key, offset);
            if (addr != NULL) {
                if (read_addr != NULL) {
                    *read_addr = addr;
                }
                break;
            }
        } else if (slot[i].status == DELETED) {
            return DELETED;
        }
    }
    ...
}
接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的，所以很多flash支持随机读，但必须保持顺序写。
static void cuckoo_hash_delete(struct hash_table *table, uint8_t *key)
{
    uint32_t i, j, tag[2];
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table-&gt;bucket_num);
    tag[1] = cuckoo_hash_msb(key, table-&gt;bucket_num);

    slot = table-&gt;buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        slot[i].status = DELETED;
        return;
    }
    ...
}
了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。
static int cuckoo_hash_collide(struct hash_table *table, uint32_t *tag, uint32_t *p_offset)
{
    int i, j, k, alt_cnt;
    uint32_t old_tag[2], offset, old_offset;
    struct hash_slot_cache *slot;

    /* Kick out the old bucket and move it to the alternative bucket. */
    offset = *p_offset;
    slot = table-&gt;buckets[tag[0]];
    old_tag[0] = tag[0];
    old_tag[1] = slot[0].tag;
    old_offset = slot[0].offset;
    slot[0].tag = tag[1];
    slot[0].offset = offset;
    i = 0 ^ 1;
    k = 0;
    alt_cnt = 0;

KICK_OUT:
    slot = table-&gt;buckets[old_tag[i]];
    for (j = 0; j &lt; ASSOC_WAY; j++) {
        if (offset == INVALID_OFFSET &amp;&amp; slot[j].status == DELETED) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            *p_offset = offset = slot[j].offset;
            break;
        } else if (slot[j].status == AVAILIBLE) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            slot[j].offset = old_offset;
            break;
        }
    }

    if (j == ASSOC_WAY) {
        if (++alt_cnt &gt; 512) {
            if (k == ASSOC_WAY - 1) {
                /* Hash table is almost full and needs to be resized */
                return 1;
            } else {
                k++;
            }
        }
        uint32_t tmp_tag = slot[k].tag;
        uint32_t tmp_offset = slot[k].offset;
        slot[k].tag = old_tag[i ^ 1];
        slot[k].offset = old_offset;
        old_tag[i ^ 1] = tmp_tag;
        old_offset = tmp_offset;
        i ^= 1;
        goto KICK_OUT;
    }

    return 0;
}
rehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意，千万不能有相同的key混进来！虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~
static void cuckoo_rehash(struct hash_table *table)
{
    ...
    uint8_t *read_addr = nvrom_base_addr;
    uint32_t entries = log_entries;
    while (entries--) {
        uint8_t key[20];
        uint32_t offset = read_addr - nvrom_base_addr;
        for (i = 0; i &amp;lt; 20; i++) {
            key[i] = flash_read(read_addr);
            read_addr++;
        }
        /* Duplicated keys in hash table which can cause eternal
         * hashing collision! Be careful of that!
         */
        assert(!cuckoo_hash_put(table, key, &amp;offset));
        if (cuckoo_hash_get(&amp;old_table, key, NULL) == DELETED) {
            cuckoo_hash_delete(table, key);
        }
        read_addr += DAT_LEN;
    }
    ...
}
到此为止代码的逻辑还是比较简单，使用效果如何呢？我来帮你找个大文件unqlite.c测试一下，这是一个嵌入式数据库源代码，共59959行代码。作为需要导入的文件，编译我们的cuckoo filter，然后执行：
./cuckoo_db unqlite.c output.c
你会发现生成output.c正好也是59959行代码，一分不差，probably yes终于变成了definitely yes。同时也可以看到，cuckoo filter真的很快！如果你想看hashing的整个过程，可以参照README里把调试宏打开。最后，欢迎给这个小玩意提交PR！
参考资料
Cuckoo Filter的论文和PPT：Cuckoo Filter: Practically Better Than Bloom
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2013年10月09日 伙伴分配器的一个极简实现2011年02月28日 打印质数的各种算法2012年09月07日 无锁队列的实现2012年05月17日 rsync 的核心算法2013年07月14日 二叉树迭代器算法2014年08月06日 谜题的答案和活动的心得体会2014年08月03日 【活动】解迷题送礼物2011年05月04日 可视化的数据结构和算法
</content>
</doc><doc>
    <docid>9</docid>
    <url>http://coolshell.cn/articles/17200.html</url>
    <title>Docker基础技术：DeviceMapper</title>
    <content>在上一篇介绍AUFS的文章中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。
Device Mapper 简介
DeviceMapper自Linux 2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。
Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。
Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。

DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。
DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略（让我不自然地想到了面向对象中的策略模式），在这诸多“插件”中，有一个东西叫Thin Provisioning Snapshot，这是Docker使用DeviceMapper中最重要的模块。
图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/
Thin Provisioning 简介
Thin Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”——操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，意思是，我逻辑上给你无限多的内存，但是实际上是实报实销，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin Provisioning的技术，所谓的超配，或是超卖）
&nbsp;
好了，话题拉回来，我们这里说的是存储。看下面两个图（图片来源），第一个是Fat Provisioning，第二个是Thin Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）
 
那么，Docker是怎么使用Thin Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin Provisioning的Snapshot的技术。下面我们来介绍一下Thin Provisioning的Snapshot。
Thin Provisioning Snapshot 演示
下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot是怎么玩的。
首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：
~hchen$ sudo dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s

~hchen$ sudo dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s
注意命令中seek选项，其表示为略过of选项指定的输出文件的前10G个output的bloksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了12K和4K。
~hchen$ sudo ls -lsh /tmp/data.img
12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img

~hchen$ sudo ls -slh /tmp/meta.data.img
4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img
然后，我们为这个文件创建一个loopback设备。（loop2015和loop2016是我乱取的两个名字）
~hchen$ sudo losetup /dev/loop2015 /tmp/data.img
~hchen$ sudo losetup /dev/loop2016 /tmp/meta.data.img

~hchen$ sudo losetup -a
/dev/loop2015: [64768]:103991768 (/tmp/data.img)
/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)
现在，我们为这个设备建一个Thin Provisioning的Pool，用dmsetup命令：
~hchen$ sudo dmsetup create hchen-thin-pool \
                  --table &quot;0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \
                           128 65536 1 skip_block_zeroing&quot;
其中的参数解释如下（更多信息可参看Thin Provisioning的man page）：

dmsetup create是用来创建thin pool的命令
hchen-thin-pool 是自定义的一个pool名，不冲突就好。
&#8211;table是这个pool的参数设置

0代表起的sector位置
20971522代码结句的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB
/dev/loop2016是meta文件的设备（前面我们建好了）
/dev/loop2015是data文件的设备（前面我们建好了）
128是最小的可分配的sector数
65536是最少可用sector的water mark，也就是一个threshold
1 代表有一个附加参数
skip_block_zeroing是个附加参数，表示略过用0填充的块



然后，我们就可以看到一个Device Mapper的设备了：
~hchen$ sudo ll /dev/mapper/hchen-thin-pool
lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -&gt; ../dm-4
接下来，我们的初始还没有完成，还要创建一个Thin Provisioning 的 Volume：
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_thin 0&quot;
~hchen$ sudo dmsetup create hchen-thin-volumn-001 \
            --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&quot;
其中：

第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id
第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。2097152只有1GB

好了，在mount前，我们还要格式化一下：
~hchen$ sudo mkfs.ext4 /dev/mapper/hchen-thin-volumn-001
mke2fs 1.42.9 (28-Dec-2013)
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=16 blocks, Stripe width=16 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
好了，我们可以mount了（下面的命令中，我还创建了一个文件）
~hchen$ sudo mkdir -p /mnt/base
~hchen$ sudo mount /dev/mapper/hchen-thin-volumn-001 /mnt/base
~hchen$ sudo echo &quot;hello world, I am a base&quot; &gt; /mnt/base/id.txt
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base
好了，接下来，我们来看看snapshot怎么搞：
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 1 0&quot;
~hchen$ sudo dmsetup create mysnap1 \
                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&quot;

~hchen$ sudo ll /dev/mapper/mysnap1
lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -&gt; ../dm-5
上面的命令中：

第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev id，第二个是要从哪个已有的dev id上做snapshot（0这个dev id是我们前面就创建了了）


第二条命令是创建一个mysnap1的device，并可以被mount。

下面我们来看看：
~hchen$ sudo mkdir -p /mnt/mysnap1
~hchen$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1

~hchen$ sudo ll /mnt/mysnap1/
total 20
-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt
drwx------. 2 root root 16384 Aug 25 23:43 lost+found

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：
~hchen$ sudo echo &quot;I am snap1&quot; &gt;&gt; /mnt/mysnap1/id.txt
~hchen$ sudo echo &quot;I am snap1&quot; &gt; /mnt/mysnap1/snap1.txt

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
I am snap1

~hchen$ sudo cat /mnt/mysnap1/snap1.txt
I am snap1
我们再看一下/mnt/base，你会发现没有什么变化：
~hchen$ sudo ls /mnt/base
id.txt      lost+found
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base
你是不是已经看到了分层镜像的样子了？
你还要吧继续在刚才的snapshot上再建一个snapshot
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 2 1&quot;
~hchen$ sudo dmsetup create mysnap2 \
                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 2&quot;

~hchen$ sudo ll /dev/mapper/mysnap2
lrwxrwxrwx. 1 root root 7 Aug 25 23:52 /dev/mapper/mysnap1 -&gt; ../dm-7

~hchen$ sudo mkdir -p /mnt/mysnap2
~hchen$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2
~hchen$ sudo  ls /mnt/mysnap2
id.txt  lost+found  snap1.txt 
好了，我相信你看到了分层镜像的样子了。
看完演示，我们再来补点理论知识吧：

Snapshot来自LVM（Logic Volumn Manager），它可以在不中断服务的情况下为某个device打一个快照。
Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝。

另外，这里有篇文章Storage thin provisioning benefits and challenges可以前往一读。
Docker的DeviceMapper
上面基本上就是Docker的玩法了，我们可以看一下docker的loopback设备：
~hchen $ sudo losetup -a
/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)
/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)
其中data 100GB，metadata 2.0GB
~hchen $ sudo ls -alhs /var/lib/docker/devicemapper/devicemapper
506M -rw-------. 1 root root 100G Sep 10 20:15 data
1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata 
下面是相关的thin-pool。其中，有个当一大串hash串的device是正在启动的容器：
~hchen $ sudo ll /dev/mapper/dock*
lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -&gt; ../dm-2
lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -&gt; ../dm-3
我们可以看一下它的device id（Docker都把它们记下来了）：
~hchen $ sudo cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf
{&quot;device_id&quot;:24,&quot;size&quot;:10737418240,&quot;transaction_id&quot;:26,&quot;initialized&quot;:false}
device_id是24，size是10737418240，除以512，就是20971520 个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev id &#8211; 1024）：
~hchen$ sudo dmsetup message &quot;/dev/mapper/docker-253:0-104108535-pool&quot; 0 \
                                    &quot;create_snap 1024 24&quot;
~hchen$ sudo dmsetup create dockersnap --table \
                    &quot;0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024&quot;
~hchen$ sudo mkdir /mnt/docker
~hchen$ sudo mount /dev/mapper/dockersnap /mnt/docker/
~hchen$ sudo ls /mnt/docker/
id lost+found rootfs
~hchen$ sudo ls /mnt/docker/rootfs/
bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var
我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：
# findmnt
TARGET                SOURCE               
/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]
/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]
/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]
/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]
Device Mapper 行不行？
Thin Provisioning的文档中说，这还处理实验阶段，不要上Production.
These targets are very much still in the EXPERIMENTAL state. Please do not yet rely on them in production.
另外，Jeff Atwood在Twitter上发过这样的一推

这个推指向的这个讨论中，其中指向了这个code diff，基本上就是说，DeviceMapper这种东西问题太多了，我们应该把其加入黑名单。Doker的Founder也这样回复到：

所以，如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：
rm -rf /var/lib/docker
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2015年04月17日 Docker基础技术：Linux CGroup2015年08月24日 Docker基础技术：AUFS2015年04月16日 Docker基础技术：Linux Namespace（下）2015年04月16日 Docker基础技术：Linux Namespace（上）2009年03月16日 Linux 相关的资源站makelinux.net2013年01月09日 应该知道的Linux技巧2009年05月10日 十个你可能不曾用过的Linux命令2014年11月21日 vfork 挂掉的一个问题
</content>
</doc><doc>
    <docid>10</docid>
    <url>http://coolshell.cn/articles/17061.html</url>
    <title>Docker基础技术：AUFS</title>
    <content>AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。
AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。
不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。
好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）

首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。
$ tree
.
├── fruits
│   ├── apple
│   └── tomato
└── vegetables
    ├── carrots
    └── tomato


然后，我们输入以下命令：
# 创建一个mount目录
$ mkdir mnt

# 把水果目录和蔬菜目录union mount到 ./mnt目录中
$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt

#  查看./mnt目录
$ tree ./mnt
./mnt
├── apple
├── carrots
└── tomato
我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。
我们来修改一下其中的文件内容：
$ echo mnt &gt; ./mnt/apple
$ cat ./mnt/apple
mnt
$ cat ./fruits/apple
mnt
上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。
$ echo mnt_carrots &gt; ./mnt/carrots
$ cat ./vegetables/carrots 

$ cat ./fruits/carrots
mnt_carrots

上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。
也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）
所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：
$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt

$ echo &quot;mnt_carrots&quot; &gt; ./mnt/carrots 

$ cat ./vegetables/carrots
mnt_carrots

$ cat ./fruits/carrots
cat: ./fruits/carrots: No such file or directory
现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？
$ echo &quot;mnt_tomato&quot; &gt; ./mnt/tomato 

$ cat ./fruits/tomato
mnt_tomato

$ cat ./vegetables/tomato
I am a vegetable
可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。
你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。
那么，这种UnionFS有什么用？
历史上，有一个叫Knoppix的Linux发行版，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。
我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。
Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在介绍Linux Namespace上篇中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。
下图来自Docker的官方文档Layer，其很好的展示了Docker用UnionFS搭建的分层镜像。

关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 &#8211;storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：
/var/lib/docker/aufs/diff/&lt;id&gt; 
在docker执行起来后（比如：docker run -it ubuntu /bin/bash ），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：
#ls /sys/fs/aufs/si_b71b209f85ff8e75/
br0      br2      br4      br6      brid1    brid3    brid5    xi_path
br1      br3      br5      brid0    brid2    brid4    brid6 

# cat /sys/fs/aufs/si_b71b209f85ff8e75/*
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh
/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh
/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh
/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh
/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh
/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh
64
65
66
67
68
69
70
/run/shm/aufs.xino
你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。
关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。
AUFS的一些特性
AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。
上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：

rw表示可写可读read-write。
ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。
rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。

权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。
一般来说ro的分支都会有wh的属性，比如 &#8220;[dir]=ro+wh&#8221;。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。
看个例子：
假设我们有三个目录和文件如下所示（test是个空目录）：
# tree
.
├── fruits
│   ├── apple
│   └── tomato
├── test
└── vegetables
    ├── carrots
    └── tomato
我们如下mount：
# mkdir mnt

# mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt

# # ls ./mnt/
apple  carrots  tomato 
现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:
 # touch ./test/.wh.apple

# ls ./mnt
carrots  tomato
上面这个操作和 rm ./mnt/apple是一样的。
相关术语
Branch – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）

Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。
Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限

Whiteout 和 Opaque

如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。


Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。


Opaque的意思就是不允许任何下层的某个目录显示出来。


在隐藏低层档的情况下，whiteout的名字是’.wh.&lt;filename&gt;’。


在阻止readdir的情况下，名字是’.wh..wh..opq’或者 ’.wh.__dir_opaque’。

相关问题
看到上面这些，你一定会有几个问题：
其一、你可能会问，要有文件在原来的地方被修改了会怎么样？mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s Direct Branch Access），这个参数有三个取值：

udba=none – 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。
udba=reval – 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。
udba=notify – 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。

其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？ aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。
create=rr | round−robin 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中

hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt
hchen$ touch ./mnt/a ./mnt/b ./mnt/c
hchen$ tree
.
├── 1
│   └── a
├── 2
│   └── c
└── 3
    └── b
create=mfs[:second] | most−free−space[:second] 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。
create=mfsrr:low[:second] 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round-robin 方式。
更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过 man aufs 来看一下其中的各种参数和命令。
AUFS的性能
AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。
所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。
IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《An Updated Performance Comparison of Virtual Machinesand Linux Containers》
我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）

&nbsp;
顺序读写

&nbsp;
随机读写
延伸阅读

Introduce UnionFS
Union file systems: Implementations, part I
Union file systems: Implementations, part 2
Another union filesystem approach
Unioning file systems: Architecture, features, and design choices

（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2015年04月17日 Docker基础技术：Linux CGroup2015年04月16日 Docker基础技术：Linux Namespace（下）2015年08月26日 Docker基础技术：DeviceMapper2015年04月16日 Docker基础技术：Linux Namespace（上）2009年04月13日 Ubuntu的并行启动2009年06月30日 Ksplice Uptrack — Ubuntu更新不用重启2009年05月10日 十个你可能不曾用过的Linux命令2009年08月14日 你用Linux命令行吗？
</content>
</doc><doc>
    <docid>11</docid>
    <url>http://coolshell.cn/articles/17049.html</url>
    <title>Docker基础技术：Linux CGroup</title>
    <content>前面，我们介绍了Linux Namespace，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。
Linux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ &#8212; 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。
主要提供了如下功能：


Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。
Accounting: 一些审计或一些统计，主要目的是为了计费。
Control: 挂起进程，恢复执行进程。

使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。
在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：

隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。
为这组进程 分配其足够使用的内存
为这组进程分配相应的网络带宽和磁盘存储限制
限制访问某些设备（通过设置设备的白名单）

那么CGroup是怎么干的呢？我们先来点感性认识吧。
首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。
hchen@ubuntu:~$ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)
或者使用lssubsys命令：
$ lssubsys  -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
net_cls /sys/fs/cgroup/net_cls
net_prio /sys/fs/cgroup/net_prio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。
如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：
mkdir cgroup
mount -t tmpfs cgroup_root ./cgroup
mkdir cgroup/cpuset
mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
mkdir cgroup/cpu
mount -t cgroup -ocpu cpu ./cgroup/cpu/
mkdir cgroup/memory
mount -t cgroup -omemory memory ./cgroup/memory/
一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：
hchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ 
/sys/fs/cgroup/cpu:
cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
cgroup.procs           cpu.cfs_quota_us      notify_on_release  user

/sys/fs/cgroup/cpuset/:
cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
cgroup.procs           cpuset.memory_pressure          notify_on_release
cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
cpuset.cpus            cpuset.memory_spread_slab       user
cpuset.mem_exclusive   cpuset.mems
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。
hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel
[sudo] password for hchen: 
hchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel
cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release
好了，我们来看几个示例。
CPU 限制
假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：
int main(void)
{
    int i = 0;
    for(;;) i++;
    return 0;
}
用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）
  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
 3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop   
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：
hchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
-1
root@ubuntu:~# echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us
我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：
# echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks
然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）
  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
 3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop    
下面的代码是一个线程的示例：
#define _GNU_SOURCE         /* See feature_test_macros(7) */

#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;


const int NUM_THREADS = 5;

void *thread_main(void *threadid)
{
    /* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */
    char cmd[128];
    sprintf(cmd, &quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks&quot;, syscall(SYS_gettid));
    system(cmd); 
    sprintf(cmd, &quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks&quot;, syscall(SYS_gettid));
    system(cmd);

    long tid;
    tid = (long)threadid;
    printf(&quot;Hello World! It's me, thread #%ld, pid #%ld!\n&quot;, tid, syscall(SYS_gettid));
    
    int a=0; 
    while(1) {
        a++;
    }
    pthread_exit(NULL);
}
int main (int argc, char *argv[])
{
    int num_threads;
    if (argc &gt; 1){
        num_threads = atoi(argv[1]);
    }
    if (num_threads&lt;=0 || num_threads&gt;=100){
        num_threads = NUM_THREADS;
    }

    /* 设置CPU利用率为50% */
    mkdir(&quot;/sys/fs/cgroup/cpu/haoel&quot;, 755);
    system(&quot;echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us&quot;);

    mkdir(&quot;/sys/fs/cgroup/cpuset/haoel&quot;, 755);
    /* 限制CPU只能使用#2核和#3核 */
    system(&quot;echo \&quot;2,3\&quot; &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus&quot;);

    pthread_t* threads = (pthread_t*) malloc (sizeof(pthread_t)*num_threads);
    int rc;
    long t;
    for(t=0; t&lt;num_threads; t++){
        printf(&quot;In main: creating thread %ld\n&quot;, t);
        rc = pthread_create(&amp;threads[t], NULL, thread_main, (void *)t);
        if (rc){
            printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc);
            exit(-1);
        }
    }

    /* Last thing that main() should do */
    pthread_exit(NULL);
    free(threads);
}

内存使用限制
我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int size = 0;
    int chunk_size = 512;
    void *p = NULL;

    while(1) {

        if ((p = malloc(p, chunk_size)) == NULL) {
            printf(&quot;out of memory!!\n&quot;);
            break;
        }
        memset(p, 1, chunk_size);
        size += chunk_size;
        printf(&quot;[%d] - memory is allocated [%8d] bytes \n&quot;, getpid(), size);
        sleep(1);
    }
    return 0;
}
然后，在我们另外一边：
# 创建memory cgroup
$ mkdir /sys/fs/cgroup/memory/haoel
$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes

# 把上面的进程的pid加入这个cgroup
$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks 
你会看到，一会上面的进程就会因为内存问题被kill掉了。
磁盘I/O限制
我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）
sudo dd if=/dev/sda1 of=/dev/null
我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
 8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null...
然后，我们先创建一个blkio（块设备IO）的cgroup
mkdir /sys/fs/cgroup/blkio/haoel
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：
root@ubuntu:~# echo '8:0 1048576'  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
root@ubuntu:~# echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks
再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
 8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null...
CGroup的子系统
好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：

blkio &#8212; 这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB 等​​​等​​​）。
cpu &#8212; 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​
cpuacct &#8212; 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​
cpuset &#8212; 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​ CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​
devices &#8212; 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​
freezer &#8212; 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​
memory &#8212; 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup 中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​
net_cls &#8212; 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​ Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​
net_prio &#8212; 这个子系统用来设计网络流量的优先级
hugetlb &#8212; 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。
​​​
注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：
$ sudo modprobe cls_cgroup
$ sudo mkdir /sys/fs/cgroup/net_cls
$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls

$ sudo modprobe netprio_cgroup
$ sudo mkdir /sys/fs/cgroup/net_prio
$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio
关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：

Linux Kernel的官方文档
Redhat的官方文档

CGroup的术语
CGroup有下述术语：

任务（Tasks）：就是系统的一个进程。
控制组（Control Group）：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。
层级（Hierarchy）：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。
子系统（Subsystem）：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。

下一代的CGroup
上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。
不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里对cgroup吐了一把槽，还引发了内核组的各种讨论。
对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。 
层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。
所以，在Kernel 3.16后，引入了unified hierarchy的新的设计，这个东西引入了一个叫__DEVEL__sane_behavior的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。
我们mount一下看看：
$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup

$ ls ./cgroup
cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control 

$ cat ./cgroup/cgroup.controllers
cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb
我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。上级的cgroup.subtree_control控制下级的cgroup.controllers。
举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。

# A(b,m) - B(b,m) - C (b)
#               \ - D (b) - E

# 下面的命令中， +表示enable， -表示disable

# 在B上的enable blkio
# echo +blkio &gt; A/cgroup.subtree_control

# 在C和D上enable blkio 
# echo +blkio &gt; A/B/cgroup.subtree_control

# 在B上enable memory  
# echo +memory &gt; A/cgroup.subtree_control
在上述的结构中，

cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。
任何被配置过subtree_control的目录都不能绑定进程，根结点除外。所以，A,C,D,E可以绑上进程，但是B不行。

我们可以看到，这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。
当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。
参考

Linux Kernel Cgroup Documents
Reahat Resource Management Guide
Fixing control groups
The unified control group hierarchy in 3.16
Cgroup v2(PDF)

（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2015年08月24日 Docker基础技术：AUFS2015年08月26日 Docker基础技术：DeviceMapper2015年04月16日 Docker基础技术：Linux Namespace（下）2015年04月16日 Docker基础技术：Linux Namespace（上）2012年06月20日 性能调优攻略2013年01月09日 应该知道的Linux技巧2014年11月21日 vfork 挂掉的一个问题2009年05月10日 十个你可能不曾用过的Linux命令
</content>
</doc><doc>
    <docid>12</docid>
    <url>http://coolshell.cn/articles/17010.html</url>
    <title>Docker基础技术：Linux Namespace（上）</title>
    <content>时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New &#8220;Old Stuff&#8221;。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。
当然，文章的风格一定会尊重时下的“流行”——我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）
废话少说，我们开始。先从Linux Namespace开始。
 简介
Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。

举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）
Linux Namespace 有如下种类，官方文档在这里《Namespace in Operation》



分类
系统调用参数
相关内核版本




Mount namespaces
CLONE_NEWNS
Linux 2.4.19


UTS namespaces
CLONE_NEWUTS
Linux 2.6.19


IPC namespaces
CLONE_NEWIPC
Linux 2.6.19


PID namespaces
CLONE_NEWPID
Linux 2.6.24


Network namespaces
CLONE_NEWNET
始于Linux 2.6.24 完成于 Linux 2.6.29


User namespaces
CLONE_NEWUSER
始于 Linux 2.6.23 完成于 Linux 3.8)



主要是三个系统调用

clone() &#8211; 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。
unshare() &#8211; 使某进程脱离某个namespace
setns() &#8211; 把某进程加入到某个namespace

unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。
下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。
clone()系统调用
首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];

char* const container_args[] = {
    &quot;/bin/bash&quot;,
    NULL
};

int container_main(void* arg)
{
    printf(&quot;Container - inside the container!\n&quot;);
    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */
    execv(container_args[0], container_args); 
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    printf(&quot;Parent - start a container!\n&quot;);
    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);
    /* 等待子进程结束 */
    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。
下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。
UTS Namespace
下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。
int container_main(void* arg)
{
    printf(&quot;Container - inside the container!\n&quot;);
    sethostname(&quot;container&quot;,10); /* 设置hostname */
    execv(container_args[0], container_args);
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    printf(&quot;Parent - start a container!\n&quot;);
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */
    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。
hchen@ubuntu:~$ sudo ./uts
Parent - start a container!
Container - inside the container!
root@container:~# hostname
container
root@container:~# uname -n
container
IPC Namespace
IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。
要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。
int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL); 
首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0）
hchen@ubuntu:~$ ipcmk -Q 
Message queue id: 0

hchen@ubuntu:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0    
如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。
hchen@ubuntu:~$ sudo ./uts 
Parent - start a container!
Container - inside the container!

root@container:~# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0    
但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：
root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!

root@container:~/linux_namespace# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
我们可以看到IPC已经被隔离了。
PID Namespace
我们继续修改上面的程序：
int container_main(void* arg)
{
    /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */
    printf(&quot;Container [%5d] - inside the container!\n&quot;, getpid());
    sethostname(&quot;container&quot;,10);
    execv(container_args[0], container_args);
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    printf(&quot;Parent [%5d] - start a container!\n&quot;, getpid());
    /*启用PID namespace - CLONE_NEWPID*/
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); 
    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
运行结果如下（我们可以看到，子进程的pid是1了）：
hchen@ubuntu:~$ sudo ./pid
Parent [ 3474] - start a container!
Container [    1] - inside the container!
root@container:~# echo $$
1
你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。
但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。
所以，我们还需要对文件系统进行隔离。
Mount Namespace
下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。
int container_main(void* arg)
{
    printf(&quot;Container [%5d] - inside the container!\n&quot;, getpid());
    sethostname(&quot;container&quot;,10);
    /* 重新mount proc文件系统到 /proc下 */
    system(&quot;mount -t proc proc /proc&quot;);
    execv(container_args[0], container_args);
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    printf(&quot;Parent [%5d] - start a container!\n&quot;, getpid());
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
运行结果如下：
hchen@ubuntu:~$ sudo ./pid.mnt
Parent [ 3502] - start a container!
Container [    1] - inside the container!
root@container:~# ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash
0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf

上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：
root@container:~# ls /proc
1          dma          key-users   net            sysvipc
16         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
下图，我们也可以看到在子进程中的top命令只看得到两个进程了。

这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。


--make-shared ： 共享方式的mount，主要是为了文件的共享和镜像。



--make-slave ： 这种mount方式更大的意义是为了“只读”的场景，也就是从动式的mount。



--make-private：这种mount方式主要就是为了隔离。如proc文件系统。



--make-unbindable：标记为不可绑定。




-->
你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。
Docker的 Mount Namespace
下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。
首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：
hchen@ubuntu:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）
hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin
 
./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：
hchen@ubuntu:~/rootfs/bin$ ldd bash
	linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)
	libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)
	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)
下面是我的rootfs中的一些so文件：
hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
包括这些命令依赖的一些配置文件：
hchen@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。
hchen@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。
好了，终于到了我们的程序。
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char* const container_args[] = {
    &quot;/bin/bash&quot;,
    &quot;-l&quot;,
    NULL
};

int container_main(void* arg)
{
    printf(&quot;Container [%5d] - inside the container!\n&quot;, getpid());

    //set hostname
    sethostname(&quot;container&quot;,10);

    //remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container's information
    if (mount(&quot;proc&quot;, &quot;rootfs/proc&quot;, &quot;proc&quot;, 0, NULL) !=0 ) {
        perror(&quot;proc&quot;);
    }
    if (mount(&quot;sysfs&quot;, &quot;rootfs/sys&quot;, &quot;sysfs&quot;, 0, NULL)!=0) {
        perror(&quot;sys&quot;);
    }
    if (mount(&quot;none&quot;, &quot;rootfs/tmp&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) {
        perror(&quot;tmp&quot;);
    }
    if (mount(&quot;udev&quot;, &quot;rootfs/dev&quot;, &quot;devtmpfs&quot;, 0, NULL)!=0) {
        perror(&quot;dev&quot;);
    }
    if (mount(&quot;devpts&quot;, &quot;rootfs/dev/pts&quot;, &quot;devpts&quot;, 0, NULL)!=0) {
        perror(&quot;dev/pts&quot;);
    }
    if (mount(&quot;shm&quot;, &quot;rootfs/dev/shm&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) {
        perror(&quot;dev/shm&quot;);
    }
    if (mount(&quot;tmpfs&quot;, &quot;rootfs/run&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) {
        perror(&quot;run&quot;);
    }
    /* 
     * 模仿Docker的从外向容器里mount相关的配置文件 
     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，
     * 你会看到docker的这些文件的。
     */
    if (mount(&quot;conf/hosts&quot;, &quot;rootfs/etc/hosts&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 ||
          mount(&quot;conf/hostname&quot;, &quot;rootfs/etc/hostname&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 ||
          mount(&quot;conf/resolv.conf&quot;, &quot;rootfs/etc/resolv.conf&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 ) {
        perror(&quot;conf&quot;);
    }
    /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */
    if (mount(&quot;/tmp/t1&quot;, &quot;rootfs/mnt&quot;, &quot;none&quot;, MS_BIND, NULL)!=0) {
        perror(&quot;mnt&quot;);
    }

    /* chroot 隔离目录 */
    if ( chdir(&quot;./rootfs&quot;) != 0 || chroot(&quot;./&quot;) != 0 ){
        perror(&quot;chdir/chroot&quot;);
    }

    execv(container_args[0], container_args);
    perror(&quot;exec&quot;);
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    printf(&quot;Parent [%5d] - start a container!\n&quot;, getpid());
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：
hchen@ubuntu:~$ sudo ./mount 
Parent [ 4517] - start a container!
Container [    1] - inside the container!
root@container:/# mount
proc on /proc type proc (rw,relatime)
sysfs on /sys type sysfs (rw,relatime)
none on /tmp type tmpfs (rw,relatime)
udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)
devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)
tmpfs on /run type tmpfs (rw,relatime)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)

root@container:/# ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more	mv	 ping  rm   sleep  tail  test	  top	 truncate  uname
cat    chown  grep  ip	      ln    mount	nc	 ps    sed  tabs   tar	 timeout  touch  tty	   which
chgrp  cp     gzip  kill      ls    mountpoint	netstat  pwd   sh   tac    tee	 toe	  tr	 umount

/usr/bin:
awk  env  groups  head	id  mesg  sort	strace	tail  top  uniq  vi  wc  xargs
关于如何做一个chroot的目录，这里有个工具叫DebootstrapChroot，你可以顺着链接去看看（英文的哦）
接下来的事情，你可以自己玩了，我相信你的想像力 。：）
在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。
  >>> 
（上篇完，请参看下篇）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2015年04月16日 Docker基础技术：Linux Namespace（下）2015年08月26日 Docker基础技术：DeviceMapper2015年08月24日 Docker基础技术：AUFS2015年04月17日 Docker基础技术：Linux CGroup2009年04月18日 Linux设备驱动Hello World程序介绍2009年08月14日 你用Linux命令行吗？2009年10月28日 ldd 的一个安全问题2009年04月25日 Linux 的僵尸(zombie)进程
</content>
</doc><doc>
    <docid>13</docid>
    <url>http://coolshell.cn/articles/17029.html</url>
    <title>Docker基础技术：Linux Namespace（下）</title>
    <content>在 Docker基础技术：Linux Namespace（上篇）中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。
好，下面我们就介绍一下还剩下的这两个Namespace。
User Namespace
User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。
要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/&lt;pid&gt;/uid_map 和 /proc/&lt;pid&gt;/gid_map 这两个文件。这两个文件的格式为：
ID-inside-ns ID-outside-ns length
其中：


第一个字段ID-inside-ns表示在容器显示的UID或GID，
第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。
第三个字段表示映射的范围，一般填1，表示一一对应。

比如，把真实的uid=1000映射成容器内的uid=0
$ cat /proc/2465/uid_map
         0       1000          1
再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形
$ cat /proc/$$/uid_map
         0          0          4294967295
另外，需要注意的是：

写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities）
写入的进程必须是此user namespace的父或子的user namespace进程。
另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。

这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/capability.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char* const container_args[] = {
    &quot;/bin/bash&quot;,
    NULL
};

int pipefd[2];

void set_map(char* file, int inside_id, int outside_id, int len) {
    FILE* mapfd = fopen(file, &quot;w&quot;);
    if (NULL == mapfd) {
        perror(&quot;open file error&quot;);
        return;
    }
    fprintf(mapfd, &quot;%d %d %d&quot;, inside_id, outside_id, len);
    fclose(mapfd);
}

void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, &quot;/proc/%d/uid_map&quot;, pid);
    set_map(file, inside_id, outside_id, len);
}

void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, &quot;/proc/%d/gid_map&quot;, pid);
    set_map(file, inside_id, outside_id, len);
}

int container_main(void* arg)
{

    printf(&quot;Container [%5d] - inside the container!\n&quot;, getpid());

    printf(&quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;,
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    /* 等待父进程通知后再往下执行（进程间的同步） */
    char ch;
    close(pipefd[1]);
    read(pipefd[0], &amp;ch, 1);

    printf(&quot;Container [%5d] - setup hostname!\n&quot;, getpid());
    //set hostname
    sethostname(&quot;container&quot;,10);

    //remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container's information
    mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL);

    execv(container_args[0], container_args);
    printf(&quot;Something's wrong!\n&quot;);
    return 1;
}

int main()
{
    const int gid=getgid(), uid=getuid();

    printf(&quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;,
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    pipe(pipefd);
 
    printf(&quot;Parent [%5d] - start a container!\n&quot;, getpid());

    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);

    
    printf(&quot;Parent [%5d] - Container [%5d]!\n&quot;, getpid(), container_pid);

    //To map the uid/gid, 
    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent
    //The file format is
    //   ID-inside-ns   ID-outside-ns   length
    //if no mapping, 
    //   the uid will be taken from /proc/sys/kernel/overflowuid
    //   the gid will be taken from /proc/sys/kernel/overflowgid
    set_uid_map(container_pid, 0, uid, 1);
    set_gid_map(container_pid, 0, gid, 1);

    printf(&quot;Parent [%5d] - user/group mapping done!\n&quot;, getpid());

    /* 通知子进程 */
    close(pipefd[1]);

    waitpid(container_pid, NULL, 0);
    printf(&quot;Parent - container stopped!\n&quot;);
    return 0;
}
上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。
整个程序的运行效果如下：
hchen@ubuntu:~$ id
uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)

hchen@ubuntu:~$ ./user #&lt;--以hchen用户运行
Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 
Parent [ 3262] - start a container!
Parent [ 3262] - Container [ 3263]!
Parent [ 3262] - user/group mapping done!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 0, UID=0, GID=0 #&lt;---Container里的UID/GID都为0了
Container [    1] - setup hostname!

root@container:~# id #&lt;----我们可以看到容器里的用户和命令行提示符是root用户了
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。
我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。
Network Namespace
Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。
首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）

上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。
当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：
hchen@ubuntu:~$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff
那么，要做成这个样子应该怎么办呢？我们来看一组命令：
## 首先，我们先增加一个网桥lxcbr0，模仿docker0
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址

## 接下来，我们要创建一个network namespace - ns1

# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）
ip netns add ns1 

# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）
ip netns exec ns1   ip link set dev lo up 

## 然后，我们需要增加一对虚拟网卡

# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中
ip link add veth-ns1 type veth peer name lxcbr0.1

# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了
ip link set veth-ns1 netns ns1

# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0 

# 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up


# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1

# 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1

# 在/etc/netns下创建network namespce名称为ns1的目录，
# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/netns/ns1/resolv.conf 
上面基本上就是docker网络的原理了，只不过，


Docker的resolv.conf没有用这样的方式，而是用了上篇中的Mount Namesapce的那种方式

另外，docker是用进程的PID来做Network Namespace的名称的。

了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：
ip link add peerA type veth peer name peerB 
brctl addif docker0 peerA 
ip link set peerA up 
ip link set peerB netns ${container-pid} 
ip netns exec ${container-pid} ip link set dev peerB name eth1 
ip netns exec ${container-pid} ip link set eth1 up ; 
ip netns exec ${container-pid} ip addr add ${ROUTEABLE_IP} dev eth1 ;
上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。
这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。
当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。
这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的。
Namespace文件
上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。
让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。
$ sudo ./pid.mnt 
[sudo] password for hchen: 
Parent [ 4599] - start a container!
Container [    1] - inside the container!
我们到另一个shell中查看一下父子进程的PID：
hchen@ubuntu:~$ pstree -p 4599
pid.mnt(4599)───bash(4600)
我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。
下面是父进程的：
hchen@ubuntu:~$ sudo ls -l /proc/4599/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]
下面是子进程的：
hchen@ubuntu:~$ sudo ls -l /proc/4600/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]
我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。
这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount &#8211;bind /proc/4600/ns/uts ~/uts 来hold这个namespace。
另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：
int setns(int fd, int nstype);
其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：
fd = open(&quot;/proc/4600/ns/nts&quot;, O_RDONLY);  // 获取namespace文件描述符
setns(fd, 0); // 加入新的namespace 
参考文档

Namespaces in operation
Linux Namespace Man Page
Creat Containers &#8211; Part 1
Introduction to Linux namespaces
（应网友card323加入）

（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2015年04月16日 Docker基础技术：Linux Namespace（上）2015年08月24日 Docker基础技术：AUFS2015年08月26日 Docker基础技术：DeviceMapper2015年04月17日 Docker基础技术：Linux CGroup2012年06月20日 性能调优攻略2014年11月21日 vfork 挂掉的一个问题2011年03月29日 如何学好C语言2010年04月09日 Unix传奇(下篇)
</content>
</doc><doc>
    <docid>14</docid>
    <url>http://coolshell.cn/articles/17066.html</url>
    <title>关于移动端的钓鱼式攻击</title>
    <content>今天，在微博上看了一篇《微信和淘宝到底是谁封谁》的文章，我觉得文章中逻辑错乱，所以，我发了一篇关于这篇文章逻辑问题的长微博。后面，我被原博主冷嘲热讽了一番，说是什么鸡汤啊，什么我与某某之流的人在一起混淆视听啊，等等。并且也有一些网友找我讨论一下相关的钓鱼式攻击的技术问题。所以，我想写下这篇纯技术文章，因为我对那些商业利益上的东西不关心，所以，只谈技术，这样最简单。
首先说明一下，我个人不是一个安全专家，也不是一个移动开发专家，按道理来说，这篇文章不应该我来写，但是我就试一试，请原谅我的无知，也期待抛砖引玉了，希望安全的同学斧正。
关于钓鱼式攻击，其实是通过一种社会工程学的方式来愚弄用户的攻击式，攻击者通常会模仿一个用户信任的网站来偷取用户的机密信息，比如用户密码或是信用卡。一般来说，攻击者会通过邮件和实时通信工具完成，给被攻击者发送一个高仿的网站，然后让用户看不出来与正统网站的差别，然后收集用户的机密数据。
移动端钓鱼攻击点分析
因为钓鱼式攻击并不新鲜，所以我这里只讲移动方面的。
在移动端，这个事情会更容易干，因为移动端有如下特点：

移动端的UI只能有一个应用占据整个屏幕，你只能看到一个应用，而且用户屏幕小，能显示的信息有限，比如浏览器里的网址是显示不全的。这会给钓鱼攻击有很多可乘之机。


移动端的平台有其安全的设计。每个应用都是隔离开的，一个应用无法获取另一个应用的数据。而且应用的下载基本上来说都是来自合法的地方。比如iOS的设备通过App Store下载，每个程序都有自己的签名保证不会被篡改。而且移动端的的应用有各种权限配置，这样也能很大程度提高安全性。


移动端的APP有些有些是收费的，所以自然会有盗版需求，虽然在平台上做了一些安全设计，但是并不完美。用户可以越狱，可以root。这给恶意软件有了可乘之机。

下面我们来分析下移动端的用户操作，我们重点关注用户控制权的切换过程（因为这是攻击点）

在移动设备上，基本上来说，用户的控制切换有四种：

从一个APP切到另一个APP，也就是我们所谓的唤出APP。
从一个APP唤出一个Web，常见为一个嵌入式的WebView或是一个浏览器
从一个Web唤出一个APP，这需要浏览器支持一些非标准的HTTP协议，比如skype://之类的。
从一个Web到另一个Web，这和Web上的方式差不多。

基本上来说，黑客的攻击从来都是找这样的转换环节来做文章的，并且需要一个用户非常熟悉的场景（这样用户才会放松警惕）。
通过观察移动APP的特性，我们可以知道，当用户控制切换时，有下面的这些特性：

到另一个APP时，需要用户登录（如果登录的session过期了）
当支付的时候，需要用户输入支付信息（信用卡信息、支持密码）

那么用户在移动APP上经常做的事是什么？

社交分享：分享到微博，分享到微信等等，分享的时候，可能需要你输入用户名和口令。


应用内购：一般来说APP会有两种，一种免费的，一种是收费的，大量的用户都是下载免费的，然后通过什么“开通更多关卡”、“去广告”、“买道具”之类的东西，让用户输入支付信息。Apple的支付的时候也会要用户输入Apple ID的密码。


点击链接：有时候，我们收到短信，或是二维码，或是一个微信微博，会让我们去点击一个网站链接，这个网站链接要么就是打开一个网页，要么就是启动应用，要么就是跳转到应用市场去下载应用（如果你没安装）。

所以，一个好的钓鱼式攻击一定会从这些地方入手，然后高仿UI以及交互流程，这个交互流程和用户日常操作的完全一样，让用户无法察觉。任何方式的钓鱼攻击简单来说，会有两种：

一种是直接攻击：你下载了一个恶意的APP，或是打开了一个恶意的冒牌APP。
一种是中间人攻击：用户控制权转换时的两端都是正规应用，但是中间的过程不是正常的。

攻击方式
下面是一些常见的攻击方式：
从一个应用唤起另一个应用的方式
直接攻击
当你点击一个社交分享按钮，或是一个支付按钮的时候。就会转到一个页面，这个页面需要你输入用户机密信息（密码或是支付信息），然后再唤起真正的APP。
一个有恶意的APP可能会让你放松警惕，因为，这个你在安装这个APP的时候，你会发现这个APP根本不需要任何的权限（Android上的），甚至连网络访问的权限都不要，因为在Android下，App可以通过别的组件访问互联网，比如：恶意应用可能创建一个MediaPlayer Object，然后就可以通过这个对象访问一个URL然后把偷到的信息发送出去。
你的手机要被安装一个恶意的应用并不难，同样通过社工的方式，比如：盗版，色情，伪装成客服等等通过人性的弱点让你去一些非受信的市场上安装。iOS设备上的应用也可以不用通过App Store安装（通过itms-services协议，可以通过safari浏览器直接在IOS设备上安装应用程序）。
还有，人们都是贪小便宜的人，所以，会到某些地方买一些便宜的手机（比如淘宝），现在的高仿手机，翻新的二手手机对于一般人甚至安全专家来说完全没有识别能力。这些手机中有很大可能藏有恶意程序。你千万不要以为你格式化手机就OK了。今天（2015年4月14日）早上CCTV2台的“第一时间”就说了一个案例，你可以看看。另外，你可以看看相关的新闻。（另外，你把你的旧手机卖了也要小心，因为你的数据就在里面，旧手机已经成了一个灰色产业链）
另外，Apple的App需要有一个review过程，这个过程对大众是神秘的，但我觉得应该会包括安全方面的review。不过，这个审核过程可能也有空子可以钻。比如：在review的时候，这个应用完全正常，但在用户使用的时候，会自己从网站下载一些自己的配置文件而改变行为（更为直接的就是访问外部网页时在审核时和在用户应用时可能完全不一样，Apple应该完全没有能力审核应用要访问的外部站点）
中间人攻击
我们知道，一个APP唤起另一个APP好多都是用url-scheme的，也就是某种协议，审核这样的协议非常简单，所以如果有恶意的东西在里面基本上很容易看到。但是，如果某些APP并没有注册自己的url-scheme，或是没有被安装，反而，另一个有恶意的APP注册了这个scheme，那么，就会导致恶意的APP被唤起来了（这就是我为什么在我的微博中说，如果用户没有安装淘宝的客户端，那么，让微信唤起淘宝的客户端时，有可能是另一个有恶意的APP。但是很多人不懂这个事。在iOS下，两个APP通讯正确的做法是“钥匙串机制”）。
当然如果有两个应用被注册了同一个scheme，那么，iOS和Android会给出一个选择，让用户来选（注：iOS的系统有可能会直接跳某个 App 上去，不同版本的跳规则不明确，可以认为是随机跳转）。于是乎，恶意的APP就要努力的让自己比正规的APP看起来更像个正规的APP就可以了。
在Android平台上，这个事可能更变态，只要恶意的应用有两个权限，一个是随手机操作系统在后台启动，一个是task list（然而这两个权限都是一般权限）。这样一来，当你进行两个APP切换时，恶意程序可以通过task list权限监控到，然后自己马上先于正规的app出现，等到收集完用户数据后简单的退出就好了。这个方式只需要你的程序能在10ms以内反应过来（最佳是5ms左右），人的肉眼根本看不出来。（在iOS设备下，除了jail break后的iPhone可以这么干，正常的都iPhone还没有找到这样的攻击方式）
在一个应用内内嵌Web的方式
这种方式更容易攻击了，现在很多很多应用都是内嵌的Web的形式，你完全不知道打开的网页的网站是什么，因为这些内嵌的WebView你连地址都看不见。而且无论是iOS或Android，其WebView都可以执行任何的Javascript代码，就算显示URL，URL也可能是被混乱过的，你也看不全，你也很容易上当。当然，那些使用带SSL证书的支持HTTPS的网站（尤其是EV证书）可以在地址栏上显示一个绿色的标记表示你访问的就是正确网址，但是并不是所有的浏览器都会这样，比如iPhone的Safari并没有这个提示，所以，你一定要用Chrome。
更狠的是就算你打开的是一个正确的URL，你依然可能被中间人攻击。尤其是这个网站使用了明文的HTTP协议，而你又喜欢蹭那些免费的WiFi，于是很容易给把服务器返回给你的网页中做修改，比如，修改网页中login表单或是支付表单提交的网站（想想天朝的网络运营商给你访问的正常的网页弹广告这事吧）
关于DNS劫持，有些人觉得这事可能遇不上，因为这是一个全网的问题，如果你有这样的想法你就错了。还是那样，你爱占便宜，蹭上那些没有密码的WiFi，你完不知道，你连上去的那个WiFi会设置什么样的DNS服务器，你输入了www.taobao.com，但你打开的网站根本就是不是淘定，而是一个钓鱼网站。你会知道你打开的是错的了么？基本不可能。所以，安全点的网站都是要用HTTPS，但是还是那句话，iPhone的Safari并不会提示你打开网站的SSL证书合不合法（事实上，在手机上的很多浏览器都不会这提示，只有Chrome会）。
关于攻击的方式我不想讲太多，还有很多高级+猥琐的方式我也不是完全知道，知道了我也不说，不然，教人犯罪了。
关于从Web端唤起APP是和，APP唤醒APP的攻击方式基本一样。我就不说了。
怎么防范钓鱼式攻击
首先，我们要知道，钓鱼式攻击是一件非常难搞的事。要搞定这个事，一般来说需要四个方面：立法层面、用户培训层面、宣传层面、与技术保全措施层面。
教育方面
打击网钓的策略之一，是试着培养人们识别网钓，并教导怎样处理这些问题。只需要稍稍修改人们浏览习惯的方式，很多问题都可以避免。随着人们越来越认识到网钓者所使用的社会工程学技俩，传统的网钓欺诈技术可能在未来过时。

对别人发来的链接要小心，尤其是让你输入机密信息的链接要小心检查。


到正规的地方买手机，不要贪图小便宜。旧手机在卖前要“物理删除”数据。


不要对手机越狱，不要root。


不要从非信任的地方下载软件。


要小心免费的WiFi。


输入机密数据的时候一定要小心检查。


多依赖一些不同的安全体系，比如：网上支付不要只依赖支付宝，尽量使用信用卡（信用卡千万不要设密码），这样就算是被钓鱼了，你还有一个银行安全的缓冲地带——可以不承认交易。


现在使用手机的频率越来越高，所以，我非常建议你使用更为安全的iPhone手机，一定要打开“查找我的iPhone”功能，然后设上开机密码。iPhone手机可以做到手机丢失了别人都无法使用，包括刷机都刷不了（iOS7以上版本）


对于一些关键网站，开启两步验证，这样就算你的用户名和密码被钓走了，还有一个动态手机口令做为登录的关卡。

技术方面

利用SSL证书来保证从浏览器到网站的访问是现在采用比较多的方式，也是在理论上可行的方式。现代的浏览器都会在URL上放上一个锁的标志，对于EV证书，你会看到浏览器的URL是绿色的（很容易分辨）


另外，像firefox浏览器有一个petname的插件，你可以为你常上的网站设置一些标签。这样，当你打开钓鱼网站的时候，你会发现这些标签没有显示出来，那就有问题了。


关于SSL的CA认证机构，你需要管理好你浏览的那些根证书，有些根证书你需要删掉。


还有一种打击网钓的流行作法是保持一份已知的网钓网站名单，并随时更新。比如PhishTank，以及中国防钓鱼网站联盟。


增加式登录方式。这种方式被美国银行采用，就是说，你可以上传一个你自己知道的图片，而当你打开登录页面里时，输入了自己的用户名后，你会看到你设置的这个图片被显示出来。如果没有或是显示错了，表示你打开的是钓鱼网站。


两步验证，通过用户自设密码+手机动态口令登录（好些网站都在使用Google Authenticator的方式，这有点像公司VPN的动态口令）。

上述都是PC Web上的防范，然而我们的手机移动端做的并不够好，移动端的安全还是要加油。
安全风控方面
什么叫安全风控，说白了就是拿钱出来赔偿给被骗的用户，大家相信我，这个事情在基本上所有的公司都会做的，也就是说，无论你怎么做安全也无法保证绝对的安全，你只能缓解或是降低用户被骗的数量或概率。所以，几乎所有的公司都会有一笔钱专门用来赔偿。
在西方国家，用户体验很好，我说一个故事，我有一个妹妹在英国，有一天她到ATM上取钱，取完钱后忘了把卡取出，结果后面的人把她的卡里的钱取走了，于是她报了警，等警察做完笔录后，她给银行的客服打了个电话说明了情况，本想冻结银行卡的，但是银行方面二话不说就赔偿了她所有的损失。为什么英国的巴克莱银行这么痛快，是因为他们有风控基金，专门用来处理这样的事的。
在中国，其实银行和一些大的公司都有这笔安全风控基金，但是，要你非常坚持不懈地申诉，他们才会赔给你，而且还不是全部。要全部的话，我估计你要做一个“刁民”，否则欺负你，没道理。
关于微信和淘宝
微信和淘宝到底是谁先屏蔽谁我并不关心，这里面的商业利益我也不关心，微信是不是支持卖东西我也不关心。我关心的是寒冬文章中所说的微信上有淘宝钓鱼的安全问题。
从技术上来说，我觉得要微信和淘宝一起干这事，单方都不行，需要两边的安全专家一起讨论（如果需要，我可以帮你们约）。我这里给一个可能很不成熟的方案，算是抛砖引玉（我不考虑你们之间的商业竞争，我只从用户的角度出发，客户第一）：
我觉得，从业务上来说，淘宝可以在微信上有一个官方的商城。而淘宝的商家，需要取得微信的认证后入住，才能分享相关的商品或店家链接，对此，商家入住，我觉得可通过微信的服务账号与淘宝的商家后台集成可以做到。
然后，商家也好，买家也好，他们分享商品只能通过微信官方的商城或是商家的服务账号分享出去，而分享出去的商品信息可以是一个比较unique的形式（比如有一个不能伪造的官方认证的标签），而用户的支付可以通过内置的微信支付也可以通过内置的支付宝（通过唤起App并不是一个好的方式，还是应该你们在服务端进行相互的通信）。
然后微信和淘宝双方通过宣传手段告诉全社会，微信里的商品什么才是正规的，才不是钓鱼的，并给教育用户更为安全地使用手机。
P.S. 我虽然这么说，但从我个人来说，我非常理解微信为了让用户有很好的体验而不让微信成为一个四处都是营销商品的地方。所以，我从个人来说，希望微信不要成为一个商家的营销地。另外，我也知道阿里对移动端的看重，所以，上述的方案虽然对用户体验和安全都比较好，但是从目前商业利益的情况看来基本无法实现。不过我这里也只是抛砖引玉了。
面对安全和用户这两个事，你们两个中国最大的互联网公司，应该带头做好榜样，你们都是不缺钱的公司，应该更多的承担起社会的责任，真正为用户做点什么，而不是整天想着流量入口，互相屏蔽，互相指责，想着自己能有多少用户，这TMD太LOW了，和你们的地位完全不符。所以，从站在用户的角度上来说，我希望微信和淘宝都能站在用户的角度上思考问题，一起合作来真正的为用户更好的服务。
（全文完）
关注CoolShell微信公众账号可以在手机端搜索文章

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell.cn ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——
本广告收入已由广告主捐给Wikipedia

相关文章2014年12月15日 DHH 谈混合移动应用开发2014年11月26日 Google Inbox如何跨平台重用代码？2011年08月25日 你会做Web上的用户登录功能吗？2011年11月28日 如何设计“找回用户帐号”功能2012年12月10日 程序员疫苗：代码注入2011年04月06日 一些有意思的文章和资源2014年04月21日 C语言的整型溢出问题2010年05月12日 HTML 安全列表
</content>
</doc><doc>
    <docid>15</docid>
    <url>https://book.douban.com/review/8132172/</url>
    <title>如果你也和我一样笑不出来 (评论: 你就适可而止吧)</title>
    <content>

林远远评论: 你就适可而止吧
评价: 推荐
</content>
</doc><doc>
    <docid>16</docid>
    <url>https://book.douban.com/review/8134254/</url>
    <title>心疼当初那个奋不顾身的自己 (评论: 最初不过你好)</title>
    <content>

喵了个咪评论: 最初不过你好
评价: 力荐
</content>
</doc><doc>
    <docid>17</docid>
    <url>https://book.douban.com/review/8141697/</url>
    <title>遇见你，才是最好的时光 (评论: 愿所有的姑娘都能嫁给爱情)</title>
    <content>

喵了个咪评论: 愿所有的姑娘都能嫁给爱情
评价: 力荐
</content>
</doc><doc>
    <docid>18</docid>
    <url>https://book.douban.com/review/8142275/</url>
    <title>编辑，原来也可以很摇滚 。 (评论: 金色梦乡)</title>
    <content>

绵羊油蜜糖评论: 金色梦乡
评价: 力荐
</content>
</doc><doc>
    <docid>19</docid>
    <url>https://book.douban.com/review/8141690/</url>
    <title>像现在这样生活就行，不要嘲笑和瞧不起现在的自己 (评论: 我不过别人指定的生活)</title>
    <content>

喵了个咪评论: 我不过别人指定的生活
评价: 力荐
</content>
</doc><doc>
    <docid>20</docid>
    <url>https://book.douban.com/review/8122102/</url>
    <title>满满一书的唐人风情 (评论: 唐人小说)</title>
    <content>

太常寺协律郎评论: 唐人小说
评价: 力荐
</content>
</doc><doc>
    <docid>21</docid>
    <url>https://book.douban.com/review/8143204/</url>
    <title>最孤独的魂游天外 (评论: 漫长的中场休息)</title>
    <content>

欢乐分裂评论: 漫长的中场休息
评价: 推荐
</content>
</doc><doc>
    <docid>22</docid>
    <url>https://book.douban.com/review/8135672/</url>
    <title>文学奇境的私人词典 (评论: 想象地名)</title>
    <content>

malingcat评论: 想象地名
评价: 力荐
</content>
</doc><doc>
    <docid>23</docid>
    <url>https://book.douban.com/review/8124455/</url>
    <title>遵从天意承受孤独 (评论: 天意)</title>
    <content>

棉花糖*胡子小姐东游记评论: 天意
评价: 力荐
</content>
</doc><doc>
    <docid>24</docid>
    <url>https://book.douban.com/review/8124867/</url>
    <title>作者好厉害，能把诺奖理论介绍得如此通俗！ (评论: 合适)</title>
    <content>

魔云兽评论: 合适
评价: 力荐
</content>
</doc><doc>
    <docid>25</docid>
    <url>https://book.douban.com/review/8142219/</url>
    <title>不能忘却的友情 (评论: 我在伦敦买了一头狮子)</title>
    <content>

喵了个咪评论: 我在伦敦买了一头狮子
评价: 力荐
</content>
</doc><doc>
    <docid>28</docid>
    <url>https://book.douban.com/review/8142679/</url>
    <title>我想陪你说说家国之外 (评论: 宋末大变局.四川风云  上册)</title>
    <content>

钟无艳评论: 宋末大变局.四川风云  上册
评价: 力荐
</content>
</doc><doc>
    <docid>29</docid>
    <url>https://book.douban.com/review/8127681/</url>
    <title>一本温暖而治愈的友人帐 (评论: 夏目友人帐)</title>
    <content>

喵了个咪评论: 夏目友人帐
评价: 力荐
</content>
</doc><doc>
    <docid>31</docid>
    <url>https://book.douban.com/review/8130532/</url>
    <title>真我至上：灵魂对肉体的背叛 (评论: 丹麦女孩)</title>
    <content>

喵了个咪评论: 丹麦女孩
评价: 力荐
</content>
</doc><doc>
    <docid>32</docid>
    <url>https://book.douban.com/review/8134157/</url>
    <title>“润物细无声”的习惯养成策略 (评论: 微习惯)</title>
    <content>

喵了个咪评论: 微习惯
评价: 力荐
</content>
</doc><doc>
    <docid>33</docid>
    <url>https://book.douban.com/review/8125359/</url>
    <title>像国王一样吃法国大餐 (评论: 愿上帝保佑法兰西厨子)</title>
    <content>

喵了个咪评论: 愿上帝保佑法兰西厨子
评价: 力荐
</content>
</doc><doc>
    <docid>34</docid>
    <url>https://book.douban.com/review/8142993/</url>
    <title>可持续发展是资源未来的发展方向 (评论: 图解全球资源真相)</title>
    <content>

喵了个咪评论: 图解全球资源真相
评价: 力荐
</content>
</doc><doc>
    <docid>35</docid>
    <url>http://blog.jobbole.com/107047/</url>
    <title>c 语言宏定义 #define 的理解与资料整理</title>
    <content>
1. 利用 define 来定义 数值宏常量

#define 宏定义是个演技非常高超的替身演员，但也会经常耍大牌的，所以我们用它要慎之又慎。它可以出现在代码的任何地方，从本行宏定义开始，以后的代码就就都认识这个宏了；也可以把任何东西定义成宏。因为编译器会在预编译的时候用真身替换替身，而在我们的代码里面却又用常常用替身来帮忙。
看例子：

#define PI 3.141592654

在此后的代码中你尽可以使用PI 来代替3.141592654，而且你最好就这么做。不然的话，如果我要把PI 的精度再提高一些，你是否愿意一个一个的去修改这串数呢？你能保证不漏不出错？而使用PI 的话，我们却只需要修改一次（这是十分高效的）。
这种情况还不是最要命的，我们再看一个例子：

#define ERROR_POWEROFF  -1

如果你在代码里不用ERROR_POWEROFF 这个宏而用-1，尤其在函数返回错误代码的时候（往往一个开发一个系统需要定义很多错误代码）。肯怕上帝都无法知道-1 表示的是什么意思吧。这个-1，我们一般称为“魔鬼数”，上帝遇到它也会发狂的。所以，我奉劝你代码里一定不要出现“魔鬼数”。(这里是从代码可读性的角度进行考虑！)
但是我们利用define来定义数值类型的数据，一般只是用来定义  常量 ，如果 要定义一些变量，则可以使用c语言中const这个关键字。
我们已经讨论了const 这个关键字，我们知道const 修饰的数据是有类型的，而define 宏定义的数据没有类型。为了安全，我建议你以后在定义一些宏常数的时候用const代替，编译器会给const 修饰的只读变量做类型校验，减少错误的可能。
但一定要注意const修饰的不是常量而是readonly 的变量，const 修饰的只读变量不能用来作为定义数组的维数，也不能放在case 关键字后面。
2.利用 define 来定义 字符串宏常量
除了定义宏常数之外，经常还用来定义字符串，尤其是路径：

A),#define ENG_PATH_1 E:\English\listen_to_this\listen_to_this_3
B),#define ENG_PATH_2 “E:\English\listen_to_this\listen_to_this_3”

噢，到底哪一个正确呢？如果路径太长，一行写下来比较别扭怎么办？用反斜杠接续符 &#8221; 啊：

C), #define ENG_PATH_3 E:\English\listen_to_this\listen\_to_this_3

还没发现问题？这里用了4 个反斜杠，到底哪个是接续符？回去看看接续符反斜杠。
反斜杠作为接续符时，在本行其后面不能再有任何字符，空格都不行。所以，只有最后一个反斜杠才是接续符。至于A)和B)，那要看你怎么用了，既然define 宏只是简单的替换，那给ENG_PATH_1 加上双引号不就成了：“ENG_PATH_1”。
但是请注意：有的系统里规定路径的要用双反斜杠“\”,比如（这是正确的版本）：

#define ENG_PATH_4 E:\\English\\listen_to_this\\listen_to_this_3

3.用 define 宏定义 注释符号
上面对define 的使用都很简单，再看看下面的例子：

#define BSC //
#define BMC /*
#define EMC */
 
D),BSC my single-line comment
E),BMC my multi-line comment EMC

D)和E)都错误，为什么呢？因为注释先于预处理指令被处理,当这两行被展开成//…或/*…*/时,注释已处理完毕,此时再出现//…或/*…*/自然错误.（这一条需要对编译预处理有所理解，才能体会。看来我还得再写一篇这方面的文章。）
因此,试图用宏开始或结束一段注释是不行的。
4.用define 宏定义表达式
这些都好理解，下面来点有“技术含量”的，定义一年有多少秒：

#define SEC_A_YEAR 60*60*24*365

这个定义没错吧？很遗憾，很有可能错了，至少不可靠。你有没有考虑在16 位系统下把这样一个数赋给整型变量的时候可能会发生溢出？一年有多少秒也不可能是负数吧。
改一下：

#define SEC_A_YEAR （60*60*24*365）UL

又出现一个问题，这里的括号到底需不需要呢？继续看一个例子，定义一个宏函数，求x 的平方：

#define SQR (x) x * x

对不对？试试：假设x 的值为10，SQR (x)被替换后变成10*10。没有问题。
再试试：假设x 的值是个表达式10+1，SQR (x)被替换后变成10+1*10+1。问题来了，这并不是我想要得到的。怎么办？括号括起来不就完了？

#define SQR (x) （（x）*（x））

最外层的括号最好也别省了，看例子，求两个数的和：

#define SUM (x) （x）+（x）

如果x 的值是个表达式5*3,而代码又写成这样：SUM (x)* SUM (x)。替换后变成：（5*3）+（5*3）*（5*3）+（5*3）。又错了！所以最外层的括号最好也别省了。我说过define 是个演技高超的替身演员，但也经常耍大牌。要搞定它其实很简单，别吝啬括号就行了。
注意这一点：宏函数被调用时是以实参代换形参。而不是“值传送”。
5.宏定义中的空格
另外还有一个问题需要引起注意，看下面例子：

#define SUM （x） （x）+（x）

这还是定义的宏函数SUM（x）吗？显然不是。编译器认为这是定义了一个宏：SUM，其代表的是（x） （x）+（x）。
为什么会这样呢？其关键问题还是在于SUM 后面的这个空格。所以在定义宏的时候一定要注意什么时候该用空格，什么时候不该用空格。这个空格仅仅在定义的时候有效，在使用这个宏函数的时候，空格会被编译器忽略掉。也就是说，上一节定义好的宏函数SUM（x）在使用的时候在SUM 和（x）之间留有空格是没问题的。比如：SUM（3）和SUM （3）的意思是一样的。
6.#undef
#undef 是用来撤销宏定义的，用法如下：

#define PI 3.141592654

…

// code

#undef PI

//下面的代码就不能用PI 了，它已经被撤销了宏定义。
写好C语言，漂亮的宏定义很重要，使用宏定义可以防止出错，提高可移植性，可读性，方便性 等等。下面列举一些成熟软件中常用得宏定义：
1，防止一个头文件被重复包含

#ifndef COMDEF_H

#define COMDEF_H

//头文件内容

#endif

2，重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。这里已经不是#define的范畴了。

typedef unsigned char boolean; /* Boolean value type. */
typedef unsigned long int uint32; /* Unsigned 32 bit value */
typedef unsigned short uint16; /* Unsigned 16 bit value */
typedef unsigned char uint8; /* Unsigned 8 bit value */
typedef signed long int int32; /* Signed 32 bit value */
typedef signed short int16; /* Signed 16 bit value */
typedef signed char int8; /* Signed 8 bit value */
//下面的不建议使用
typedef unsigned char byte; /* Unsigned 8 bit value type. */
typedef unsigned short word; /* Unsinged 16 bit value type. */
typedef unsigned long dword; /* Unsigned 32 bit value type. */
typedef unsigned char uint1; /* Unsigned 8 bit value type. */
typedef unsigned short uint2; /* Unsigned 16 bit value type. */
typedef unsigned long uint4; /* Unsigned 32 bit value type. */
typedef signed char int1; /* Signed 8 bit value type. */
typedef signed short int2; /* Signed 16 bit value type. */
typedef long int int4; /* Signed 32 bit value type. */
typedef signed long sint31; /* Signed 32 bit value */
typedef signed short sint15; /* Signed 16 bit value */
typedef signed char sint7; /* Signed 8 bit value */

3，得到指定地址上的一个字节或字

#define MEM_B( x ) ( *( (byte *) (x) ) )
#define MEM_W( x ) ( *( (word *) (x) ) )

4，求最大值和最小值

#define MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
#define MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )

5，得到一个field在结构体(struct)中的偏移量

#define FPOS( type, field ) \
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */

6,得到一个结构体中field所占用的字节数

#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )

7，按照LSB格式把两个字节转化为一个Word

#define FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )

8，按照LSB格式把一个Word转化为两个字节

#define FLOPW( ray, val ) \
 
(ray)[0] = ((val) / 256); \
 
(ray)[1] = ((val) &amp; 0xFF)

9，得到一个变量的地址（word宽度）

#define B_PTR( var ) ( (byte *) (void *) &amp;(var) )
 
#define W_PTR( var ) ( (word *) (void *) &amp;(var) )

10，得到一个字的高位和低位字节

#define WORD_LO(xxx) ((byte) ((word)(xxx) &amp; 255))
 
#define WORD_HI(xxx) ((byte) ((word)(xxx) &gt;&gt; 8))

11，返回一个比X大的最接近的8的倍数

#define RND8( x ) ((((x) + 7) / 8 ) * 8 )

12，将一个字母转换为大写

#define UPCASE( c ) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) )

13，判断字符是不是10进值的数字

#define DECCHK( c ) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')

14，判断字符是不是16进值的数字

#define HEXCHK( c ) ( ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||\
 
((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||\
 
((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )

15，防止溢出的一个方法

#define INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))

16，返回数组元素的个数

#define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )

17，返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)

#define MOD_BY_POWER_OF_TWO( val, mod_by ) \
( (dword)(val) &amp; (dword)((mod_by)-1) )

18，对于IO空间映射在存储空间的结构，输入输出处理

#define inp(port) (*((volatile byte *) (port)))
 
#define inpw(port) (*((volatile word *) (port)))
 
#define inpdw(port) (*((volatile dword *)(port)))
 
#define outp(port, val) (*((volatile byte *) (port)) = ((byte) (val)))
 
#define outpw(port, val) (*((volatile word *) (port)) = ((word) (val)))
 
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))

19,使用一些宏跟踪调试
A N S I标准说明了五个预定义的宏名。它们是：

_ LINE _
_ FILE _
_ DATE _
_ TIME _
_ STDC _

可以定义宏，例如:
当定义了_DEBUG，输出数据信息和所在文件所在行

#ifdef _DEBUG
 
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
 
#else
 
#define DEBUGMSG(msg,date)
 
#endif

20，宏定义防止使用是错误
用小括号包含。 
例如：

#define ADD(a,b) （a+b）

用do{}while(0)语句包含多语句防止错误
例如：

#define DO(a,b) a+b;\
 
a++;

应用时：

if(….)
 
DO(a,b); //产生错误
 
else

解决方法: 代码就只会执行一次。和直接加花括号有什么区别呢。哦对，不能随便在程序中，任意加｛｝，组成代码块的。

#define DO(a,b) do{a+b;\
 
a++;}while(0)

c 语言宏定义 #define 的理解与资料整理，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>36</docid>
    <url>http://blog.jobbole.com/107038/</url>
    <title>程序员如何保持身体健康？</title>
    <content>最近听说公司的几个同事都大病了一场，有的还进行了大的手术，差点跟阎王爷报道了。努力工作固然重要，但是一定注意身体，身体不好了，随着来的就是，工作和生活双失。
我根据自己的实践，列举了几点习惯，可能可以帮助程序员调整一下工作和生活的节奏，从而达到生活和工作平衡，进而改进身体体质和健康。
1、请早睡
早睡都做不到的话，其他就都别谈了。像要跑步，要健身，要努力工作，如果没有早睡作为前提，通通没用的。只有早睡，白天精神气才有可能足，精神气足了，干事情才有劲。熬夜的话，现在80后程序员真心是熬不起了，你可能经常有这样的感慨：怎么现在敖几次夜后，就浑身不爽呢？。

2、请吃好
像街边摊，大排档，这些地方就别去了，他们用的油不好，食材也不好，你把这些不健康的东西吃进肚子里，真心会把身体搞坏。如果公司有食堂了，就去食堂吃，如果没有食堂的话，就自己做饭，然后带饭到公司。你自己可以仔细对比观察周围的人，吃的健康的人的起色和精神气通常都非常好。
3、请有规律的准时吃饭
比如吃中午饭，你第一天11点吃，第二天12点半吃，第三天一点半吃，这种情况，你的胃是吃不消的。得有规律的吃。最好能跟同事一起吃，这样比较准时，同时，跟大家一起吃，你也自然会吃的比较慢。吃的慢是护胃的一种非常好的方式。
千万不好因为工作忙，就不按时准时的吃饭。这种不准时吃饭，吃饭快的，可能会导致胃癌。
4、请健身
有了前面3点之后，你才来考虑健身的问题。健身除了塑形之外呢，还可以增强体质。健身不一定要去健身房的，在家里就可以了。你只要买了哑铃和杠铃，大部分健身动作就都可以完成了。不过健身一定要注意动作的正确性,这个是极其关键的，动作不对，除了健身效果不明显之外，还会伤到肌肉和骨头。
如果周围没有熟悉健身的朋友，可以看一些健身视频，慢慢揣摩动作。
本人就是个健身爱好者，每天都健身，不健身就浑身不爽。二话不说，附上本人的健身后效果图。(^__^) 嘻嘻……


5、请跑步或者游泳
游泳的效果是跑步的三倍，只是我自己的实践经验。当然女生的话，由于头发问题，游泳不能经常做，但是跑步则可以。游泳和跑步这些有氧运动，可以改进心肺机能。

6、加班不要太严重了
这个才是最关键的，经常性的频繁的加班，必定打乱你所有的生活节奏，节奏不对，身体就很快吃不消，各种健康问题也都随之而来。
7、多掌握一些编程以外的技能
程序员不能简单的做码农，日子也要过的精彩。平时可以多学习一些技能，像健身、乒乓球、羽毛球、溜冰、唱歌、保龄球、钢琴、吉他、做家常菜等等。可以帮助你把日子过的精彩些，要往自己身上多投资。
程序员如何保持身体健康？，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>37</docid>
    <url>http://blog.jobbole.com/107021/</url>
    <title>全栈必备：DevOps</title>
    <content>全栈不仅是一个研发多面手，而且必须要关注产品的最终交付，以及线上服务的稳定运行。工具化使开发、交付、运维紧密地联系在一起，于是DevOps 逐渐成为了全栈们手中的利器，但由于DevOps的复杂性，如果没有科学的人员、流程与工具相配合，DevOps根本无从谈起，因此，DevOps 更是一柄双刃剑。

什么是DevOps呢？
先看一下wiki百科给出的定义：
DevOps (a clipped compound of development and operations) is a culture, movement or practice that emphasizes the collaboration and communication of both software developers and other information-technology (IT) professionals while automating the process of software delivery and infrastructure changes. It aims at establishing a culture and environment where building, testing, and releasing software can happen rapidly, frequently, and more reliably.
简单地说，DevOps是一种开发、测试、运营、维护部门之间沟通、协作与整合的软件过程、方法与系统。
DevOps是一种高度强调人与人间互动的工作方式，不能先入为主地认为参与者了解某方面技能，在完成高频率部署的同时，提高生产环境的可靠稳定和安全行。
DevOps能够为团队提供一种极具凝聚力的文化氛围，DevOps不光是一个方法理念，而且是一个有力的技术手段，人员、文化、流程与工具这几大要素在DevOps中同样重要。
为什么DevOps姗姗来迟
DevOps 的概念在2009年就诞生了，但没有相关的技术支持，只是出现在教科书和论文里。然而，近年来所谓DevOps的最佳实践逐渐越来越多，原因何在？

云服务的普遍使用，各种云服务成为IT基础设施中不可分隔的一部分。运维有一个很重要的概念就是Infrastructure as code。
容器技术开始成熟，特别是Docker技术的大行其道。容器 Container是用来存储和组织其他对象的对象。Docker是一个开源的应用容器引擎。
微服务架构技术的广泛使用。
微服务 MicroService是指一个单纯的小型有意义的功能。
微服务，是支撑DevOps方法的手段，传统开发是在一个服务器里面，把各种元素装在一起组合成一个程序，但微服务是每一个服务是一个单独的单元，可以部署在不同的服务器上，通过SOA的方法，把它连接起来，再提供整个功能。
微服务是由一个个团队组成，每团队有自己的服务，做好后，可以独立的进行测试、开发、部署，然后整个应用组合到一起。张侠表示，开发运维一体化、微服务和Container是同等的，把它们组合起来，加上云的手段才成为可能。

4.敏捷开发流程的深入人心。
诸如Scrum, Agile, Kanban等敏捷方式被团队广泛使用，TDD、BDD、DDD这些测试驱动设计、行为驱动设计、域驱动设计等设计方式的采纳，CI和CD这些持续集成和持续部署等方式的实施，这些都是对DevOps的强烈需求。
DevOps中的技术栈与工具链
在全栈眼中，Everything is Code，所以DevOps 是通过技术工具链完成持续集成、持续交付、用户反馈和系统优化的整合，实现跨团队的无缝协作。
DevOps 中涉及的技术栈与工具链如下：

DevOps 流程门户： 这是统一操作的web网站，主要是进度看板，Sprint周期等。本着拿来主义，在一定条件下，可以采用类似Trello，worktile等工具代替。
身份及访问管理： 用户权限管理的重要组成，可以采用RABC的方式实现，也可以与LDAP服务对接
产品管理： 产品的需求，定义，依赖，推广等产品线的全面管理，confluence 可能是个不错的选择，禅道也可以满足一部分的功能
配置管理： 提高产品的配置维护能力，zookeeper 大概是不二之选。
持续集成： 提供持续集成任务调度和执行的能力，Jenkins的用武之地，提供产品和组件自动编译、打包和部署的能力，支持编译和部署的流程编制，进度跟踪和日志查看
环境管理： 提供资源配给和负载均衡的能力，需要配合云服务的资源管理能力。初级的负载均衡可以选择nginx或者Haproxy，生产环境的入口最好采用云服务的SLB负载均衡，以便简单地解决HA的问题。资源的调度采用云的弹性能力，辅助脚本实现。同时，微服务的容器化（docker）管理需要特别关注。
质量反馈： 提供产品的质量管理和监控能力，包括测试用例，缺陷跟踪和质量监控。Jira 是个不错的选择，其他的开源工具例如禅道，bugzila，mantis等等，因团队而异。
版本控制： 代码库的创建和维护，分支管理等。Git 几乎是行业的标准，可以自建Git仓库的服务器，也可以使用github 或者bitbucket这样的第三方服务。
自动化测试： 包括客户端与服务器端的自动化测试框架，例如Appium，Selenium 以及各种Mock技术和xUnit
文档管理：各种开发、运维、部署文档的统一管理，同样最好放到git上，同时指出文档的自动化生成
运营管理：这就是传说中的OAM 中心，这是广义的运营，其中还包括运维的部分。OAM 不但提供了业务系统的运营操作，还提供了面向运维的统一Monitor，alarm，fault handling等能力，以及产品的资源使用和运行状况等，涉及的技术很多，尽量采用云监控＋脚本的方式，规模较小时可以尝zZabbix 实现部分功能。
沟通管理： 敏捷的一个原则就是沟通优于文档，IM是团队必备，微信和QQ可以满足大部分的需求，但是Slack 因为其强大的web hook 功能显得更加出色。

DevOps 的双刃剑
DevOps 的成功与技术、流程和组织的全面支撑是密不可分的。技术栈和工具链只是DevOps的一个前提和基础，技术方面的实践相对容易，流程较难，组织变革最为艰难。DevOps还是以工程实践为主，管理实践这块，像Scrum成体系的还比较少。DevOps玩得好，可以提高团队的生产力。若是玩不好，可能还不如传统的生产模式有效率。
狭义上看，DevOps主要困难点在于开发和运维是两种完全不同性质的技术工作。很多开发的同事，看着运维人员整天就是玩几个工具，写几个脚本，觉得蛮简单，实际上，很多东西要在生产环境下快速稳定应用，并没有看上去那么容易。生产系统少出问题（软件本身bug除外）是运维的绩效，多实现业务需求是开发的绩效，这一少一多，体现了两种技术角色的根本性区别。
业务部门压力往往导致技术部门的任务主要是求“快”，在这种情况下，DevOps必然失衡，因为只追求快，就不需要ops了，只需要dev加班加点即可，不重视ops，结果必然是可悲的，往往业务上线后鸡飞狗跳，各种问题不断。在激烈竞争环境中，出几次事故就可能对产品形象的伤害很大。
对全栈来说，业务初期到底要不要考虑高可用？从Dev角度看，简洁明快的实现就行了，从Ops的角度看，高可用、监控、报表这些东西在业务正式上线前就是必须要考虑的。
因此，DevOps实施成功的关键，涉及到团队管理，项目管理，技术管理等诸多方面。DevOps并非治病良药，如果团队正能量大，实施起来就相对容易，否则引入DevOps可能也无法改变什么。对于一个全栈而言，DevOps是一柄必备的双刃剑。

全栈必备：DevOps，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>38</docid>
    <url>http://blog.jobbole.com/107033/</url>
    <title>C++ 的强制类型转换</title>
    <content>Q:什么是C风格转换？什么是static_cast, dynamic_cast 以及 reinterpret_cast？区别是什么？为什么要注意？
A:转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式。为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符。
比如，为了转换一个类型为doubole的浮点数的指针到整型：
代码int i;
double d;
i = (int) d;或者：i = int (d);对于具有标准定义转换的简单类型而言工作的很好。然而，这样的转换符也能不分皂白的应用于类（class）和类的指针。ANSI-C++标准定义了四个新的转换符：&#8217;reinterpret_cast&#8217;, &#8216;static_cast&#8217;, &#8216;dynamic_cast&#8217; 和 &#8216;const_cast&#8217;，目的在于控制类(class)之间的类型转换。
代码:reinterpret_cast&lt;new_type&gt;(expression)
dynamic_cast&lt;new_type&gt;(expression)
static_cast&lt;new_type&gt;(expression)
const_cast&lt;new_type&gt;(expression)
1 reinterpret_cast
reinterpret_cast 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型。反之亦然。（译注：是指针具体的地址值作为整数值？）
这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。如果情况是从一个指针到整型的拷贝，内容的解释是系统相关的，所以任何的实现都不是方便的。一个转换到足够大的整型能够包含它的指针是能够转换回有效的指针的。
代码:class A {};
class B {};
A * a = new A;
B * b = reinterpret_cast&lt;B *&gt;(a);reinterpret_cast 就像传统的类型转换一样对待所有指针的类型转换。
2 static_cast
static_cast 允许执行任意的隐式转换和相反转换动作。（即使它是不允许隐式的）
意思是说它允许子类类型的指针转换为父类类型的指针（这是一个有效的隐式转换），同时，也能够执行相反动作：转换父类为它的子类。在这最后例子里，被转换的父类没有被检查是否与目的类型相一致。
代码：class Base {};
class Derived : public Base {};

Base *a = new Base;
Derived *b = static_cast&lt;Derived *&gt;(a);static_cast 除了操作类型指针，也能用于执行类型定义的显式的转换，以及基础类型之间的标准转换:
代码:double d = 3.14159265;
int i = static_cast&lt;int&gt;(d);
3 dynamic_cast
dynamic_cast只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。
检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.
代码：class Base { virtual dummy() {} };
class Derived : public Base {};

Base* b1 = new Derived;
Base* b2 = new Base;

Derived* d1 = dynamic_cast&lt;Derived *&gt;(b1); // succeeds
Derived* d2 = dynamic_cast&lt;Derived *&gt;(b2); // fails: returns 'NULL'如果一个引用类型执行了类型转换并且这个转换是不可能的，一个bad_cast的异常类型被抛出：
代码:class Base { virtual dummy() {} };
class Derived : public Base { };

Base* b1 = new Derived;
Base* b2 = new Base;

Derived d1 = dynamic_cast&lt;Derived &amp;*&gt;(b1); // succeeds
Derived d2 = dynamic_cast&lt;Derived &amp;*&gt;(b2); // fails: exception thrown
4 const_cast
这个转换类型操纵传递对象的const属性，或者是设置或者是移除：
代码:class C {};
const C *a = new C;

C *b = const_cast&lt;C *&gt;(a);其它三种操作符是不能修改一个对象的常量性的。注意：&#8217;const_cast&#8217;也能改变一个类型的volatile qualifier。
C++ 的四种强制转型形式每一种适用于特定的目的

dynamic_cast 主要用于执行“安全的向下转型（safe downcasting）”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。它是唯一不能用旧风格语法执行的强制转型，也是唯一可能有重大运行时代价的强制转型。
static_cast 可以被用于强制隐型转换（例如，non-const 对象转型为 const 对象，int 转型为 double，等等），它还可以用于很多这样的转换的反向转换（例如，void* 指针转型为有类型指针，基类指针转型为派生类指针），但是它不能将一个 const 对象转型为 non-const 对象（只有 const_cast 能做到），它最接近于C-style的转换。
const_cast 一般用于强制消除对象的常量性。它是唯一能做到这一点的 C++ 风格的强制转型。
reinterpret_cast 是特意用于底层的强制转型，导致实现依赖（implementation-dependent）（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见。

C++ 的强制类型转换，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>39</docid>
    <url>http://blog.jobbole.com/107012/</url>
    <title>Go net/http 超时机制完全手册</title>
    <content>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。
HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。
本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。
SetDeadline
首先，你需要了解Go实现超时的网络原语(primitive): Deadline (最后期限)。
net.Conn为Deadline提供了多个方法Set[Read|Write]Deadline(time.Time)。Deadline是一个绝对时间值，当到达这个时间的时候，所有的 I/O 操作都会失败，返回超时(timeout)错误。
Deadline不是超时(timeout)。一旦设置它们永久生效(或者直到下一次调用SetDeadline), 不管此时连接是否被使用和怎么用。所以如果想使用SetDeadline建立超时机制，你不得不每次在Read/Write操作之前调用它。
你可能不想自己调用SetDeadline, 而是让net/http代替你调用，所以你可以调用更高级的timeout方法。但是请记住，所有的超时的实现都是基于Deadline, 所以它们不会每次接收或者发送重新设置这个值(so they do NOT reset every time data is sent or received)。
江南雨的指正：
应该是由于“Deadline是一个绝对时间值”，不是真的超时机制，所以作者特别提醒，这个值不会自动重置的，需要每次手动设置。
服务器端超时设置

对于暴露在网上的服务器来说，为客户端连接设置超时至关重要，否则巨慢的或者隐失的客户端可能导致文件句柄无法释放，最终导致服务器出现下面的错误:
http: Accept error: accept tcp [::]:80: accept4: too many open files; retrying in 5ms
http.Server有两个设置超时的方法: ReadTimeout 和 andWriteTimeout`。你可以显示地设置它们：

srv := &amp;http.Server{  
    ReadTimeout: 5 * time.Second,
    WriteTimeout: 10 * time.Second,
}
log.Println(srv.ListenAndServe())
ReadTimeout的时间计算是从连接被接受(accept)到request body完全被读取(如果你不读取body，那么时间截止到读完header为止)。它的内部实现是在Accept立即调用SetReadDeadline方法(代码行)。

……
  if d := c.server.ReadTimeout; d != 0 {
	c.rwc.SetReadDeadline(time.Now().Add(d))
}
if d := c.server.WriteTimeout; d != 0 {
	c.rwc.SetWriteDeadline(time.Now().Add(d))
}
  ……
WriteTimeout的时间计算正常是从request header的读取结束开始，到 response write结束为止 (也就是 ServeHTTP 方法的声明周期), 它是通过在readRequest方法结束的时候调用SetWriteDeadline实现的(代码行)。

func (c *conn) readRequest(ctx context.Context) (w *response, err error) {
	if c.hijacked() {
		return nil, ErrHijacked
	}
	if d := c.server.ReadTimeout; d != 0 {
		c.rwc.SetReadDeadline(time.Now().Add(d))
	}
	if d := c.server.WriteTimeout; d != 0 {
		defer func() {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}()
	}
  ……
}
但是，当连接是HTTPS的时候，SetWriteDeadline会在Accept之后立即调用(代码)，所以它的时间计算也包括 TLS握手时的写的时间。 讨厌的是， 这就意味着(也只有这种情况) WriteTimeout设置的时间也包含读取Headerd到读取body第一个字节这段时间。

if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
    ……
当你处理不可信的客户端和网络的时候，你应该同时设置读写超时，这样客户端就不会因为读慢或者写慢长久的持有这个连接了。
最后，还有一个http.TimeoutHandler方法。 它并不是Server参数，而是一个Handler包装函数，可以限制 ServeHTTP调用。它缓存response, 如果deadline超过了则发送 504 Gateway Timeout 错误。 注意这个功能在 1.6 中有问题，在1.6.2中改正了。
http.ListenAndServe 的错误
顺便提一句，net/http包下的封装的绕过http.Server的函数http.ListenAndServe, http.ListenAndServeTLS 和 http.Serve并不适合实现互联网的服务器。这些函数让超时设置默认不启用，并且你没有办法设置启用超时处理。所以如果你使用它们，你会很快发现连接泄漏，太多的文件句柄。我犯过这种错误至少五六次。
取而代之，你应该创建一个http.Server示例，设置ReadTimeout和WriteTimeout,像上面的例子中一样使用相应的方法。
关于流
令人心塞的是， 没有办法从ServeHTTP中访问底层的net.Conn，所以提供流服务强制不去设置WriteTimeout（这也可能是为什么这些值的默认值总为0）。如果无法访问net.Conn就不能在每次Write的时候调用SetWriteDeadline来实现一个正确的idle timeout。
而且，也没有办法取消一个阻塞的ResponseWriter.Write，因为ResponseWriter.Close没有文档指出它可以取消一个阻塞并发写。也没有办法使用Timer创建以俄国手工的timeout 杯具就是流服务器不能对于慢读的客户端进行防护。我提交的了一个［bug](https://github.com/golang/go/issues/16100)，欢迎大家反馈。
编者按: 作者此处的说法是有问题的，可以通过Hijack获取net.Conn,既然可以可以获取net.Conn,我们就可以调用它的SetWriteDeadline方法。代码例子如下：

package main
import (
	"fmt"
	"log"
	"net/http"
)
func main() {
	http.HandleFunc("/hijack", func(w http.ResponseWriter, r *http.Request) {
		hj, ok := w.(http.Hijacker)
		if !ok {
			http.Error(w, "webserver doesn't support hijacking", http.StatusInternalServerError)
			return
		}
		conn, bufrw, err := hj.Hijack()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		// Don't forget to close the connection:
		defer conn.Close()
		conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
		bufrw.WriteString("Now we're speaking raw TCP. Say hi: ")
		bufrw.Flush()
		s, err := bufrw.ReadString('\n')
		if err != nil {
			log.Printf("error reading string: %v", err)
			return
		}
		fmt.Fprintf(bufrw, "You said: %q\nBye.\n", s)
		bufrw.Flush()
	})
}
客户端超时设置

Client端的超时设置说复杂也复杂，说简单也简单，看你怎么用了，最重要的就是不要有资源泄漏的情况或者程序被卡住。
最简单的方式就是使用http.Client的 Timeout字段。 它的时间计算包括从连接(Dial)到读完response body。

c := &amp;http.Client{  
    Timeout: 15 * time.Second,
}
resp, err := c.Get("https://blog.filippo.io/")
就像服务器端一样，http.GET使用Client的时候也没有超时设置,所以在互联网上使用也很危险。
有一些更细粒度的超时控制：

net.Dialer.Timeout 限制建立TCP连接的时间
http.Transport.TLSHandshakeTimeout 限制 TLS握手的时间
http.Transport.ResponseHeaderTimeout 限制读取response header的时间
http.Transport.ExpectContinueTimeout 限制client在发送包含 Expect: 100-continue的header到收到继续发送body的response之间的时间等待。注意在1.6中设置这个值会禁用HTTP/2(DefaultTransport自1.6.2起是个特例)


c := &amp;http.Client{  
    Transport: &amp;Transport{
        Dial: (&amp;net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
        }).Dial,
        TLSHandshakeTimeout:   10 * time.Second,
        ResponseHeaderTimeout: 10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    }
}
如我所讲，没有办法限制发送request的时间。读取response body (原文是读取request body，按照理解应该是读取response可以手工控制)的时间花费可以手工的通过一个time.Timer来实现, 读取发生在调用Client.Do之后（详见下一节）。
最后将一点，在Go 1.7中，增加了一个http.Transport.IdleConnTimeout， 它不控制client request的阻塞阶段，但是可以控制连接池中一个连接可以idle多长时间。
注意一个Client缺省的可以执行 redirect。http.Client.Timeout包含所有的redirect，而细粒度的超时控制参数只针对单次请求有效， 因为http.Transport是一个底层的类型，没有redirect的概念。
Cancel 和 Context
net/http提供了两种方式取消一个client的请求: Request.Cancel以及Go 1.7新加的Context。
Request.Cancel是一个可选的channel, 当设置这个值并且close它的时候，request就会终止，就好像超时了一样(实际它们的实现是一样的，在写本文的时候我还发现一个1.7 的 一个bug, 所有的cancel操作返回的错误还是timeout error )。
我们可以使用Request.Cancel和time.Timer来构建一个细粒度的超时控制，允许读取流数据的时候推迟deadline:

package main
import (  
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "time"
)
func main() {  
    c := make(chan struct{})
    timer := time.AfterFunc(5*time.Second, func() {
        close(c)
    })
        // Serve 256 bytes every second.
    req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)
    if err != nil {
        log.Fatal(err)
    }
    req.Cancel = c
    log.Println("Sending request...")
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    log.Println("Reading body...")
    for {
        timer.Reset(2 * time.Second)
                // Try instead: timer.Reset(50 * time.Millisecond)
        _, err = io.CopyN(ioutil.Discard, resp.Body, 256)
        if err == io.EOF {
            break
        } else if err != nil {
            log.Fatal(err)
        }
    }
}
上面的例子中我们为Do方法执行阶段设置5秒的超时，但是我们至少花费8秒执行8次才能读完所欲的body，每一次设置2秒的超时。我们可以为流 API这样处理避免程序死在那里。 如果超过两秒我们没有从服务器读取到数据， io.CopyN会返回net/http: request canceled错误。
在1.7中， context包升级了，进入到标准库中。Context有很多值得学习的功能，但是对于本文介绍的内容来讲，你只需直到它可以用来替换和扔掉Request.Cancel。
用Context取消请求很简单，我们只需得到一个新的Context和它的cancel()函数，这是通过context.WithCancel方法得到的，然后创建一个request并使用Request.WithContext绑定它。当我们想取消这个请求是，我们调用cancel()取消这个Context:

ctx, cancel := context.WithCancel(context.TODO())  
timer := time.AfterFunc(5*time.Second, func() {  
    cancel()
})
req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)  
if err != nil {  
    log.Fatal(err)
}
req = req.WithContext(ctx)
Context好处还在于如果parent context被取消的时候(在context.WithCancel调用的时候传递进来的)，子context也会取消， 命令会进行传递。
Go net/http 超时机制完全手册，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>40</docid>
    <url>http://blog.jobbole.com/107030/</url>
    <title>6 个月才解决了这个小 Bug</title>
    <content>我曾经为一家美国著名的国防承包商工作过。我很高兴我做到了，因为它是我一直的梦想；但我也很高兴有机会继续前进。我学到了很多，遇到超多了不起的家伙，而且只要我活着，就永远不会缩写另外一个变量。

（图文无关。F-117 夜鹰隐形战机，图来自维基百科）
我效力过一个隐形飞机的项目，这里不提它的名字，它主要负责制造雷达接收器。你可以能会问，“为什么隐形飞机还需要雷达接收器？”这主要有两个原因。这些接收器是定制的，专门用来接收和识别地理位置以及敌方系统发射雷达脉冲的国籍。首先，知道敌方雷达的地理位置，可以帮助你避免意外飞过他们的上空（如果你的影子飞过敌方空军基地上空，却没有被雷达发现，那是极好的）。第二，它让你分析敌方在哪里寻找你（比如在一个山头上出现了一个俄国的防空导弹基地，上个月还没有呢，那你就知道一定有些东西在上面）。
当接收器在测试实验室的时候，你经常会看到 20~30 磅的精美的航空级铝，里面塞满了 10~20个 定制的电子卡，上面运行着价值 50~100 万美元的软件。移动接收器很容易，绝大多数我在实验室里处理的，都是空军部队在使用中遇到某些问题的。本质上，99.9% 的这些问题都是电子问题，我们不得不欺骗这个盒子，让它认为自己飞在空中，并接受敌方的雷达脉冲。测试仪器和软件在当初采购时，可能是很先进的，在合同获准后都维持不变。然而，因为它们是上世纪 90 年代获准的，你可以想象我们20年后还不得不处理这些遗物。以 MHz 计量的古老 CPU，比我还要老的操作系统，软件的用户友好特性根本无从谈起。我工作的一部分是执行新的合同，负责将升级原有测试仪器以及在上面运行的软件。接下来，有趣的事情发生了。
这项宏大的任务有很多层，我负责的一层是在同一个接收器上运行新旧两个测试，看结果有什么不同，找到软件的问题，然后修正它。因为有很多小问题要处理，所以事情进展地相当缓慢但是还算稳定，但是 SlowPOP 给我留下的印象却挥之不去。SlowPOP，也被称为“慢上升时间的脉冲叠加”，这项测试用来保证在接收到两个叠加的雷达脉冲，而且脉冲的上升、下降时间比正常时间要慢很多的情况下，接收器还能正常工作。这些细节不但枯燥而且还属于机密，所以可以这么说，结果相当糟糕。输入参数稍有调整，测试就可以通过……差不多是这样……但是这仍旧不太正常，后面调整的参数和原始参数并不是很接近，这让我很不舒服。
我不停地重启，重新校准，重新安装（软件），重新测试、测试、不停地测试。
我不断地询问，调查，请求，追问，推测。
随后几个月，我们发布了其它可以通过测试的版本。
有趣的是，每当我问到 WaveGenAPI 函数的时候，每个人都说“那个函数不可能有问题，其他 80% 的测试都在使用它，而且它也正常工作一年多了。”
最后在检查所有可能后，我知道必须要检查 WaveGenAPI 了。
当我研究 WaveGenAPI 函数代码时，经过几天的努力，我找到一些线索。有一行代码看上去不太对。它添加了一堆术语，其中有一个术语看上去不太对。我请 WaveGenAPI 的作者（他有令我羡慕的 26 年经验）下到实验室，和我一起看结果。他沉默地盯着那行代码差不多有半个小时，只问了这个问题的基本信息，包含了基本的检查和可能性。最终他只说了一句“做得好”，然后我们握手，他就离开了。
问题找到了：一个文件 → 一行代码 → 一个术语 → 一个变量 → 一个字母
当时，这位资深程序员接受的训练就是要限定变量名的长度，他在实际工作中使用的变量名长度都不会超过 8 个字符。在这个案例中，有问题变量的含义是脉冲“下降沿十分之一高度的时间”。这个术语应该缩写成 “Ttpfe”，但是他错误地把它命名成“Ttpre”，而它却正好代表相反的含义，即“上升沿”。“Ttpre”这个术语也存在了，所以这个拼写错误才不会造成“undefined”错误。而且除了 SlowPOP 以外，所有测试的时间差异都在1个皮秒内（译注：1皮秒等于百万分之一微秒）。发现和修订这个错误，是对我六个月工作的最高嘉奖，并且是迄今为止我职业生涯中找到最让人满意的 bug。
这就是为什么，只要我活着，就永远不会缩写变量名。
简而言之，我花费了 6 个月的时间去查找一个错误的字母，而它是一个比我多 26 年工作经验的工程师所犯的输入错误。
6 个月才解决了这个小 Bug，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>41</docid>
    <url>http://blog.jobbole.com/107027/</url>
    <title>全栈必备：Git</title>
    <content>
为什么使用Git
Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。大神就是大神，在开发了Linux之后，Git 是又一抗鼎之作。这是唯一的理由么？
Git在软件开发中位置——配置管理SCM
Software configuration management (SCM, or just plain CM) is an organizational framework — that is, a discipline — for managing the evolution of computer systems throughout all stages of systems development.
软件配置管理:通过执行版本控制、变更控制的规程，以及使用合适的配置管理软件，来保证所有配置资源的完整性和可跟踪性。配置管理是对工作成果的一种有效保护。没有软件配置管理，最大的麻烦是工作成果无法回溯。
配置管理的内容和目标
配置管理的内容：
一类是属于产品的组成部分，例如需求文档、设计文档、源代码、测试用例等等；
另一类是在管理过程中产生的文档，例如各种计划、报告等
软件配置管理是在贯穿整个软件生命周期中建立和维护项目产品的完整性。它的基本目标包括：
1. 软件配置管理的各项工作是有计划进行的。
2. 被选择的项目产品得到识别，控制并且可以被相关人员获取。
3. 已识别出的项目产品的更改得到控制。
4. 使相关组别和个人及时了解软件基准的状态和内容。
配置管理的主要任务
软件配置管理的主要任务也就归结为以下几条：
（1）制定项目的配置计划；
（2）对配置项进行标识；
（3）对配置项进行版本控制；
（4）对配置项进行变更控制；
（5）定期进行配置审计；
（6）向相关人员报告配置的状态。
版本控制
版本控制是软件配置管理的核心功能。所有位于配置资源库中的元素都应自动予以版本的标识，并保证版本命名的唯一性。版本在生成过程中，自动依照设定的使用模型自动分支、演进。
版本控制(Revision control)确保由不同人所编辑的同一档案都得到更新。
版本控制中的基本概念
1）签入，提交，检出
2）冲突，解决，合并
3）分支，版本
4）锁定，hook
常见的版本控制工具
作为一个老码农，枚举一下曾经使用过的版本控制工具。
1. VSS： visual source safe, 微软的东东，97年写VC程序时使用，人多的时候性能较差，不知道现在的升级版怎样了
2. clearcase： 99年开发Unix 上分布式式应用时使用，功能强大，不只限于版本控制，有钱的大团队才去用
3. CVS: 02年在互联网热潮的时候使用，开源产品，当时“Copy-Modify-Merge”开发模型眼前一亮。
4. SVN：曾经的挚爱，在曾工作的合资公司使用，权限管理和分支合并等方面做的很出色，并在多个公司推广使用。还记得TortoiseSVN么?那只可爱的小乌龟。
5. perforce:是一款具有轻便快速的SCM工具、真正的客户端/服务器系统等特点的商业软件。高通内部使用的版本管理工具。确实不错。
6. git：现在的最爱……
比较一下cvs,svn,和git：

Git 简要
GIT 是一款免费的、开源的、分布式的版本控制系统。每一个GIT克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力。其最大特色就是“分支”及“合并”操作快速、简便。支持离线工作，GIT是整个项目范围的原子提交，而且GIT中的每个工作树都包含一个具有完整项目历史的仓库。
核心特点：

Git 底层自行维护的存储文件系统：存储的是文件快照，即整个文件内容，并保存指向快照的索引
去中心化的分布式控制

优缺点：
优点：

适合分布式开发，强调个体。
公共服务器压力和数据量都不会太大， 速度快、灵活。
任意两个开发者之间可以很容易的解决冲突。
离线工作。

缺点：

学习周期相对而言比较长。
不符合常规思维。
代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。

Git 原理
Git的目录结构
不论通过git init 还是克隆下来的git 仓库，都有如下的目录结构：

主要目录结构描述见下表：



子目录名
简要描述


branches
Git 项目分支信息，新版 Git 已经不再使用该目录


config
Git 项目配置信息


description
Git 项目描述信息


HEAD
指向 Git 项目当前分支的头指针


hooks
默认的”hooks”脚本，被特定事件发生前后触发。


info
里面含一个 exclude 文件，指 Git 项目要忽略的文件。


objects
Git 的数据对象，包括：commits, trees, blobs, tags。


refs
指向所有 Git 项目分支的指针



所有的分支指针保存在 .git/refs/heads 目录下，HEAD 在 .git/HEAD 目录下，标签在 .git/refs/tags 目录下。
快照
例如： 一个工程中有两个文件A和B， 有3个版本:
V1.0 A和B，V1.5 A1和B，V2.0 A1和B1
在Git 的实际存储中实际存了3个快照 4个文件。
Git对文件进行 SHA-1 计算作为文件的唯一ID，并校验了文件完整性。
SHA-1 算法将文件中的内容通过计算生成一个 40 位的 Hash 值。SHA-1 算法的特点：
由文件内容计算出的 Hash 值；Hash 值相同，文件内容相同。

使用 SHA-1 的前两位创建了文件夹，剩下的 38 位为文件名。
这些 Obj 文件，其实分为四种类型，分别是 Blob、Tree、Commit、Tag。
Blob
用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以 Blob 的形式存放的。
Tree
Tree 用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 Tree 中有 Blob、子 Tree，且都是使用 SHA-1值引用的。这是与目录对应的。从顶层的 Tree 纵览整个树状的结构，叶子结点就是 Blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 Tree 对象就代表了当前项目的快照。
Commit
表示一次提交，有 Parent 字段，用来引用父提交。指向了一个顶层 Tree，表示了项目的快照，还有一些其它的信息，比如上一个提交 Committer、Author、Message 等信息。
存储区
Git中有4个类型的存储区：远程仓库，工作区，本地仓库和缓存区。
暂存区的好处：

为了能够实现部分提交
为了不在工作区创建状态文件、会污染工作区。
暂存区记录文件的修改时间等信息，提高文件比较的效率。
暂存区是用来构建项目快照的区域。暂存区是一个文件，路径为： .Git/index


它是一个二进制文件，第四列是文件名，第三列是文件的冲突状态，第二列指的是文件的 Blob。
Commit 命令，将暂存区的内容永久保存到本地仓库。提交时 Git 会使用暂存区的这些信息生成 Tree 对象，也就是项目快照，永久保存到数据库中。
文件的状态可以分为两类。一类是暂存区与本地仓库比较得出的状态，另一类是工作区与暂存区比较得出的状态。为什么要分成两类的愿意也很简单，因为第一类状态在提交时，会直接写入本地仓库。而第二种则不会。一个文件可以同时拥有两种状态。
分支
分支的目的是让我们可以并行的进行开发。 .Git/HEAD 文件，它保存了当前的分支。

分支指向了一次提交，也是 Git 中的分支为什么这么轻量的原因。
因为分支就是指向了一个 Commit 的指针，当提交新的 Commit，这个分支的指向只需要跟着更新就可以了，而创建分支仅仅是创建一个指针。
Git 必备技能
常见命令速查

git add 和 git commit
Add 操作是将修改保存到暂存区，Commit 是将暂存区的内容永久保存到本地仓库。
每当将修改的文件加入到暂存区，Git 都会根据文件的内容计算出 SHA-1，并将内容转换成 Blob，写入数据库。然后使用 SHA-1 值更新该列表中的文件项。
在暂存区的文件列表中，每一个文件名，都会对应一个 SHA-1 值，用于指向文件的实际内容。最后提交的那一刻，Git 会将这个列表信息转换为项目的快照，也就是 Tree 对象。写入数据库，并再构建一个 Commit 对象，写入数据库。然后更新分支指向。
分支合并: merge 和rebase
冲突的状态

DELETED_BY_THEM;
DELETED_BY_US;
BOTH_ADDED;
BOTH_MODIFIED

遇到不可自动合并冲突时，Git 会将这些状态写入到暂存区。
merge
在解决完冲突后，我们可以将修改的内容提交为一个新的提交。这就是 Merge。
Merge 之后仍可以做出新的提交。

rebase
Rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新达到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward，即不会产生任何冲突。

Rebase 主要在 .Git/Rebase-Merge 下生成了两个文件，分别为 Git-Rebase-todo 和 Done 文件，Git-Rebase-todo 存放了 Rebase 将要操作的 Commit。而 Done 存放正在操作或已经操作完毕的 Commit。
Rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（Force）强行推送。
所以使用 Rebase 最好不要在公共分支上进行操作。
checkout
经常用来切换分支、或者切换到某一次提交。
Checkout 找到目标提交（Commit），目标提交中的快照也就是 Tree 对象就是我们要检出的项目版本。
Checkout 首先根据Tree生成暂存区的内容，再根据 Tree 与其包含的 Blob 转换成我们的项目文件。然后修改 HEAD 的指向，表示切换分支。
Checkout 并没有修改提交的历史记录。只是将对应版本的项目内容提取出来。
revert
revert 实现了反向提交，就是旧版本添加了的内容，要在新版本中删除；旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。
Revert 也不会修改历史提交记录，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的“回退”。
reset
在当前分支进行版本的“回退”，Reset 是会修改历史提交记录的。
Reset 常用的选项有三个，分别是 —Soft, —Mixed, —Hard。他们的作用域依次增大。
Soft 会仅仅修改分支指向。而不修改工作区与暂存区的内容，
Mixed 比 Soft 的作用域多了一个 暂存区。实际上 Mixed 选项与 Soft 只差了一个 Add 操作。
Hard 会比 Mixed作用域又多了一个工作区。
注意：在丢失后可以使用 Git Reset –Hard ORIG_HEAD 立即恢复，或者使用 reflog 命令查看之前分支的引用
stash
有时，在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。
Stash 将工作区与暂存区中的内容做一个提交，保存起来，然后使用Reset Hard 选项恢复工作区与暂存区内容。我们可以随时使用 Stash Apply 将修改应用回来。
Stash 实现思路将我们的修改提交到本地仓库，使用特殊的分支指针（.Git/refs/Stash）引用该提交，然后在恢复的时候，将该提交恢复即可。
Git 典型实践
一个典型的git 并行开发的流程模型如下：

主要分支
把origin/master作为主要分支，源码的HEAD总是表示production-ready(可随时部署)状态。

origin/develop上的代码是为下一次的代码发布准备的。每日构建也是基于此分支。
当develop分支达到了一个稳定状态并准备发布时，所有的改变都要合并到master分支，并标上版本号。
辅助分支
Feature branches
继承与合并都与develop 分支相关，用来开发新特性的(短期，远期都可以)。

当要创建一个新特性时，从develop分支上再创建一个 Feature branch。
$ git checkout -b myfeature develop
合并feature 到develop$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557 (Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05e9557).
$ git push origin develop
Release branches
继承分支: develop
合并分支：develop 和 master
命名规范：release-*
创建一个release 分支
Release branch是通过develop分支而创建.$ git checkout -b release-1.2 develop    
Switched to a new branch "release-1.2"

$ ./bump-version.sh 1.2
Files modified successfully, version bumped to 1.2.

$ git commit -a -m "Bumped version number to 1.2"
[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)
完成一个release 分支
当release branch已经准备就绪，需要做几件事。

release分支被合并到master分支上(每一个提交到master上的commit都是一个新版 本，切记)。
master上的commit都要添加tag，方便将来查看和回滚。
release上所做的修改必须合并到develop分支上，保证bug已被修补。
前两个步骤：

$ git checkout master
Switched to branch 'master'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2为了把release上的改变保存到develop，需要合并到develop。$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)这个步骤可能会导致冲突，如果这样的话，解决冲突，然后再提交。
最后，可以删除release 分支。$ git branch -d release-1.2
Deleted branch release-1.2 (was ff452fe).
Hotfix branches
继承分支: master
合并分支：develop 和 master
命名规范：hotfix-*
运行过程中发现了bug，就必须快速解决，这时就可以创建一个Hotfix branch，解决完后合并到master分支上。好处是开发人员可以继续工作，有专人来负责搞定这个bug。
创建hotfix分支
$ git checkout -b hotfix-1.2.1 master
Switched to a new branch "hotfix-1.2.1"
$ ./bump-version.sh 1.2.1
Files modified successfully, version bumped to 1.2.1.
$ git commit -a -m "Bumped version number to 1.2.1"
[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)
fix bug, 解决问题
需要一次或几次commit$ git commit -m "Fixed severe production problem"
[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)
完成Hotfix branch
当结束时，bugfix要被合并到master，同时也要合并到develop，保证下个版本发布时该bug已被修复。这跟release branch完成时一样。
首先更新master和tag release$ git checkout master
Switched to branch 'master'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2.1接下来与develop合并$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)有一个例外，就是当一个release branch存在时，bugfix要被合并到release而不是develop，因为release最终会被合并到develop。
最后移除branch
$ git branch -d hotfix-1.2.1 
Deleted branch hotfix-1.2.1 (was abbe5d6).
总结
了解Git 在软件工程及敏捷开发中的地位，明白git与其他版本控制工具之间的区别，掌握Git 工作的基本原理和必备操作，复杂问题可以查找git的相关命令，应用git开发的流程模型，让Git 成为我们的真正利器。
参考资料：
1）http://nvie.com/posts/a-successful-git-branching-model/
2）https://community.qingcloud.com/topic/457/%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD-git-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E4%B9%88/2

全栈必备：Git，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>42</docid>
    <url>http://blog.jobbole.com/107025/</url>
    <title>后端成长之路：从菜鸟到架构</title>
    <content>
有不少初学者问到，我想学习后端，但是又不知道该怎么学，所以我决定把这几年的经验和经历整理成一篇文章，分析后端的路该怎么走，先说明下面仅仅是个人心得，也许与外面的理论有所不同。（文章最后面会附上学习路线地图和一些自己看过的书籍）

后端任务其实是实现接收输入响应输出

后端初接触
后端首先需要学习的是html，css和js，也许你会问做网页不是前端做的事情吗？答案是对于真实开发环境后端很多时候还兼顾了前端这个角色，对于架构来说优化不仅仅要考虑后端还需要考虑前端。
要学到什么样的程度才可以学下一样技能呢？我的建议是能够搭建起一个简单的页面，最重要的是学会dom操作和ajax。
语言选择
我相信过来人或者正在入门的人都碰到过这个世纪难题，如果你是初学者我建议您使用java。这里并不是说我喜欢java才推荐你们用java入门，而是java的思想对我们以后开发有很不错的启发。当你学会一种语言的基本语法就可以到下一步了（仅仅是语法，任意语言）。
hello world！
没错，这个时候，你得让浏览器可以看到hello world！ 为了实现这个小目标，我们就需要根据语言配置不同的运行环境。由于入门，我建议可以使用一些集成的一键配置环境软件，例如php可以用phpstudy，java看看教程，下载一个tomcat然后跟eclipse集成就好，而python或则ruby则使用一个轻量级的web框架，copy一下官网提供的hello world！例子即可。
高级一些的hello world
这个阶段，你需要实现的是通过浏览器输入不同的网址，你可以输出不同的内容。然后要弄明白什么是get参数，什么是post参数。然后要实现根据不同get参数或者post参数输出不同内容。因为后端研发从根本上来说就是处理这些不同输入，输出特定的内容回去而已，所以这一步，最关键。
数据库
为什么我们要用数据库呢？以一个新闻网站为例，它要保存新闻数据，还得保存用户信息，也要保存评论信息。也许你会问用文件保存就好了，为何还要学习数据库这么庞大的东西呢？首先，我们来看一下什么是数据库，我们可以把数据库每一个table看成excel的sheet，每一个db就是一个excel文件。而sql语句就是一条条指令，可以帮我们操作里面的数据，可以节省我们大量的操作。开始学习数据库的时候，我建议学习mysql。

数据库

模板引擎
一项技术的出现，往往在于解决了一些开发难题。在没有模板引擎之前，我们得使用字符串拼接方式，弄成html字符串，但是这种方式很容易出错的。而模板引擎无需字符串拼接，并且可以处理字符串转义问题，并且模板集成，模板引用等功能，可以使代码可以重用，大大提高了开发效率，工程也更容易维护。

模板引擎

MVC框架
首先，我们得明白为什么要用框架？假如是第一次接触，我相信第一感受是用了框架加重自己的开发负担。然后框架存在必然有自己的合理性，我们来看看框架有什么优点。
1. 框架提供了大量的方法封装，我们可以直接调用来解决业务问题，这可以大大提高开发效率。
2. 框架能够帮我们分层编写代码，能够在后期更好的维护我们的项目。
3. 做一些安全防护，处理一些常见的攻击。
所以对于各种语言，大家可以选择一个对应的框架来学习。那么我们应该如何挑选一个框架呢？
1. 多人用的（最起码使用过程中遇到问题，都能找到人问）
2. 文档详细的（文档不详细，怎么去学习呢？）
3. 简单的（未来的趋势估计都是往轻量级框架走的）

MVC框架有利于维护

Linux与应用部署
开发用window没什么问题，但是我们做的应用绝大部分是要放在linux系统来对外提供服务器，所以不懂linux的操作是不行的，并且服务器为了尽可能节省资源，都是不使用界面的，所以我们要学好大量的linux命令。
服务器环境我们一般就不会用外面的通用的一键安装环境，往往需要优化的。所以基本的软件安装和配置需要学会，特别是近年来很火的docker，越来越多都是基于docker来部署的啦。
缓存
缓存可是处理高并发的万能药，每当你写的功能慢的时候，基本上你都可以通过缓存来大大提高网站性能。实现缓存的方法很简单，但是一当在并发下和海量数据面前一切都不容易，还得上分布式集群这些。
http协议
如果上面的你都接触了，恭喜您普通开发估计是没问题了，如果你说很多需求还是做不出，没关系，其实你只是缺乏开发经验而已，只要多写多请教，你就会发现，其实后端研发也没什么难度。这个时候，如果我们想往高级研发工程师方向走，一些底层的高级的东西我们得学会。

http协议

浏览器与服务器通过http协议交互，其实就是相互之间传递一串特定格式的字符串。get参数，post参数，url，和cookie等信息其实都包含在这字符串里面。我们平时虽然没有怎么碰到这些底层的东西，其实是框架和tomcat这种软件帮我们处理了。
就像平时一个重定向，其实就在header里面有一句Location: XXX。而我们平时声明返回的是html还是json其实是headers有一句Content-Type:XXX，一切神奇的功能其实仅仅是一段特定的字符串而已，所以http协议怎么可以不研究呢。
nosql
非关系型数据库有很多，例如memcached，redis，mongodb，coundb等。这些东西都有自己的适用场景，合理利用可以加快开发效率，对提高应用性能有很大的帮助的。
消息中间件
这种技术的出现是为了解耦，当我们业务过于庞大的时候，就会相应的拆分成几个小系统，系统之间的通讯往往是通过http协议调用和基于消息中间件。通过http协议有一个弊端，就是某个系统一旦修改了地址，那么就必须修改调用该服务的系统。如果通过消息中间件调用，那么应用如何迁移，也不会影响到别的系统。

消息中间件

一点点话
你跟所谓的大牛差距在哪里呢？我的看法是差距仅仅在于项目经验。也许你会说后端怎么需要学习这么多东西，并且年年都有新的技术出现怎么学呢？其实对于一种新技术，我们主要是要弄明白我们为什么要用这种技术，因为存在即合理，新技术的出现必然有自己的原因，所以新技术不一定要追求，但是底层建议要理解。然后什么海量数据和高并发下系统优化，一个原则，找到性能瓶颈并解决它而已。
附录
路线图

一个简单的学习路线图

书单（下面仅仅是一些个人以前看过的书籍，并不是推荐要看，个人建议看看哪种讲解核心的书籍，怎么制作比怎么用更总要）
LINUX操作系统(第2版)
LINUX指令范例速查手册
JSP &amp; SERVLET学习笔记
STRUTS 2．X权威指南(第3版)
HTML 5从入门到精通
JAVA入门经典(第6版)
看透Spring MVC：源代码分析与实践
大型分布式网站架构设计与实践
Docker 容器与容器云
Python Cookbook（第3版）中文版
Go语言程序设计
MongoDB大数据处理权威指南（第2版）
NoSQL数据库技术实战
构建高可用Linux服务器（第3版）
大型网站技术架构 核心原理与案例分析
Linux运维之道
高性能MySQL（第3版）
Java核心技术 卷I
Java核心技术 卷II

后端成长之路：从菜鸟到架构，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>43</docid>
    <url>http://blog.jobbole.com/107018/</url>
    <title>一些实用的 Laravel 小技巧</title>
    <content>Laravel 中一些常用的小技巧，额，说不定你就用上了。。。
1.侧栏
网站一般都有侧栏，用来显示分类，标签，热门文章，热门评论啥的，但是这些侧栏都是相对独立的模块，如果在每一个引入侧栏的视图中都单独导入与视图有关的数据的话，未免太冗余了。。。所以最佳的做法是：新建一个widgets视图文件夹，再利用Laravel 的ViewComposers单独为侧栏绑定数据，这样侧栏就可以随便引入而不用关心数据是否绑定啦~~~
举个栗子？拿最常用的分类侧栏来说，在resources/views/widgets下新建你的分类侧栏视图文件categories.blade.php：


&lt;div class="widget widget-default"&gt;
    &lt;div class="widget-header"&gt;&lt;h6&gt;&lt;i class="fa fa-folder fa-fw"&gt;&lt;/i&gt;分类&lt;/h6&gt;&lt;/div&gt;
    &lt;ul class="widget-body list-group"&gt;
        @forelse($categories as $category)
            @if(str_contains(urldecode(request()-&gt;getPathInfo()),'category/'.$category-&gt;name))
                &lt;li href="{{ route('category.show',$category-&gt;name) }}"
                    class="list-group-item active"&gt;
                    {{ $category-&gt;name }}
                    &lt;span class="badge"&gt;{{ $category-&gt;posts_count }}&lt;/span&gt;
                &lt;/li&gt;
            @else
                &lt;a href="{{ route('category.show',$category-&gt;name) }}"
                   class="list-group-item"&gt;
                    {{ $category-&gt;name }}
                    &lt;span class="badge"&gt;{{ $category-&gt;posts_count }}&lt;/span&gt;
                &lt;/a&gt;
            @endif
        @empty
            &lt;p class="meta-item center-block"&gt;No categories.&lt;/p&gt;
        @endforelse
    &lt;/ul&gt;
&lt;/div&gt;


新建app/Http/ViewComposers文件夹，然后创建CategoriesComposer.php：&lt;?php
namespace App\Http\ViewComposers;
use App\Http\Repositories\CategoryRepository;
use Illuminate\View\View;
class CategoriesComposer
{
    public function __construct(CategoryRepository $categoryRepository)
    {
        $this-&gt;categoryRepository = $categoryRepository;
    }

    public function compose(View $view)
    {
        $categories = $this-&gt;categoryRepository-&gt;getAll()-&gt;reject(function ($category) {
            return $category-&gt;posts_count == 0;
        });
        $view-&gt;with('categories', $categories);
    }
}再在app/Providers文件夹下新建ComposerServiceProvider.php文件：&lt;?php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\View;
class ComposerServiceProvider extends ServiceProvider
{

    public function boot()
    {
        View::composer('widget.categories', 'App\Http\ViewComposers\CategoriesComposer');
    }

    public function register(){}
}最后别忘了在config/app.php中的providers数组中添加AppProvidersComposerServiceProvider::class啊。好了，现在你可以随时随地@include('widget.categories')了。对了，要善于在ViewComposer中利用Collection的强大方法进行数据处理幺~~
2.善用路由别名
Laravel 最让人喜欢的地方之一是可以给路由起一个别名，比如：Route::get('user/profile', 'UserController@showProfile')-&gt;name('user.profile');
// 等价于：
Route::get('user/profile', ['uses' =&gt; 'UserController@showProfile' , 'as' =&gt; 'user.profile']);;然后，就可以在试图中就可以使用route()方法引用了：// 例如：
&lt;a href="{{ route('user.profile') }}"&gt;lufficc&lt;/a&gt;因为一个普通的项目路由至少也得有几十个，如果使用url()方法的话，你不但要记住具体的路由，更麻烦的是如果你将来想要改变某个路由（比如把'user/profile'改为'u/profile'，或者加个前缀啥的），必须改变所有相关的视图文件，这。。。这。。。不敢相信，而使用命名路由的话，只要命名不变，毫不受影响。
所以视图文件中尽量避免使用url()方法，为每一个路由命名，一个默认的命名规则为：资源名称.或者，如post.show，image.upload。
3.全局动态设置
仅仅是.env的配置还无法满足我们的需求，有时我们需要可以在后台动态的进行一些设置，比如网站的标题，网站的背景图片或者是否允许评论等等。那么实现这个的最佳实践是什么？
熟悉wordpress的同学知道，wordpress可以进行很多自定义，因为wordpress有一张键值对数据库表，它就是靠这个实现个性化的。因此我们也可以参考这种思路，增加一个键值对表，以Xblog为例子，新建一个maps表：Schema::create('maps', function (Blueprint $table) {
       $table-&gt;increments('id');
       $table-&gt;string('key')-&gt;unique();
       $table-&gt;string('tag')-&gt;index();
       $table-&gt;text('value')-&gt;nullable(true);
});maps表的作用就是实现键值对key-value存储，tag的是为了可以有一个分类。然后后台进行存储的话，不要写死，这样就可以随时在变单中添加设置而无需更改代码：$inputs = $request-&gt;except('_token');
foreach ($inputs as $key =&gt; $value) {
            $map = Map::firstOrNew([
                'key' =&gt; $key,
            ]);
            $map-&gt;tag = 'settings';
            $map-&gt;value = $value;
            $map-&gt;save();
}注意firstOrNew的用法：如果不存在这个选项我们就新增一个并保存，否则就更新它。然后我们就可以在视图中随便增加任意多个表单了（或者也可以用js动态生成表单）。有了数据，怎么在视图中利用呢？利用ViewComposer，新建一个SettingsComposer.php，然后将查询的数据以数组的形式传递给视图：//在SettingsComposer.php的compose方法中绑定数据
public function compose(View $view)
{
    $settings = Map::where('tag', 'settings')-&gt;get();
    $arr = [];
    foreach ($settings as $setting) {
      $arr[$setting-&gt;key] = $setting-&gt;value;
    }
   $view-&gt;with($arr);
}然后就可以在视图中随便引用了，如你表单新增加了一个description&lt;input type="text" name="description" value="{{ $description or ''}}"&gt;然后就可以在任何视图引用了:{{ $description or ''}}。另外还可以绑定一个单例Facades到容器，这样就可以在代码中随时获取配置信息啦~~~
比如：//1.注册
public function register()
{
    $this-&gt;app-&gt;singleton('XblogConfig', function ($app) {
       return new MapRepository();
   });
}
//2.注册Facade
class XblogConfig extends Facade
{
    public static function getFacadeAccessor()
    {
        return 'XblogConfig';
    }
}
//3.添加到aliases数组

'aliases' =&gt; [

        *****************  省略  *************************
        'XblogConfig' =&gt; App\Facades\XblogConfig::class,
    ],

//4.愉快的使用，可爽
$page_size = XblogConfig::getValue('page_size', 7);
4.数据库查询
怎么统计一篇文章有多少评论？最快的方法是：$post = Post::where('id',1)-&gt;withCount('comments')-&gt;first();这样$post变量就有一个属性comments_count了：$post-&gt;comments_count;如果想获取点赞数大于的100的评论个数怎么办？这样：$post = Post::where('id',1)-&gt;withCount('comments',function($query){
       $query-&gt;where('like', '&gt;', 100);
   })-&gt;first();简单吧~~
5.多态关联
文章可以有评论，页面可以有评论，评论也可以有评论，但是总不能建三张评论表吧？如果自己写条件判断也太麻烦了吧。。。Laravel的多态关联上场了！！//1.第一步在Comment模型中说明我是可以多态的
public function commentable()
{
    return $this-&gt;morphTo();
}

//2.在想要评论的模型中增加comments方法，
public function comments()
{
    return $this-&gt;morphMany(Comment::class, 'commentable');
}

//3.使用，就像普通的一对多关系一样：
$model-&gt;comments;原理很简单，comments表中增加两个列就行：Schema::create('comments', function (Blueprint $table) {
     ***************省略*******************
     $table-&gt;morphs('commentable');
     //等价于
     $table-&gt;integer('commentable_id')-&gt;index();
     $table-&gt;string('commentable_type')-&gt;index();
    ****************省略******************
});然后 laravel 会自动维持这些关系。注意，保存的评论的时候是有小技巧的，你的表单中至少要传两个参数：commentable_id和commentable_type：$comment = new Comment();

$commentable_id = $request-&gt;get('commentable_id');
//commentable_type取值例如：AppPost，AppPage等等
$commentable = app($request-&gt;get('commentable_type'))-&gt;where('id', $commentable_id)-&gt;firstOrFail();

****************省略******************

$commentable-&gt;comments()-&gt;save($comment);保存评论的时候并不知道是谁的评论，而是使用容器根据commentable_type生成一个模型实例，这样也就和具体的模型解耦了，你可以让任何东西可以评论，而不需要修改代码。
6.缓存优化相关
如果你想要在.env文件中添加自己的配置，记住一定要在config文件夹下某个配置文件的数组中添加对应的。记住，除了config文件夹下的配置文件，永远不要在其它地方使用env函数，因为部署到线上时，配置文件缓存（php artisan config:cache）后，env函数无法获得正确的值。
另外注意的是，路由文件中尽量不使用闭包函数，统一使用控制器，因为缓存路由的时候php artisan route:cache，无法缓存闭包函数。
7.Redis
如果你缓存使用Redis，session也使用了Redis，队列已使用了Redis，这样没问题，速度很快，但是！！当你运行php artisan cache:clear清除缓存时，会把你的登录信息清除，也会把队列清除。。。这就不优雅了。解决办法很简单，为它们分配不同的连接即可。
首先在configdatabase.php中增加连接，注意database序号：'redis' =&gt; [

        'cluster' =&gt; false,

        'default' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 0,
        ],
        'session' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 1,
        ],
        'queue' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 2,
        ],

    ],然后分别为session和queue更换连接：//queue.php中的connections数组中：
'redis' =&gt; [
            'driver' =&gt; 'redis',
            'connection' =&gt; 'queue',
            'queue' =&gt; 'default',
            'retry_after' =&gt; 90,
        ],

//session.php中的connection选项：
'connection' =&gt; 'session',这样他们就互不相干了~~
以上经验来自Xblog，示例均可以在Xblog找到
一些实用的 Laravel 小技巧，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>44</docid>
    <url>http://blog.jobbole.com/107004/</url>
    <title>深入Go UDP编程</title>
    <content>用户数据报协议（User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报(package-oriented)的传输层协议，正式规范为RFC 768。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验。
由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如TFTP，如果需要则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体（流技术）、即时多媒体游戏和IP电话（VoIP）一定就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（TCP协议）来代替UDP。
由于缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低UDP过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中，增加主机拥塞控制，来减小这个潜在的问题。
典型网络上的众多使用UDP协议的关键应用一定程度上是相似的。这些应用包括域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）和某些影音流服务等等。
UDP报头

IPv4伪头部
IPv6伪头部
以上大段的背景介绍引自维基百科。
而TCP是面向连接(connection-oriented)的协议，可以提供可靠的数据传输。
本文讲介绍Go语言的UDP库及其使用方法，以及了解使用过程中的细节和陷阱。
一个简单的例子
首先看一个简单的UDP的例子，这个例子演示了Go UDP通过Dial方式发送数据报的例子。

package main
import (
	"fmt"
	"net"
)
func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		_, err = listener.WriteToUDP([]byte("world"), remoteAddr)
		if err != nil {
			fmt.Printf(err.Error())
		}
	}
}
package main
import (
	"fmt"
	"net"
)
func main() {
	sip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())
}
可以看到, Go UDP的处理类似TCP的处理，虽然不像TCP面向连接的方式ListenTCP和Accept的方式建立连接,但是它通过ListenUDP和ReadFromUDP可以接收各个客户端发送的数据报，并通过WriteToUDP写数据给特定的客户端。
我们稍微修改一下client1.go,让它保持UDP Socket文件一直打开：
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	b := make([]byte, 1)
	os.Stdin.Read(b)
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())
}
使用 netstat可以看到这个网络文件描述符(因为我在同一台机器上运行服务器，所以你会看到两条记录，一个是服务器打开的，一个是客户端打开的)。
udp4       0      0  localhost.54676        localhost.9981
udp4       0      0  localhost.9981         *.*
或者使用lsof命令查看：
server1   59312 smallnest    3u  IPv4 0xad793a9a54467f61      0t0  UDP localhost:9981
client1   59323 smallnest    3u  IPv4 0xad793a9a544681c1      0t0  UDP localhost:54676-&gt;localhost:9981
更复杂的例子
我们还可以将上面的例子演化一下，实现双向的读写。
服务器端代码不用修改，因为它已经实现了读写，读是通过listener.ReadFromUDP,写通过listener.WriteToUDP。
客户端修改为读写：
package main
import (
	"fmt"
	"net"
)
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	data := make([]byte, 1024)
	n, err := conn.Read(data)
	fmt.Printf("read %s from &lt;%s&gt;\n", data[:n], conn.RemoteAddr())
}
这里client的写是Write,读是Read。
等价的客户端和服务器
下面这个是两个服务器通信的例子，互为客户端和服务器，在发送数据报的时候，我们可以将发送的一方称之为源地址，发送的目的地一方称之为目标地址。
package main
import (
	"fmt"
	"net"
	"os"
	"time"
)
func read(conn *net.UDPConn) {
	for {
		data := make([]byte, 1024)
		n, remoteAddr, err := conn.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("receive %s from &lt;%s&gt;\n", data[:n], remoteAddr)
	}
}
func main() {
	addr1 := &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981}
	addr2 := &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9982}
	go func() {
		listener1, err := net.ListenUDP("udp", addr1)
		if err != nil {
			fmt.Println(err)
			return
		}
		go read(listener1)
		time.Sleep(5 * time.Second)
		listener1.WriteToUDP([]byte("ping to #2: "+addr2.String()), addr2)
	}()
	go func() {
		listener1, err := net.ListenUDP("udp", addr2)
		if err != nil {
			fmt.Println(err)
			return
		}
		go read(listener1)
		time.Sleep(5 * time.Second)
		listener1.WriteToUDP([]byte("ping to #1: "+addr1.String()), addr1)
	}()
	b := make([]byte, 1)
	os.Stdin.Read(b)
}
Read和Write方法集的比较
前面的例子中客户端有时使用DialUDP建立数据报的源对象和目标对象(地址和端口), 它会创建UDP Socket文件描述符,然后调用内部的connect为这个文件描述符设置源地址和目标地址，这时Go将它称之为connected,尽管我们知道UDP是无连接的协议，Go这种叫法我想根源来自Unix/Linux的UDP的实现。这个方法返回*UDPConn。
有的时候却可以通过ListenUDP返回的*UDPConn直接往某个目标地址发送数据报，而不是通过DialUDP方式发送，原因在于两者返回的*UDPConn是不同的。前者是connected，后者是unconnected。
你必须清楚知道你的UDP是连接的(connected)还是未连接(unconnected)的，这样你才能正确的选择的读写方法。
如果*UDPConn是connected,读写方法是Read和Write。
如果*UDPConn是unconnected,读写方法是ReadFromUDP和WriteToUDP（以及ReadFrom和WriteTo)。
事实上Go的这种设计和Unix/Linux设计一致，下面是Linux关于UDP的文档：
When a UDP socket is created, its local and remote addresses are unspecified. Datagrams can be sent immediately using sendto or sendmsg with a valid destination address as an argument. When connect is called on the socket, the default destination address is set and datagrams can now be sent using send or write without specifying a destination address. It is still possible to send to other destinations by passing an address to sendto or sendmsg. In order to receive packets, the socket can be bound to a local address first by using bind. Otherwise, the socket layer will automatically assign a free local port out of the range defined by /proc/sys/net/ipv4/ip_local_port_range and bind the socket to INADDR_ANY.
ReadFrom和WriteTo是为了实现PacketConn接口而实现的方法，它们的实现基本上和ReadFromUDP和WriteToUDP一样，只不过地址换成了更通用的Addr,而不是具体化的UDPAddr。
还有几种情况需要弄清楚:
1、
因为unconnected的*UDPConn还没有目标地址，所以需要把目标地址当作参数传入到WriteToUDP的方法中，但是unconnected的*UDPConn可以调用Read方法吗？
答案是可以,但是在这种情况下，客户端的地址信息就被忽略了。
func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, err := listener.Read(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt;\n", data[:n])
	}
}
2、
unconnected的*UDPConn可以调用Write方法吗？
答案是不可以， 因为不知道目标地址。
func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	_, err = listener.Write([]byte("hello"))
	if err != nil {
		fmt.Printf(err.Error())
	}
}
出错：
write udp 127.0.0.1:9981: write: destination address requiredsmallnestMBP:udp smallnest
3、
connected的*UDPConn可以调用WriteToUDP方法吗？
答案是不可以， 因为目标地址已经设置。
即使是相同的目标地址也不可以。
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	_, err = conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
}
报错:
write udp 127.0.0.1:50141-&gt;127.0.0.1:9981: use of WriteTo with pre-connected connection
4、
connected的*UDPConn如果调用Closed以后可以调用WriteToUDP方法吗？
答案是不可以。
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	err = conn.Close()
	if err != nil {
		fmt.Println(err)
	}
	_, err = conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
}
同样的报错：
write udp 127.0.0.1:59074-&gt;127.0.0.1:9981: use of WriteTo with pre-connected connection
5、
connected的*UDPConn可以调用ReadFromUDP方法吗？
答案是可以,但是它的功能基本和Read一样，只能和它connected的对端通信。
看下面的client的例子：
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	go func() {
		data := make([]byte, 1024)
		for {
			n, remoteAddr, err := conn.ReadFromUDP(data)
			if err != nil {
				fmt.Printf("error during read: %s", err)
			}
			fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		}
	}()
	conn.Write([]byte("hello"))
	b := make([]byte, 1)
	os.Stdin.Read(b)
}
6、
*UDPConn还有一个通用的WriteMsgUDP(b, oob []byte, addr *UDPAddr)，同时支持connected和unconnected的UDPConn:

如果UDPConn还未连接，那么它会发送数据报给addr
如果UDPConn已连接，那么它会发送数据报给连接的对端，这种情况下addr应该为nil

通用多播编程
Go标准库也支持多播，但是我们首先我们看通用的多播是如何实现的，它使用golang.org/x/net/ipv4或者golang.org/x/net/ipv6进行控制。
首先找到要进行多播所使用的网卡,然后监听本机合适的地址和服务端口。
将这个应用加入到多播组中，它就可以从组中监听包信息，当然你还可以对包传输进行更多的控制设置。
应用收到包后还可以检查包是否来自这个组的包。
完整的代码如下：
package main
import (
	"fmt"
	"net"
	"golang.org/x/net/ipv4"
)
func main() {
	//1. 得到一个interface
	en4, err := net.InterfaceByName("en4")
	if err != nil {
		fmt.Println(err)
	}
	group := net.IPv4(224, 0, 0, 250)
	//2. bind一个本地地址
	c, err := net.ListenPacket("udp4", "0.0.0.0:1024")
	if err != nil {
		fmt.Println(err)
	}
	defer c.Close()
	//3.
	p := ipv4.NewPacketConn(c)
	if err := p.JoinGroup(en4, &amp;net.UDPAddr{IP: group}); err != nil {
		fmt.Println(err)
	}
	//4.更多的控制
	if err := p.SetControlMessage(ipv4.FlagDst, true); err != nil {
		fmt.Println(err)
	}
	//5.接收消息
	b := make([]byte, 1500)
	for {
		n, cm, src, err := p.ReadFrom(b)
		if err != nil {
			fmt.Println(err)
		}
		if cm.Dst.IsMulticast() {
			if cm.Dst.Equal(group) {
				fmt.Printf("received: %s from &lt;%s&gt;\n", b[:n], src)
				n, err = p.WriteTo([]byte("world"), cm, src)
				if err != nil {
					fmt.Println(err)
				}
			} else {
				fmt.Println("Unknown group")
				continue
			}
		}
	}
}
同一个应用可以加入到多个组中，多个应用也可以加入到同一个组中。
多个UDP listener可以监听同样的端口，加入到同一个group中。
It is possible for multiple UDP listeners that listen on the same UDP port to join the same multicast group. The net package will provide a socket that listens to a wildcard address with reusable UDP port when an appropriate multicast address prefix is passed to the net.ListenPacket or net.ListenUDP.
c1, err := net.ListenPacket("udp4", "224.0.0.0:1024")
if err != nil {
	// error handling
}
defer c1.Close()
c2, err := net.ListenPacket("udp4", "224.0.0.0:1024")
if err != nil {
	// error handling
}
defer c2.Close()
p1 := ipv4.NewPacketConn(c1)
if err := p1.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
p2 := ipv4.NewPacketConn(c2)
if err := p2.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
还支持Source-specific multicasting特性。
标准库多播编程
标准库的多播编程简化了上面的操作，当然也减少了更多的控制。如果想实现一个简单的多播程序，可以使用这样的方法。
服务器端的代码：
func main() {
	//如果第二参数为nil,它会使用系统指定多播接口，但是不推荐这样使用
	addr, err := net.ResolveUDPAddr("udp", "224.0.0.250:9981")
	if err != nil {
		fmt.Println(err)
	}
	listener, err := net.ListenMulticastUDP("udp", nil, addr)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
	}
}
写个客户端测试一下：
func main() {
	ip := net.ParseIP("224.0.0.250")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())}
广播
广播的编程方式和多播的编程方式有所不同。简单说，广播意味着你吼一嗓子，局域网内的所有的机器都会收到。
服务器端代码：
func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		_, err = listener.WriteToUDP([]byte("world"), remoteAddr)
		if err != nil {
			fmt.Printf(err.Error())
		}
	}
}
客户端代码有所不同，它不是通过DialUDP “连接” 广播地址，而是通过ListenUDP创建一个unconnected的 *UDPConn,然后通过WriteToUDP发送数据报，这和你脑海中的客户端不太一致：
func main() {
	ip := net.ParseIP("172.24.14.255")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.ListenUDP("udp", srcAddr)
	if err != nil {
		fmt.Println(err)
	}
	n, err := conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	data := make([]byte, 1024)
	n, _, err = conn.ReadFrom(data)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf("read %s from &lt;%s&gt;\n", data[:n], conn.RemoteAddr())
	b := make([]byte, 1)
	os.Stdin.Read(b)
}
你局域网内的广播地址可能和例子中的不同，你可以通过ifconfig查看。
广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。
任播
在互联网中，通常使用边界网关协议来实现任播。比如域名根服务器就是通过任播的方式提供。13台根服务器使用13个任播地址，但是有500多台实际服务器。你可以通过单播的方式发送数据包，只有最快的(最近的)的一个UDP服务器接收到。
Anycasting最初是在RFC1546中提出并定义的，它的最初语义是，在IP网络上通过一个Anycast地址标识一组提供特定服务的主机，同时服务访问方并不关心提供服务的具体是哪一台主机(比如DNS或者镜像服务)，访问该地址的报文可以被IP网络路由到这一组目标中的任何一台主机上，它提供的是一种无状态的、尽力而为的服务。
RFC2373(IP Version 6 Addressing Architecture, July 1998)提供了较新的说明和动机：任播地址的一个期望应用是标识属于某个提供互联网服务的机构的路由器集合。这种地址可以用作IPv6路由标题的中间地址,使数据分组通过某一聚合或聚合序列传递。其他可能的用途是标识属于某一子网的路由器组或提供进入某一路由范围入口的路由器组。
RFC2373标准对任播的定义是，当一个单播地址被分配到多于一个的接口上时，发到该接口的报文被网络路由到由路由协议度量的“最近”的目标接口上。与Unicast和Multicast类似，Anycast也是IP网络的一种通信模式。Unicast允许源结点向单一目标结点发送数据报，Multicast允许源结点向一组目标结点发送数据报，而Anycast则允许源结点向一组目标结点中的一个结点发送数据报，而这个结点由路由系统选择，对源结点透明；同时，路由系统选择“最近”的结点为源结点提供服务，从而在一定程序上为源结点提供了更好的服务也减轻了网络负载。
参考文档

https://zh.wikipedia.org/wiki/用户数据报协议
https://golang.org/pkg/net/
http://man7.org/linux/man-pages/man7/udp.7.html
https://godoc.org/golang.org/x/net/ipv4
https://github.com/golang/go/issues/13391
http://baike.baidu.com/view/473043.htm
http://baike.baidu.com/view/2032315.htm

深入Go UDP编程，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>45</docid>
    <url>http://blog.jobbole.com/106995/</url>
    <title>测试自动化后，我们还需要QA吗？</title>
    <content>QA的职责
我们先讨论一下传统的瀑布模型下QA是如何工作的，其中最主要的问题是什么；然后作为对比，我们来看看在敏捷团队里QA又是如何工作的，工作重点又是什么；最后，我们详细看一看在新的职责下，QA应该如何做。
瀑布开发模型
即使在今天，在很多企业中，瀑布模型仍然是主流。每一个需求都需要经过分析，设计，开发，测试，上线部署，运维等阶段。虽然一些企业已经在实施敏捷开发，比如项目/产品以迭代的方式运作，也有诸如每日站会，代码检视等敏捷实践，但是如果仔细审视，你会发现其实开发模式骨子里还是瀑布：按照软件组件划分的部门结构（详见康威定律），按照职能划分的团队（开发和测试分属不同部门），过长的反馈周期，永远无法摆脱的集成难题等等。
随着软件变得越来越复杂，团队里没有任何一个人可以说出系统是如何运作的，也不知道最终用户是谁，以及最终用户会以何种方式来使用最终的软件。
更糟糕的是，按照职能划分的团队在物理上都是隔离的，比如独立的测试部门，独立的运维部门，整日忙碌而难以预约到档期的业务人员，当然还有经常疲于交付，无处吐槽的苦逼开发。由于这些隔离，信息的反馈周期会非常长，一个本来很容易修复的缺陷可能在4周之后才可能被另一个部门的测试发现，然后通过复杂的工作流（比如某种形式的缺陷追踪系统）流到开发那里，而开发可能还在拼命的完成早就应该交付的功能，从而形成恶性循环。
瀑布模式中的QA
在这样的环境中，QA们能做的事情非常有限。在需求开始时会他们参加需求澄清的会议，制定一些测试计划，然后进行测试用例的设计。有的企业会用诸如Excel之类的工具来记录这些用例。这些写在Excel里的，死的用例用处非常有限。而最大的问题在于：它们无法自动化执行。另外，在实际软件开发中，需求总是会经常发生变化，需求的优先级也会有调整，然后这些记录在Excel中的死的用例会很快过期，变得无人问津。
除此之外，QA中的有些成员会使用工具来录制一些UI测试的场景，然后在每个新版本出来之后进行回放即可。然而，当UI发生一点变化之后，这些自动化的用例就会失效：比如HTML片段中元素位置的调整，JavaScript的异步调用超时等等。
显然，这种单纯以黑盒的形式来检查功能点的测试方式是不工作的，要真正有效的提升软件质量，仅仅通过事后检查是远远不够的，软件的质量也应该内建于软件之中。QA的工作也应该是一个贯穿软件生命周期的活动，从商业想法，到真实上线，这其中的所有环节，都应该有QA的参与。
系统思考
如果不从一个系统的角度来思考软件质量，就无法真正构建出健壮的、让业务和团队都有信心的软件系统。质量从来都不只是QA的职责，而是整个团队的职责。
关于软件质量，一个根深蒂固的误解是：缺陷在开发过程中被引入，然后在测试阶段被发现，最后在QA和开发的来来回回的撕扯中被解决（或者数量被大规模降低），最后在生产环境中，就只会有很少的，优先级很低的缺陷。
然而事实上，很多需求就没有仔细分析，业务价值不很确定，验收条件模糊，流入开发后又会引入一些代码级别的错误，以及业务规则上的缺陷，测试阶段会漏掉一些功能点，上线之后更是问题百出（网络故障，缓存失效，黑客攻击，操作系统补丁，甚至内存溢出，log文件将磁盘写满等等）。
在一个敏捷团队中，每个个人都应该对质量负责，而QA则以自己的丰富经验和独特视角来发掘系统中可能的质量隐患，并帮助团队将这些隐患消除。

我在ThoughtWorks的同事Anand Bagmar在他的演讲What is Agile testing- How does automation help?中详细讨论过这部分内容。
QA到底应该干什么？
本质上来说，任何软件项目的目标都应该是：更快地将高质量的软件从想法变成产品。
将这个大目标细分一下，会得到这样几个子项，即企业需要：

更多的商业回报（发掘业务价值）
更快的上线时间（做最简单，直接的版本）
更好的软件质量（质量内嵌）
更少的资源投入（减少浪费）

其实就是传说中的多、快、好、省。如果说这是每一个软件项目的目标的话，那么团队里的每一个个人都应该向着这个目标而努力，任何其他形式的工作都可以归类为浪费。用Excel记录那些经常会失效，而且无法自动执行的测试用例是浪费，会因为页面布局变化而大面积失效的UI测试也是浪费，一个容易修复的缺陷要等到数周之后才被发现也是浪费。
在这个大前提下，我们再来思考QA在团队里应该做什么以及怎么做。
QA的职责
Lisa Crispin在《敏捷软件测试》中提到过一个很著名的模型：敏捷测试四象限。这个模型是QA制定测试策略时的一个重要参考：

如果按照纵向划分的话，图中的活动，越向上越面向业务；越向下越面向技术。横向划分的话，往左是支撑团队；往右是评价产品。
其实简化一下，QA在团队里的工作，可以分为两大类：

确保我们在正确的交付产品
确保我们交付了正确的产品

根据这个四象限的划分，大部分团队可能都会从Q2起步：QA会和BA，甚至UX一起，从需求分析入手，进行需求分析，业务场景梳理，这时候没有具体的可以被测试的软件代码。不过这并不妨碍测试活动，比如一些纸上原型的设计（感谢刘海生供图）：

通过这一阶段之后，我们已经有了用户故事，这时候QA需要和开发一起编写用户故事的自动化验收测试。当开发交付一部分功能之后，QA就可以做常规的用户故事测试，几个迭代之后，QA开始进行跨功能需求测试和探索性测试等。根据探索性测试的结果，QA可能会调整测试策略，调整测试优先级，完善测试用例等等。
根据项目的不同，团队可以从不同的象限开始测试策略的制定。事实上，Q1-Q4仅仅是一个编号，与时间、阶段并无关系，Lisa Crispin还专门撰文解释过。
关于QA如何在软件分析的上游就介入，然后通过BDD的方式与业务分析师一起产出软件的各种规格描述，并通过实例的方式来帮助整个团队对需求的理解，ThoughtWorks的林冰玉有一篇文章很好的介绍了BDD的正确做法。如果将QA的外延扩展到在线的生产环境，制定合理的测量指标，调整测试策略，强烈推荐林冰玉写的另一篇文章产品环境中的QA。
其他职责
事实上，软件生命周期中有很多的活动，有很多处于灰色地段。既可以说是应该开发做，又可以说应该QA做，甚至可以推给其他角色（比如OPs）。不过我们知道，一旦涉及角色，人们就再也不会按照全局优化的思路来应对问题了。这种灰色的活动包括：

持续集成的搭建
测试环境的创建于维护
UAT上的数据准备
代码中的测试代码的维护
测试代码的重构

在团队实践中，这些活动我们通常会让QA和开发或者OPs同事一起结对来完成。一方面避免知识孤岛的形成，另一方面在跨角色的工作中，也可以激发出更多不同的思路。
万能的QA？
虽然在这些活动中，QA都会参与，但是并不是说团队里只要有一个QA就可以了。QA在参与这些活动时，侧重点还是有很大不同的。
比如需求分析阶段，如果有QA的加入，一些从QA角度可以发现的有明显缺陷的场景，则可以在分析阶段就得到很好的处理。另一方面，尽早介入可以设计出更合理的测试计划（比如哪些功能的优先级比较高，用户更会频繁使用，那么对应的测试比重也会更高）。在Story分析与书写阶段，QA可以帮助写出更加合理的验收条件，既满足业务需求，又可以很好的指导开发。
在和开发一起编写澄清需求时，主要是编写自动化验收测试，而不是实际编写业务逻辑的实现（虽然QA应该参与Code Reivew环节，学习并分享自己的观点）；甚至在上线运维阶段，QA还需要和OPs一起来设计用户数据的采集指标（比如用户访问的关键路径，浏览器版本，地区的区分等），从而制定出新的测试策略。
扩展阅读
What is Agile testing &#8211; How does automation help?
敏捷实践Showcase的七宗罪
产品环境下的QA
《敏捷软件测试》
测试自动化后，我们还需要QA吗？，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>46</docid>
    <url>http://blog.jobbole.com/106992/</url>
    <title>C++ 文件操作详解</title>
    <content>C++ 通过以下几个类支持文件的输入输出：

ofstream: 写操作（输出）的文件类 (由ostream引申而来)
ifstream: 读操作（输入）的文件类(由istream引申而来)
fstream: 可同时读写操作的文件类 (由iostream引申而来)

打开文件(Open a file)
对这些类的一个对象所做的第一个操作通常就是将它和一个真正的文件联系起来，也就是说打开一个文件。被打开的文件在程序中由一个流对象(stream object)来表示 (这些类的一个实例) ，而对这个流对象所做的任何输入输出操作实际就是对该文件所做的操作。
要通过一个流对象打开一个文件，我们使用它的成员函数open()：void open (const char * filename, openmode mode);
这里filename 是一个字符串，代表要打开的文件名，mode 是以下标志符的一个组合： ios::in 为输入(读)而打开文件

ios::out 为输出(写)而打开文件
ios::ate 初始位置：文件尾
ios::app 所有输出附加在文件末尾
ios::trunc 如果文件已存在则先删除该文件
ios::binary 二进制方式

这些标识符可以被组合使用，中间以”或”操作符(|)间隔。例如，如果我们想要以二进制方式打开文件&#8221;example.bin&#8221; 来写入一些数据，我们可以通过以下方式调用成员函数open（）来实现：ofstream file;
file.open ("example.bin", ios::out | ios::app | ios::binary);ofstream, ifstream 和 fstream所有这些类的成员函数open 都包含了一个默认打开文件的方式，这三个类的默认方式各不相同： 类 参数的默认方式

ofstream ios::out | ios::trunc
ifstream ios::in
fstream ios::in | ios::out

只有当函数被调用时没有声明方式参数的情况下，默认值才会被采用。如果函数被调用时声明了任何参数，默认值将被完全改写，而不会与调用参数组合。
由 于对类ofstream, ifstream 和 fstream 的对象所进行的第一个操作通常都是打开文件，这些类都有一个构造函数可以直接调用open 函数，并拥有同样的参数。这样，我们就可以通过以下方式进行与上面同样的定义对象和打开文件的操作：ofstream file ("example.bin", ios::out | ios::app | ios::binary);两种打开文件的方式都是正确的。
你可以通过调用成员函数is_open()来检查一个文件是否已经被顺利的打开了：bool is_open();
它返回一个布尔(bool)值，为真（true）代表文件已经被顺利打开，假( false )则相反。
关闭文件(Closing a file)
当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。关闭文件需要调用成员函数close()，它负责将缓存中的数据排放出来并关闭文件。它的格式很简单：void close ();这个函数一旦被调用，原先的流对象(stream object)就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程(process)所有访问了。
为防止流对象被销毁时还联系着打开的文件，析构函数(destructor)将会自动调用关闭函数close。
文本文件(Text mode files)
类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。
一般来说，我们将使用这些类与同控制台(console)交互同样的成员函数(cin 和 cout)来进行输入输出。如下面的例题所示，我们使用重载的插入操作符

// writing on a text file
#include &lt;fstream&gt;
using namespace std;

int main()
{
    ofstream examplefile("example.txt");
    if (examplefile.is_open())
    {
        examplefile &lt;&lt; "This is a line.\n";
        examplefile &lt;&lt; "This is another line.\n";
        examplefile.close();
    }
    return 0;
}

从文件中读入数据也可以用与 cin的使用同样的方法：

// reading a text file
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
using namespace std;
int main ()
{
    char buffer[256];
    ifstream examplefile("example.txt");
    if (! examplefile.is_open())
    {
        cout &lt;&lt; "Error opening file"; exit (1);
    }
    while (!examplefile.eof())
    {
        examplefile.getline(buffer,100);
        cout&lt;&lt;buffer&lt;&lt; endl;
    }
    return 0;
}
//This is a line.
//This is another line.

上面的例子读入一个文本文件的内容，然后将它打印到屏幕上。注意我们使用了一个新的成员函数叫做eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 。
状态标志符的验证(Verification of state flags)
除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回值）：
bad()

如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。

fail()

除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。

eof()

如果读文件到达文件末尾，返回true。

good()

这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。

要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。
获得和设置流指针(get and put stream pointers)
所有输入/输出流对象(i/o streams objects)都有至少一个流指针：

ifstream， 类似istream, 有一个被称为get pointer的指针，指向下一个将被读取的元素。
ofstream, 类似 ostream, 有一个指针 put pointer ，指向写入下一个元素的位置。
fstream, 类似 iostream, 同时继承了get 和 put

我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：
tellg() 和 tellp()

这两个成员函数不用传入参数，返回pos_type 类型的值(根据ANSI-C++ 标准) ，就是一个整数，代表当前get 流指针的位置 (用tellg) 或 put 流指针的位置(用tellp).

seekg() 和seekp()

这对函数分别用来改变流指针get 和put的位置。两个函数都被重载为两种不同的原型：
seekg ( pos_type position );
seekp ( pos_type position );


使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数 tellg 和tellp 的返回值类型相同。seekg ( off_type offset, seekdir direction );
seekp ( off_type offset, seekdir direction );使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：

ios::beg 从流开始位置计算的位移
ios::cur 从流指针当前位置开始计算的位移
ios::end 从流末尾处开始计算的位移

流指针 get 和 put 的值对文本文件(text file)和二进制文件(binary file)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg 和 seekp的第一种原型，而且不要对tellg 或 tellp 的返回值进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。
以下例子使用这些函数来获得一个二进制文件的大小：

// obtaining file size
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main ()
{
    const char * filename = "example.txt";
    long l,m;
    ifstream file(filename, ios::in|ios::binary);
    l = file.tellg();
    file.seekg(0, ios::end);
    m = file.tellg();
    file.close();
    cout &lt;&lt;"size of "&lt;&lt; filename;
    cout &lt;&lt;" is "&lt;&lt; (m-l)&lt;&lt;" bytes.\n";
    return 0;
}
//size of example.txt is 40 bytes.

二进制文件(Binary files)
在二进制文件中，使用&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。
文 件流包括两个为顺序读写数据特殊设计的成员函数：write 和 read。第一个函数 (write) 是ostream 的一个成员函数，都是被ofstream所继承。而read 是istream 的一个成员函数，被ifstream 所继承。类 fstream 的对象同时拥有这两个函数。它们的原型是：write ( char * buffer, streamsize size );
read ( char * buffer, streamsize size );这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。

// reading binary file
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
int main ()
{
    const char * filename = "example.txt";
    char * buffer;
    long size;
    ifstream file(filename, ios::in|ios::binary|ios::ate);
    size = file.tellg();
    file.seekg(0, ios::beg);
    buffer = new char [size];
    file.read(buffer, size);
    file.close();
    cout &lt;&lt;"the complete file is in a buffer";
    delete[] buffer;
    return 0;
}
//The complete file is in a buffer

缓存和同步(Buffers and Synchronization)
当我们对文件流进行操作的时候，它们与一个streambuf 类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流， 每次成员函数put (写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。
当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：

当文件被关闭时: 在文件被关闭之前，所有还没有被完全写出或读取的缓存都将被同步。
当缓存buffer 满时:缓存Buffers 有一定的空间限制。当缓存满时，它会被自动同步。
控制符明确指明:当遇到流中某些特定的控制符时，同步会发生。这些控制符包括：flush 和endl。

明确调用函数sync(): 调用成员函数sync() (无参数)可以引发立即同步。这个函数返回一个int 值，等于-1 表示流没有联系的缓存或操作失败
在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：
1、插入器(&lt;&lt;) 

向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout
2、析取器(&gt;&gt;)
从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。
在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。
一、打开文件
在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：void open(const char* filename,int mode,int access);参数：

filename： 要打开的文件名
mode： 要打开文件的方式
access： 打开文件的属性

打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：

ios::app： 以追加的方式打开文件
ios::ate： 文件打开后定位到文件尾，ios:app就包含有此属性
ios::binary： 以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文
ios::in： 文件以输入方式打开
ios::out： 文件以输出方式打开
ios::nocreate： 不建立文件，所以文件不存在时打开失败
ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败
ios::trunc： 如果文件存在，把文件长度设为0

可以用“或”把以上属性连接起来，如ios::out|ios::binary
打开文件的属性取值是：
0：普通文件，打开访问
1：只读文件
2：隐含文件
4：系统文件
可以用“或”或者“+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。
例如：以二进制输入方式打开文件c:config.sys

fstream file1;
file1.open("c:config.sys",ios::binary|ios::in,0);

如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：

file1.open("c:config.sys");&lt;=&gt;file1.open("c:config.sys",ios::in|ios::out,0);

另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：

fstream file1("c:config.sys");

特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。

ifstream file2("c:pdos.def");//以输入方式打开文件
ofstream file3("c:x.123");//以输出方式打开文件

所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。
二、关闭文件
打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。
三、读写文件
读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式
1、文本文件的读写
文本文件的读写很简单：用插入器(&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：

file2"I Love You";//向文件写入字符串"I Love You"
int i;
file1&gt;&gt;i;//从文件输入一个整数值。

这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些
操纵符 功能 输入/输出
dec 格式化为十进制数值数据 输入和输出
endl 输出一个换行符并刷新此流 输出
ends 输出一个空字符 输出
hex 格式化为十六进制数值数据 输入和输出
oct 格式化为八进制数值数据 输入和输出
setpxecision(int p) 设置浮点数的精度位数 输出
比如要把123当作十六进制输出：file1&lt;&lt;hex&lt;&lt;123;要把3.1415926以5位精度输出：file1&lt;&lt;setpxecision(5)&lt;&lt;3.1415926。
2、二进制文件的读写
①put()
put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(&#8216;c&#8217;);就是向流写一个字符&#8217;c&#8217;。
②get()
get()函数比较灵活，有3种常用的重载形式：
一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。
另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。
还 有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=&#8217;n&#8217;)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符&#8217;n&#8217;。例如：
file2.get(str1,127,&#8217;A&#8217;);//从文件中读取字符到字符串str1，当遇到字符&#8217;A&#8217;或读取了127个字符时终止。
③读写数据块
要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：

read(unsigned char *buf,int num);
write(const unsigned char *buf,int num);

read() 从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。
例：

unsigned char str1[]="I Love You";
int n[5];
ifstream in("xxx.xxx");
ofstream out("yyy.yyy");
out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中
in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换
in.close();out.close();

四、检测 EOF
成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();
例：

if(in.eof())ShowMessage("已经到达文件尾！");

五、文件定位
和 C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时， 相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：

istream &amp;seekg(streamoff offset,seek_dir origin);
ostream &amp;seekp(streamoff offset,seek_dir origin);

streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：

ios::beg： 文件开头
ios::cur： 文件当前位置
ios::end： 文件结尾

这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。
例：

file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节
file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节

C++ 文件操作详解，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>47</docid>
    <url>http://blog.jobbole.com/106940/</url>
    <title>漫画算法：最小栈的实现</title>
    <content>





小灰回忆起当时的情景&#8230;&#8230;





题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。


小灰的想法：
1.创建一个整型变量 min，初始值-1
2.当第一个元素进栈时，让min=0，即把唯一的元素当做最小值。
3.之后每当一个新元素近栈，让新元素和min指向位置的元素比较大小。如果Stack[min]大于新元素，则min等于新元素的下标；Stack[min]小于新元素，则不做改变。
4.当调用getMin方法的时候，直接返回min所指向位置的元素即可。

按这个思路，近栈、出栈、取最小值的时间复杂度都是O(1)，空间复杂度也是O(1)。




回忆到此结束&#8230;&#8230;







解法：
1.设原有的栈叫做栈A，此时创建一个额外的栈B，用于辅助原栈A。
2.当第一个元素进入栈A的时候，让新元素的下标进入栈B。这个唯一的元素是栈A的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是A栈元素的下标）
3.每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈A当前最小值的下标。
4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第二小的元素，代替刚才的出栈元素成为了栈A的当前最小值。（备胎转正）
5.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈A对应元素即可。

这个解法中近栈、出栈、取最小值的时间复杂度都是O(1)，最坏情况空间复杂度是O(N)。

扩展题目：
实现一个队列，带有出队（deQueue），入队（enQueue），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都尽可能小。

漫画算法：最小栈的实现，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>48</docid>
    <url>http://blog.jobbole.com/106981/</url>
    <title>Go 中的锁源码实现：Mutex</title>
    <content>上一篇文章《当我们谈论锁，我们谈什么》 中我提到了锁，准确地说是信号量（semaphore, mutext是semaphore的一种）的实现方式有两种：wait的时候忙等待或者阻塞自己。//忙等待
wait(S) {
    while(S&lt;=0)
        ;   //no-op
    S--
}
//阻塞
wait(semaphore *S) {
    S-&gt;value--;
    if (S-&gt;value &lt; 0) {
        add this process to S-&gt;list;
        block()
    }
}忙等待和阻塞方式各有优劣：

忙等待会使CPU空转，好处是如果在当前时间片内锁被其他进程释放，当前进程直接就能拿到锁而不需要CPU进行进程调度了。适用于锁占用时间较短的情况，且不适合于单处理器。
阻塞不会导致CPU空转，但是进程切换也需要代价，比如上下文切换，CPU Cache Miss。

下面看一下golang的源码里面是怎么实现锁的。golang里面的锁有两个特性：
1.不支持嵌套锁
2.可以一个goroutine lock，另一个goroutine unlock
互斥锁
golang中的互斥锁定义在src/sync/mutex.go// A Mutex is a mutual exclusion lock.
// Mutexes can be created as part of other structures;
// the zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
    state int32
    sema  uint32
}

const (
    mutexLocked = 1 &lt;&lt; iota // mutex is locked
    mutexWoken
    mutexWaiterShift = iota
)看上去也是使用信号量的方式来实现的。sema就是信号量，一个非负数；state表示Mutex的状态。mutexLocked表示锁是否可用（0可用，1被别的goroutine占用），mutexWoken=2表示mutex是否被唤醒，mutexWaiterShift=2表示统计阻塞在该mutex上的goroutine数目需要移位的数值。将3个常量映射到state上就是state:   |32|31|...|3|2|1|
         \__________/ | |
               |      | |
               |      | mutex的占用状态（1被占用，0可用）
               |      |
               |      mutex的当前goroutine是否被唤醒
               |
               当前阻塞在mutex上的goroutine数
1.Lock
下面看一下mutex的lock。func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex.
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }

    awoke := false
    iter := 0
    for {
        old := m.state
        new := old | mutexLocked
        if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                // Active spinning makes sense.
                // Try to set mutexWoken flag to inform Unlock
                // to not wake other blocked goroutines.
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
                runtime_doSpin()
                iter++
                continue
            }
            new = old + 1&lt;&lt;mutexWaiterShift
        }
        if awoke {
            // The goroutine has been woken from sleep,
            // so we need to reset the flag in either case.
            if new&amp;mutexWoken == 0 {
                panic("sync: inconsistent mutex state")
            }
            new &amp;^= mutexWoken
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
                break
            }
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }

    if race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
}这里要解释一下atomic.CompareAndSwapInt32()，atomic包是由golang提供的low-level的原子操作封装，主要用来解决进程同步为题，官方并不建议直接使用。我在上一篇文章中说过，操作系统级的锁的实现方案是提供原子操作，然后基本上所有锁相关都是通过这些原子操作来实现。CompareAndSwapInt32()就是int32型数字的compare-and-swap实现。cas(&amp;addr, old, new)的意思是if *addr==old, *addr=new。大部分操作系统支持CAS，x86指令集上的CAS汇编指令是CMPXCHG。下面我们继续看上面的lock函数。if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
    if race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
    return
}首先先忽略race.Enabled相关代码，这个是go做race检测时候用的，这个时候需要带上-race，则race.Enabled被置为true。Lock函数的入口处先调用CAS尝试去获得锁，如果m.state==0，则将其置为1，并返回。
继续往下看，首先将m.state的值保存到old变量中，new=old|mutexLocked。直接看能让for退出的第三个if条件，首先调用CAS试图将m.state设置成new的值。然后看一下if里面，如果m.state之前的值也就是old如果没有被占用则表示当前goroutine拿到了锁，则break。我们先看一下new的值的变化，第一个if条件里面new = old + 1&lt;&lt;mutexWaiterShift，结合上面的mutex的state各个位的意义，这句话的意思表示mutex的等待goroutine数目加1。还有awoke为true的情况下，要将m.state的标志位取消掉，也就是这句new &amp;^= mutexWoken的作用。继续看第三个if条件里面，如果里面的if判断失败，则走到runtime_Semacquire()。
看一下这个函数runtime_Semacquire()函数，由于golang1.5之后把之前C语言实现的代码都干掉了，所以现在很低层的代码都是go来实现的。通过源码中的定义我们可以知道这个其实就是信号量的wait操作：等待*s&gt;0，然后减1。编译器里使用的是sync_runtime.semacquire()函数。// Semacquire waits until *s &gt; 0 and then atomically decrements it.
// It is intended as a simple sleep primitive for use by the synchronization
// library and should not be used directly.
func runtime_Semacquire(s *uint32)

//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire
func sync_runtime_Semacquire(addr *uint32) {
    semacquire(addr, true)
}

func semacquire(addr *uint32, profile bool) {
    gp := getg()
    if gp != gp.m.curg {
        throw("semacquire not on the G stack")
    }

    // Easy case.
    if cansemacquire(addr) {
        return
    }

    // Harder case:
    //  increment waiter count
    //  try cansemacquire one more time, return if succeeded
    //  enqueue itself as a waiter
    //  sleep
    //  (waiter descriptor is dequeued by signaler)
    s := acquireSudog()
    root := semroot(addr)
    t0 := int64(0)
    s.releasetime = 0
    if profile &amp;&amp; blockprofilerate &gt; 0 {
        t0 = cputicks()
        s.releasetime = -1
    }
    for {
        lock(&amp;root.lock)
        // Add ourselves to nwait to disable "easy case" in semrelease.
        atomic.Xadd(&amp;root.nwait, 1)
        // Check cansemacquire to avoid missed wakeup.
        if cansemacquire(addr) {
            atomic.Xadd(&amp;root.nwait, -1)
            unlock(&amp;root.lock)
            break
        }
        // Any semrelease after the cansemacquire knows we're waiting
        // (we set nwait above), so go to sleep.
        root.queue(addr, s)
        goparkunlock(&amp;root.lock, "semacquire", traceEvGoBlockSync, 4)
        if cansemacquire(addr) {
            break
        }
    }
    if s.releasetime &gt; 0 {
        blockevent(s.releasetime-t0, 3)
    }
    releaseSudog(s)
}上面的代码有点多，我们只看和锁相关的代码。root := semroot(addr)   //seg 1

atomic.Xadd(&amp;root.nwait, 1) // seg 2

root.queue(addr, s) //seg 3seg 1代码片段semroot()返回结构体semaRoot。存储方式是先对信号量的地址做移位，然后做哈希（对251取模，这个地方为什么是左移3位和对251取模不太明白）。semaRoot相当于和mutex.sema绑定。看一下semaRoot的结构：一个sudog链表和一个nwait整型字段。nwait字段表示该信号量上等待的goroutine数目。head和tail表示链表的头和尾巴，同时为了线程安全，需要使用一个互斥量来保护链表。这个时候细心的同学应该注意到一个问题，我们前面不是从Mutex跟过来的吗，相当于Mutex的实现了使用了Mutex本身？实际上semaRoot里面的mutex只是内部使用的一个简单版本，和sync.Mutex不是同一个。现在把这些倒推回去，runtime_Semacquire()的作用其实就是semaphore的wait(&amp;s)：如果*s&lt;0，则将当前goroutine塞入信号量s关联的goroutine waiting list，并休眠。func semroot(addr *uint32) *semaRoot {
    return &amp;semtable[(uintptr(unsafe.Pointer(addr))&gt;&gt;3)%semTabSize].root
}

type semaRoot struct {
    lock  mutex
    head  *sudog
    tail  *sudog
    nwait uint32 // Number of waiters. Read w/o the lock.
}

// Prime to not correlate with any user patterns.
const semTabSize = 251

var semtable [semTabSize]struct {
    root semaRoot
    pad  [sys.CacheLineSize - unsafe.Sizeof(semaRoot{})]byte
}现在mutex.Lock()还剩下runtime_canSpin(iter)这一段，这个地方其实就是锁的自旋版本。golang对于自旋锁的取舍做了一些限制：1.多核; 2.GOMAXPROCS&gt;1; 3.至少有一个运行的P并且local的P队列为空。golang的自旋尝试只会做几次，并不会一直尝试下去，感兴趣的可以跟一下源码。func sync_runtime_canSpin(i int) bool {
    // sync.Mutex is cooperative, so we are conservative with spinning.
    // Spin only few times and only if running on a multicore machine and
    // GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.
    // As opposed to runtime mutex we don't do passive spinning here,
    // because there can be work on global runq on on other Ps.
    if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
        return false
    }
    if p := getg().m.p.ptr(); !runqempty(p) {
        return false
    }
    return true
}

func sync_runtime_doSpin() {
    procyield(active_spin_cnt)
}
Unlock
Mutex的Unlock函数定义如下// Unlock unlocks m.
// It is a run-time error if m is not locked on entry to Unlock.
//
// A locked Mutex is not associated with a particular goroutine.
// It is allowed for one goroutine to lock a Mutex and then
// arrange for another goroutine to unlock it.
func (m *Mutex) Unlock() {
    if race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }

    // Fast path: drop lock bit.
    new := atomic.AddInt32(&amp;m.state, -mutexLocked)
    if (new+mutexLocked)&amp;mutexLocked == 0 {
        panic("sync: unlock of unlocked mutex")
    }

    old := new
    for {
        // If there are no waiters or a goroutine has already
        // been woken or grabbed the lock, no need to wake anyone.
        if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
            return
        }
        // Grab the right to wake someone.
        new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            runtime_Semrelease(&amp;m.sema)
            return
        }
        old = m.state
    }
}函数入口处的四行代码和race detection相关，暂时不用管。接下来的四行代码是判断是否是嵌套锁。new是m.state-1之后的值。我们重点看for循环内部的代码。if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
    return
}这两句是说：如果阻塞在该锁上的goroutine数目为0或者mutex处于lock或者唤醒状态，则返回。new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
    runtime_Semrelease(&amp;m.sema)
    return
}这里先将阻塞在mutex上的goroutine数目减一，然后将mutex置于唤醒状态。runtime_Semrelease和runtime_Semacquire的作用刚好相反，将阻塞在信号量上goroutine唤醒。有人可能会问唤醒的是哪个goroutine，那么我们可以看一下goroutine wait list的入队列和出队列代码。func (root *semaRoot) queue(addr *uint32, s *sudog) {
    s.g = getg()
    s.elem = unsafe.Pointer(addr)
    s.next = nil
    s.prev = root.tail
    if root.tail != nil {
        root.tail.next = s
    } else {
        root.head = s
    }
    root.tail = s
}

func (root *semaRoot) dequeue(s *sudog) {
    if s.next != nil {
        s.next.prev = s.prev
    } else {
        root.tail = s.prev
    }
    if s.prev != nil {
        s.prev.next = s.next
    } else {
        root.head = s.next
    }
    s.elem = nil
    s.next = nil
    s.prev = nil
}如上所示，wait list入队是插在队尾，出队是从头出。
参考

《Go语言学习笔记》

Go 中的锁源码实现：Mutex，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>49</docid>
    <url>http://blog.jobbole.com/106933/</url>
    <title>Linux 新的API signalfd、timerfd、eventfd使用说明</title>
    <content>三种新的fd加入linux内核的的版本：
signalfd：2.6.22
timerfd：2.6.25
eventfd：2.6.22
三种fd的意义：
lsignalfd
传统的处理信号的方式是注册信号处理函数；由于信号是异步发生的，要解决数据的并发访问，可重入问题。signalfd可以将信号抽象为一个文件描述符，当有信号发生时可以对其read，这样可以将信号的监听放到select、poll、epoll等监听队列中。
ltimerfd
可以实现定时器的功能，将定时器抽象为文件描述符，当定时器到期时可以对其read，这样也可以放到监听队列的主循环中。
leventfd
实现了线程之间事件通知的方式，也可以用于用户态和内核通信。eventfd的缓冲区大小是sizeof(uint64_t)；向其write可以递增这个计数器，read操作可以读取，并进行清零；eventfd也可以放到监听队列中，当计数器不是0时，有可读事件发生，可以进行读取。
三种新的fd都可以进行监听，当有事件触发时，有可读事件发生。
signalfd涉及API：


点击(此处)折叠或打开#include &lt;sys/signalfd.h&gt; 
int signalfd(int fd, const sigset_t *mask, int flags);


参数fd：如果是-1则表示新建一个，如果是一个已经存在的则表示修改signalfd所关联的信号；
参数mask：信号集合；
参数flag：内核版本2.6.27以后支持SFD_NONBLOCK、SFD_CLOEXEC；
成功返回文件描述符，返回的fd支持以下操作：read、select(poll、epoll)、close
l例子#include &lt;sys/signalfd.h&gt; 
  #include &lt;signal.h&gt; 
  #include &lt;unistd.h&gt; 
  #include &lt;stdlib.h&gt; 
  #include &lt;stdio.h&gt; 
 
  #define handle_error(msg) \ 
  do { perror(msg); exit(EXIT_FAILURE); } while (0) 
 
  int main(int argc, char *argv[]) 
  { 
    sigset_t mask; 
    int sfd; 
    struct signalfd_siginfo fdsi; 
    ssize_t s; 
 
    sigemptyset(&amp;mask); 
    sigaddset(&amp;mask, SIGINT); 
    sigaddset(&amp;mask, SIGQUIT); 
 
    if (sigprocmask(SIG_BLOCK, &amp;mask, NULL) == -1) 
        handle_error("sigprocmask"); 
 
    sfd = signalfd(-1, &amp;mask, 0); 
    if (sfd == -1) 
        handle_error("signalfd"); 
 
    for (;;) { 
        s = read(sfd, &amp;fdsi, sizeof(struct signalfd_siginfo)); 
        if (s != sizeof(struct signalfd_siginfo)) 
            handle_error("read"); 
 
        if (fdsi.ssi_signo == SIGINT) { 
           printf("Got SIGINT\n"); 
        } else if (fdsi.ssi_signo == SIGQUIT) { 
        printf("Got SIGQUIT\n"); 
        exit(EXIT_SUCCESS); 
        } else { 
        printf("Read unexpected signal\n"); 
        } 
     } 
  }L17-L21：将感兴趣的信号加入到sigset_t中；
L24：调用signalfd，把信号集与fd关联起来，第一个参数为-1表示新建一个signalfd，不是-1并且是一个合法的signalfd表示向其添加新的信号。
L29：阻塞等待信号的发生并读取。根据读取的结果可以知道发生了什么信号。
timerfd涉及的API

#include &lt;sys/timerfd.h&gt; 
int timerfd_create(int clockid, int flags); 
int timerfd_settime(int fd, int flags, const struct itimerspec *new_value,struct itimerspec *old_value); 
int timerfd_gettime(int fd, struct itimerspec *curr_value);

timerfd_create：创建一个timerfd；返回的fd可以进行如下操作：read、select(poll、epoll)、close
timerfd_settime：设置timer的周期，以及起始间隔
timerfd_gettime：获取到期时间。//函数参数中数据结构如下： 
struct timespec 
{ 
    time_t tv_sec; /* Seconds */ 
    long tv_nsec; /* Nanoseconds */ 
}; 
  struct itimerspec 
{ 
    struct timespec it_interval; /* Interval for periodic timer */ 
    struct timespec it_value; /* Initial expiration */ 
};

l例子

#include &lt;sys/timerfd.h&gt; 
  #include &lt;sys/time.h&gt; 
  #include &lt;time.h&gt; 
  #include &lt;unistd.h&gt; 
  #include &lt;stdlib.h&gt; 
  #include &lt;stdio.h&gt; 
  #include &lt;stdint.h&gt; /* Definition of uint64_t */ 
 
  #define handle_error(msg) \ 
  do { perror(msg); exit(EXIT_FAILURE); } while (0) 
 
  void printTime() 
  { 
      struct timeval tv; 
      gettimeofday(&amp;tv, NULL); 
      printf("printTime: current time:%ld.%ld ", tv.tv_sec, tv.tv_usec); 
  } 
 
  int main(int argc, char *argv[]) 
  { 
      struct timespec now; 
      if (clock_gettime(CLOCK_REALTIME, &amp;now) == -1) 
          handle_error("clock_gettime"); 
 
      struct itimerspec new_value; 
      new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]); 
      new_value.it_value.tv_nsec = now.tv_nsec; 
      new_value.it_interval.tv_sec = atoi(argv[2]); 
      new_value.it_interval.tv_nsec = 0; 
 
      int fd = timerfd_create(CLOCK_REALTIME, 0); 
      if (fd == -1) 
      handle_error("timerfd_create"); 
 
      if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, NULL) == -1) 
          handle_error("timerfd_settime"); 
 
      printTime(); 
      printf("timer started\n"); 
 
      for (uint64_t tot_exp = 0; tot_exp &lt; atoi(argv[3]);) 
      { 
          uint64_t exp; 
          ssize_t s = read(fd, &amp;exp, sizeof(uint64_t)); 
          if (s != sizeof(uint64_t)) 
              handle_error("read"); 
 
          tot_exp += exp; 
          printTime(); 
          printf("read: %llu; total=%llu\n",exp, tot_exp); 
  } 
 
  exit(EXIT_SUCCESS); 
 }代码L25-L29：初始化定时器的参数，初始间隔与定时间隔。
L32：创建定时器fd，CLOCK_REALTIME：真实时间类型，修改时钟会影响定时器；CLOCK_MONOTONIC：相对时间类型，修改时钟不影响定时器。
L35：设置定时器的值。
L44：阻塞等待定时器到期。返回值是未处理的到期次数。比如定时间隔为2秒，但过了10秒才去读取，则读取的值是5。
编译运行：编译时要加rt库(g++ -lrt timerfd.cc -o timerfd)
[root@localhost appTest]# ./timerfd 5 2 10
printTime:  current time:1357391736.146196 timer started
printTime:  current time:1357391741.153430 read: 1; total=1
printTime:  current time:1357391743.146550 read: 1; total=2
printTime:  current time:1357391745.151483 read: 1; total=3
printTime:  current time:1357391747.161155 read: 1; total=4
printTime:  current time:1357391749.153934 read: 1; total=5
printTime:  current time:1357391751.157309 read: 1; total=6
printTime:  current time:1357391753.158384 read: 1; total=7
printTime:  current time:1357391755.150470 read: 1; total=8
printTime:  current time:1357391757.150253 read: 1; total=9
printTime:  current time:1357391759.149954 read: 1; total=10
[root@localhost appTest]#
第一个参数5为第一次定时器到期间隔，第二个参数2为定时器的间隔，第三个参数为定时器到期10次则退出。程序运行(5+2*10)S退出。
详细信息可以：man timerfd_create
eventfd涉及API：

#include &lt;sys/eventfd.h&gt; 
int eventfd(unsigned int initval, int flags);

创建一个eventfd，这是一个计数器相关的fd，计数器不为零是有可读事件发生，read以后计数器清零，write递增计数器；返回的fd可以进行如下操作：read、write、select(poll、epoll)、close。
这个函数会创建一个事件对象 (eventfd object), 用来实现，进程(线程)间的等待/通知(wait/notify) 机制. 内核会为这个对象维护一个64位的计数器(uint64_t)。并且使用第一个参数(initval)初始化这个计数器。调用这个函数就会返回一个新的文件描述符(event object)。2.6.27版本开始可以按位设置第二个参数(flags)。有如下的一些宏可以使用：
lEFD_NONBLOCK
功能同open(2)的O_NONBLOCK，设置对象为非阻塞状态，如果没有设置这个状态的话，read(2)读eventfd,并且计数器的值为0 就一直堵塞在read调用当中，要是设置了这个标志， 就会返回一个 EAGAIN 错误(errno = EAGAIN)。效果也如同 额外调用select(2)达到的效果。
lEFD_CLOEXEC
这个标识被设置的话，调用exec后会自动关闭文件描述符，防止泄漏。如果是2.6.26或之前版本的内核，flags 必须设置为0。
创建这个对象后，可以对其做如下操作：
1) write： 将缓冲区写入的8字节整形值加到内核计数器上。
2) read： 读取8字节值， 并把计数器重设为0. 如果调用read的时候计数器为0， 要是eventfd是阻塞的， read就一直阻塞在这里，否则就得到 一个EAGAIN错误。如果buffer的长度小于8那么read会失败， 错误代码被设置成 EINVAL。
3) poll select epoll
4) close: 当不需要eventfd的时候可以调用close关闭， 当这个对象的所有句柄都被关闭的时候，内核会释放资源。 为什么不是close就直接释放呢， 如果调用fork 创建
进程的时候会复制这个句柄到新的进程，并继承所有的状态。
l例子
#include &lt;sys/eventfd.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdint.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;errno.h&gt;
 #define handle_error(msg) \
    do { perror(msg); exit(1); } while (0)
int main( int argc, char **argv ){
     uint64_t u;
     ssize_t s;5 int j;
     if ( argc &lt; 2 ) {
        fprintf(stderr, "input in command argument");
         exit(1);
     }
 
     int efd;
     if ( (efd = eventfd(0, EFD_NONBLOCK)) == -1 )
             handle_error("eventfd failed");
 
 
     switch (fork()) {
         case 0:
             for( j = 1; j &lt; argc; j ++ ) {
                 printf("Child writing %s to efd\n", argv[j] );
             
                 u = strtoull(argv[j], NULL, 0); /* analogesly atoi */
                 s = write(efd, &amp;u, sizeof(uint64_t));/*append u to counter */
                 if ( s != sizeof(uint64_t) )
                     handle_error("write efd failed");
 
             }
             printf("child completed write loop\n");
 
             exit(0);
         default:
             sleep (2);
             
             printf("parent about to read\n");
             s = read(efd, &amp;u, sizeof(uint64_t));
             if ( s != sizeof(uint64_t) ) {
                 if (errno = EAGAIN) {
                     printf("Parent read value %d\n", s);
                     return 1;
                 }
                 handle_error("parent read failed");
             }
             printf("parent read %d , %llu (0x%llx) from efd\n",
                     s, (unsigned long long)u, (unsigned long long) u);
             exit(0);
 
         case -1:
             handle_error("fork ");
     }
     return 0;
}

Linux 新的API signalfd、timerfd、eventfd使用说明，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>50</docid>
    <url>http://blog.jobbole.com/106922/</url>
    <title>一个屌丝程序猿的人生（39）</title>
    <content>
本系列：第 1 篇 、第 2 篇、第 3 篇、（4）、（5）、（6）、（7）、（8）、（9）、10）、（11）、（12）、（13）、（14）、（15）、（16）、（17）、（18）、（19）、（20）、（21）、（22）、（23）、（24）、（25）、（26）、（27）、（28）、（29）、（30）、（31）、（32）、（33）、（34）、（35）、（36）、（37）、（38）

有史晓玲这么一位颜值不错的妹子常伴左右，换作一般人还真的很难静下心来学习，但是林萧却很清楚，在眼前的情况下，撩妹和学习到底孰轻孰重。
更何况，这妹子可是怀了张亮的孩子的，就算是要撩妹，林萧也还没到饥不择食的地步，拿自己兄弟的妹子下手。
这事儿特么不地道啊！
于是，心无旁鹭的林萧，在结束了Java基础的学习之后，立即便开始了接下来的视频学习。
&#8230;&#8230;
紧接着Java基础的一章，是Java高级特性。
不知为何，程序猿总会对这些听起来很牛逼的词汇感兴趣，因此，一看到“高级特性”四个字，林萧立马就来了精神。
然而事实上，真正牛逼的东西，往往不是那么好理解的。至少对于一个初入Java领域的菜鸟来说，“高级特性”这四个字还是太过深奥了一些。
就说“高级特性”中最开始的内容吧，面向对象的三个重要特性，继承、封装以及多态。
其中继承其实已经是最好理解的一个了，原因是继承在现实中的例子实在是太多了，最典型的就是父子之间的关系。
儿子会继承老爸身上某一部分的特征，并且还会拥有老爸身上所没有的一些特点。这正是诠释着，子类可以继承父类的属性和方法，并且通常还会拥有父类所没有的一些属性和方法。
与此同时，儿子虽然可以继承老爸的一些特征，但也并不是所有特征都可以继承的。因此，这也正是诠释着，子类只能继承父类部分的属性和方法，一些隐藏比较深的，例如被private所修饰的，子类也是继承不了的。
知道继承的以上两点，对于一个新人来说，就基本上足够了。至于一些有关继承比较高级的用法，例如模板方法模式这种的，就只能在以后的路上，慢慢研究去了。
封装相较于继承，会比较难理解一些。不过对于很抽象很难理解的知识，林萧有自己的办法，那就是找相似的事物。
因为林萧相信，世间万物都是相通的，任何一个知识点，你总能在其它领域找到相似的。
就说谈恋爱这回事吧，都说没有最好的，只有最合适的，这句话，其实也同样可以适用于找工作，这就是一个最简单的道理相通的例子。
知道了这一点之后，如何找到一个合适的例子，就比较关键了。
关于封装的现实例子，其实说起来还是蛮多的。就说叫外卖这件事吧，其实卖家就充分体现了封装的思想。
那么卖家到底封装了哪些东西？
很显然，大致包括了买菜、洗菜、做饭、送饭等等一系列的动作，而你只需要付钱给外卖员，就可以吃到香喷喷的饭菜。你不需要知道如何买菜，如何做饭等等这些琐碎的事情，你要做的就一件事，就是掏钱！
这就是现实中封装的思想，也就是所谓的一站式服务。
对应到编程世界，其实也是一样的，一个类要尽可能把自己的服务细节隐藏起来，不对外部暴露，让外部的类只需要“付钱”，就可以方便的调用服务即可。
隐藏细节，这其实就是封装的核心思想了。
三大特性中，继承和封装都说完了，还剩下最后一个特性，也是最难理解的一个。
多态在很多人刚接触Java时，都难免会觉得懵逼，林萧也不例外。尽管他一直在试图理解“不同的类型有不同的表现”这句话，但其实他在当时，始终都没有理解到多态的本质。
多态的本质其实用一句话就可以概括，就是“编译时和运行时才决定对象的行为”，俗称为静态分派和动态分派。
很多人第一次看到这两个词的时候，应该比看到多态更加懵逼，但其实沉下心来去想想，这两个词其实非常好理解。
不过理解的前提是，你要非常清楚一个Java程序从编写到运行的过程，简单的说，这个过程就是编译和执行。
而静态分派和动态分派的本质就是，静态分派是编译期间就可以决定的，而动态分派则是执行期间才可以决定的。
要理解编译期和执行期其实也非常好理解，你可以把计算机看做是一个英国人，而你是一个中国人，程序就是你写的一篇文章。
那么计算机要想运行你的程序，也就相当于英国人要想读你的文章。
那就首先得有人把你的文章翻译成英文，这个过程就相当于编译的过程。这个负责翻译的人，在现实里就叫翻译员，而在程序世界里，就是编译器。
当文章被翻译成英文以后，英国人就开始阅读你的文章，也就相当于计算机开始运行你的程序。
而对于Java程序来说，编译器其实就是javac，而所谓的计算机，其实就是JVM。
理解这个最基本的编译和执行的过程，静态分派和动态分派就很好理解了。而理解了静态分派和动态分派，多态就非常好理解了。
当然了，这些知识，对于初学Java的林萧来说，当然是不太可能彻底理解的，不过这其实并无大碍，学习本身就是一个循序渐进的过程。
&#8230;&#8230;
说起来，林萧也算是够拼命的，自从开始培训以后，几乎就变成了足不出户的骨灰级宅男，与当初在家里玩游戏的时候，简直是如出一撤。
一天下来，除了上厕所和拿外卖以外，林萧几乎可以做到坐在椅子上一动不动。这种惊人的毅力和懒的程度，如果不是以前玩游戏早已经习惯了的话，说不定林萧还真坚持不下来。
但是，这种生活虽然看起来挺苦逼的，林萧却非常乐在其中。而且，游戏所带来的快感，与知识所带来的快感相比，始终缺少了一种充实感。
这种充实感，可以帮你驱散孤独，也会让你有种，未来掌握在自己手里的安全感。
此时此刻，林萧心中多少有些明白了，为什么有人说，成功的男人要学会享受孤独。因为享受孤独的过程，其实就是你充实自己的过程。
然而，就在林萧尽情享受孤独，疯狂得充实自己的时候，一个故人却再次打断了这种疯狂而又宁静的生活。
她，来了。
&nbsp;

一个屌丝程序猿的人生（39），首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>51</docid>
    <url>http://blog.jobbole.com/106923/</url>
    <title>C++ 内存分配(new，operator new)详解</title>
    <content>本文主要讲述C++ new运算符和operator new, placement new之间的种种关联，new的底层实现，以及operator new的重载和一些在内存池，STL中的应用。
一 new 运算符和 operator new()：
new：指我们在C++里通常用到的运算符，比如A* a = new A;  对于new来说，有new和::new之分，前者位于std
operator new()：指对new的重载形式，它是一个函数，并不是运算符。对于operator new来说，分为全局重载和类重载，全局重载是void* ::operator new(size_t size)，在类中重载形式 void* A::operator new(size_t size)。还要注意的是这里的operator new()完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个void*指针。而构造函数的调用(如果需要)是在new运算符中完成的。
先简单解释一下new和operator new之间的关系：
关于这两者的关系，我找到一段比较经典的描述（来自于www.cplusplus.com 见参考文献）：
operator new can be called explicitly as a regular function, but in C++, new is an operator with a very specific behavior: An expression with the new operator, first calls function operator new (i.e., this function) with the size of its type specifier as first argument, and if this is successful, it then automatically initializes or constructs the object (if needed). Finally, the expression evaluates as a pointer to the appropriate type.
比如我们写如下代码：A* a = new A;我们知道这里分为两步：1.分配内存，2.调用A()构造对象。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，如果没有重载，就调用::operator new(size_t )，全局new操作符由C++默认提供。因此前面的两步也就是：1.调用operator new 2.调用构造函数。这里再一次提出来是因为后面关于这两步会有一些变形，在关于placement new那里会讲到。
先举个简单例子//平台：Visual Stdio 2008  
#include&lt;iostream&gt;  
class A  
{  
public:  
     A()  
     {  
          std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
     }  
  
     ~A()  
     {  
          std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
     }  
}  
int _tmain(int argc, _TCHAR* argv[])  
{  
  
     A* a = new A;  
     delete a;  
  
     system("pause");  
     return 0;  
}下面我们跟踪一下A反汇编代码，由于Debug版本反汇编跳转太多，因此此处通过Release版本在A* a = new A;处设断点反汇编：
在Release版本中，构造函数和析构函数都是直接展开的。A* a = new A;  
01301022  push        1    ;不含数据成员的类占用一字节空间，此处压入sizeof(A)  
01301024  call        operator new (13013C2h) ;调用operator new(size_t size)  
01301029  mov         esi,eax ;返回值保存到esi  
0130102B  add         esp,4 ;平衡栈  
0130102E  mov         dword ptr [esp+8],esi ;  
01301032  mov         dword ptr [esp+14h],0   
0130103A  test        esi,esi ;在operator new之后，检查其返回值，如果为空(分配失败)，则不调用A()构造函数  
0130103C  je          wmain+62h (1301062h) ;为空 跳过构造函数部分  
0130103E  mov         eax,dword ptr [__imp_std::endl (1302038h)] ;构造函数内部，输出字符串  
01301043  mov         ecx,dword ptr [__imp_std::cout (1302050h)]   
01301049  push        eax    
0130104A  push        offset string "call A constructor" (1302134h)   
0130104F  push        ecx    
01301050  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h)   
01301055  add         esp,8   
01301058  mov         ecx,eax   
0130105A  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)]   
01301060  jmp         wmain+64h (1301064h) ;构造完成，跳过下一句  
01301062  xor         esi,esi ;将esi置空，这里的esi即为new A的返回值  
01301064  mov         dword ptr [esp+14h],0FFFFFFFFh   
    delete a;  
0130106C  test        esi,esi ;检查a是否为空  
0130106E  je          wmain+9Bh (130109Bh) ;如果为空，跳过析构函数和operator delete  
01301070  mov         edx,dword ptr [__imp_std::endl (1302038h)] ;析构函数 输出字符串  
01301076  mov         eax,dword ptr [__imp_std::cout (1302050h)]   
0130107B  push        edx    
0130107C  push        offset string "call A destructor" (1302148h)   
01301081  push        eax    
01301082  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h)   
01301087  add         esp,8   
0130108A  mov         ecx,eax   
0130108C  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)]   
01301092  push        esi  ;压入a   
01301093  call        operator delete (13013BCh) ;调用operator delete   
01301098  add         esp,4   
通过反汇编可以看出A* = new A包含了operator new(sizeof(A))和A()两个步骤(当然，最后还要将值返回到a)  
         delete a包含了~A()和operator delete(a)两个步骤。
二 operator new 的三种形式：
operator new有三种形式：
throwing (1)void* operator new (std::size_t size) throw (std::bad_alloc);nothrow (2)void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();placement (3)void* operator new (std::size_t size, void* ptr) throw();(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。它们都分配一个固定大小的连续内存。
用法示例：A* a = new A; //调用throwing(1)
A* a = new(std::nothrow) A; //调用nothrow(2)（3）是placement new，它也是对operator new的一个重载，定义于中，它多接收一个ptr参数，但它只是简单地返回ptr。
其在new.h下的源代码如下：#define __PLACEMENT_NEW_INLINE  
inline void *__cdecl operator new(size_t, void *_P)  
        {return (_P); }  
#if     _MSC_VER &gt;= 1200  
inline void __cdecl operator delete(void *, void *)  
    {return; }  
#endif  
#endif那么它究竟有什么用呢？事实上，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。
它的调用形式为：new(p) A(); //也可用A(5)等有参构造函数。前面说到，new运算符都会调用operator new，而这里的operator new(size_t, void*)并没有什么作用，真正起作用的是new运算符的第二个步骤：在p处调用A构造函数。这里的p可以是动态分配的内存，也可以是栈中缓冲，如char buf[100]; new(buf) A();
我们仍然可以通过一个例子来验证：#include &lt;iostream&gt;  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
};  
int _tmain(int argc, _TCHAR* argv[])  
{  
  
    A* p = (A*)::operator new(sizeof(A)); //分配  
  
    new(p) A(); //构造  
      
    p-&gt;~A(); //析构  
  
    ::operator delete(p); //释放  
  
    system("pause");  
    return 0;  
}
上面的代码将对象的分配，构造，析构和释放分离开来，这也是new和delete运算符两句就能完成的操作。
先直接运行可以看到程序输出：
再分别注释掉new(a) A();和a-&gt;~A();两句，可以看到对应的构造和析构函数将不会被调用。
然后查看反汇编：
平台: Visual Studio 2008 Debug版A* a = (A*)::operator new(sizeof(A)); //分配  
00F9151D  push        1      
00F9151F  call        operator new (0F91208h) ;调用::operator new(size_t size)也就是throwing(1)版本  
00F91524  add         esp,4   
00F91527  mov         dword ptr [ebp-14h],eax ;返回地址放入[ebp-14h] 即为p  
  
    new(a) A(); //构造  
00F9152A  mov         eax,dword ptr [ebp-14h]   
00F9152D  push        eax    
00F9152E  push        1    ;压入p  
00F91530  call        operator new (0F91280h);调用operator new(size_t, void* p)即placement(3)版本 只是简单返回p  
00F91535  add         esp,8   
00F91538  mov         dword ptr [ebp-0E0h],eax ;将p放入[ebp-0E0h]  
00F9153E  mov         dword ptr [ebp-4],0   
00F91545  cmp         dword ptr [ebp-0E0h],0   ;判断p是否为空  
00F9154C  je          wmain+81h (0F91561h)     ;如果为空 跳过构造函数  
00F9154E  mov         ecx,dword ptr [ebp-0E0h] ;取出p到ecx  
00F91554  call        A::A (0F91285h)          ;调用构造函数 根据_thiscall调用约定 this指针通过ecx寄存器传递  
00F91559  mov         dword ptr [ebp-0F4h],eax ;将返回值(this指针)放入[ebp-0F4h]中  
00F9155F  jmp         wmain+8Bh (0F9156Bh)     ;跳过下一句  
00F91561  mov         dword ptr [ebp-0F4h],0   ;将[ebp-0F4h]置空 当前面判断p为空时执行此语句  
00F9156B  mov         ecx,dword ptr [ebp-0F4h] ;[ebp-0F4h]为最终构造完成后的this指针(或者为空) 放入ecx  
00F91571  mov         dword ptr [ebp-0ECh],ecx ;又将this放入[ebp-0ECh] 这些都是调试所用  
00F91577  mov         dword ptr [ebp-4],0FFFFFFFFh   
      
    a-&gt;~A(); //析构  
00F9157E  push        0      
00F91580  mov         ecx,dword ptr [ebp-14h] ;从[ebp-14h]中取出p  
00F91583  call        A::`scalar deleting destructor' (0F91041h) ;调用析构函数(跟踪进去比较复杂 如果在Release下，构造析构函数都是直接展开的)  
  
    ::operator delete(a); //释放  
00F91588  mov         eax,dword ptr [ebp-14h]   ;将p放入eax  
00F9158B  push        eax           ;压入p  
00F9158C  call        operator delete (0F910B9h);调用operator delete(void* )  
00F91591  add         esp,4 &lt;/span&gt;从反汇编中可以看出，其实operator new调用了两次，只不过每一次调用不同的重载函数，并且placement new的主要作用只是将p放入ecx，并且调用其构造函数。
事实上，在指定地址上构造对象还有另一种方法，即手动调用构造函数：p-&gt;A::A(); 这里要加上A::作用域，否则编译器会报错：error C2273: “函数样式转换”: 位于“-&gt;”运算符右边时非法
用p-&gt;A::A();替换掉new(p) A();仍然能达到同样的效果，反汇编：A* a = (A*)::operator new(sizeof(A)); //分配  
010614FE  push        1      
01061500  call        operator new (1061208h)   
01061505  add         esp,4   
01061508  mov         dword ptr [a],eax   
  
    //new(a) A();   //构造  
    a-&gt;A::A();  
0106150B  mov         ecx,dword ptr [a]   
0106150E  call        operator new (1061285h)   
  
    a-&gt;~A(); //析构  
01061513  push        0      
01061515  mov         ecx,dword ptr [a]   
01061518  call        A::`scalar deleting destructor' (1061041h)   
  
    ::operator delete(a); //释放  
0106151D  mov         eax,dword ptr [a]   
01061520  push        eax    
01061521  call        operator delete (10610B9h)   
01061526  add         esp,4比之前的方法更加简洁高效(不需要调用placement new)。不知道手动调用构造函数是否有违C++标准或有什么隐晦，我在其他很多有名的内存池(包括SGI STL alloc)实现上看到都是用的placement new，而不是手动调用构造函数。
三 operator new 重载：
前面简单提到过 A* p = new A；所发生的事情：先调用operator new，如果类A重载了operator new，那么就使用该重载版本，否则使用全局版本::operatro new(size_t size)。那么类中可以重载operator new的哪些版本？全局operator new可以重载吗？全局和类中重载分别会在什么时机调用？
1.在类中重载 operator new
上面提到的throwing(1)和nothrow(2)的operator new是可以被重载的，比如：#include &lt;iostream&gt;  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
    void* operator new(size_t size)  
    {  
        std::cout&lt;&lt;"call A::operator new"&lt;&lt;std::endl;  
        return malloc(size);  
    }  
  
    void* operator new(size_t size, const std::nothrow_t&amp; nothrow_value)  
    {  
        std::cout&lt;&lt;"call A::operator new nothrow"&lt;&lt;std::endl;  
        return malloc(size);  
    }  
};  
int _tmain(int argc, _TCHAR* argv[])  
{  
    A* p1 = new A;  
    delete p1;  
  
    A* p2 = new(std::nothrow) A;  
    delete p2;  
  
    system("pause");  
    return 0;  
}

如果类A中没有对operator new的重载，那么new A和new(std::nothrow) A;都将会使用全局operator new(size_t size)。可将A中两个operator new注释掉，并且在A外添加一个全局operator new重载：void* ::operator new(size_t size)  
{  
    std::cout&lt;&lt;"call global operator new"&lt;&lt;std::endl;  
    return malloc(size);  
}程序输出：

注意，这里的重载遵循作用域覆盖原则，即在里向外寻找operator new的重载时，只要找到operator new()函数就不再向外查找，如果参数符合则通过，如果参数不符合则报错，而不管全局是否还有相匹配的函数原型。比如如果这里只将A中operator new(size_t, const std::nothrow_t&amp;)删除掉，就会报错：
error C2660: “A::operator new”: 函数不接受 2 个参数。
至于placement new，它本身就是operator new的一个重载，不需也尽量不要对它进行改写，因为它一般是搭配 new(p) A(); 工作的，它的职责只需简单返回指针。
对operator new的重载还可以添加自定义参数，如在类A中添加void* operator new(size_t size, int x, int y, int z)  
{  
    std::cout&lt;&lt;"X="&lt;&lt;x&lt;&lt;"  Y="&lt;&lt;y&lt;&lt;" Z="&lt;&lt;z&lt;&lt;std::endl;  
    return malloc(size);  
}这种重载看起来没有什么大作用，因为它operator new需要完成的任务只是分配内存，但是通过对这类重载的巧妙应用，可以让它在动态分配内存调试和检测中大展身手。这将在后面operator new重载运用技巧中，展现。
2.重载全局 operator new
全局operator new的重载和在类中重载并无太大区别，当new A;时，如果类A中没有重载operator new，那么将调用全局operator new函数，如果没有重载全局operator new，最后会调用默认的全局operator new。
3.类中operator new和全局 operator new 的调用时机
前面已经提到了在new时的调用顺序，但是这里提出来的原因是还存在一个全局的new运算符，也就是::new，这个运算符会直接调用全局operator new，并且也会调用构造函数。这可能让人很犯迷糊，只做了解即可。这里提到的调用时机都是指通过new运算符调用，没有讨论其他情况，比如主动调用。
四 operator new运用技巧和一些实例探索
1.operator new 重载运用于调试：
前面提到如何operator new的重载是可以有自定义参数的，那么我们如何利用自定义参数获取更多的信息呢，这里一个很有用的做法就是给operator new添加两个参数:char* file, int line,这两个参数记录new运算符的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。
那么如何获取当前语句所在文件名和行号呢，windows提供两个宏：__FILE__和__LINE__。利用它们可以直接获取到文件名和行号，也就是 new(__FILE__, __LINE__) 由于这些都是不变的，因此可以再定义一个宏：#define new new(__FILE__, __LINE__)。这样我们就只需要定义这个宏，然后重载operator new即可。
源代码如下，这里只是简单输出new的文件名和行号。//A.h  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
  
    void* operator new(size_t size, const char* file, int line)  
    {  
        std::cout&lt;&lt;"call A::operator new on file:"&lt;&lt;file&lt;&lt;"  line:"&lt;&lt;line&lt;&lt;std::endl;  
        return malloc(size);  
        return NULL;  
    }  
  
};  
//Test.cpp  
#include &lt;iostream&gt;  
#include "A.h"  
#define new new(__FILE__, __LINE__)  
  
int _tmain(int argc, _TCHAR* argv[])  
{  
    A* p1 = new A;  
    delete p1;  
  
    A* p2 = new A;  
    delete p2;  
  
    system("pause");  
    return 0;  
}输出：


注意：需要将类的声明实现与new的使用隔离开来。并且将类头文件放在宏定义之前。否则在类A中的operator new重载中的new会被宏替换，整个函数就变成了： void* operator new(__FILE__, __LINE__)(size_t size, char* file, int line)
编译器自然会报错。
2.内存池优化
operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new运算符，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。
3.STL中的 new
在SGI STL源码中,defalloc.h和stl_construct.h中提供了最简单的空间配置器(allocator)封装，见《STL源码剖析》P48。它将对象的空间分配和构造分离开来，虽然在defalloc.h中仅仅是对::operator new和::operator delete的一层封装，但是它仍然给STL容器提供了更加灵活的接口
SGI STL真正使用的并不是defalloc.h中的分配器，而是stl_alloc.h中的SGI精心打造的&#8221;双层级配置器&#8221;，它将内存池技术演绎得淋漓尽致，值得细细琢磨。顺便提一下，在stl_alloc.h中并没有使用::operator new/delete 而直接使用malloc和free。具体缘由均可参见《STL源码剖析》。
五 delete 的使用
delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。但是有一点需要注意，operator delete的自定义参数重载并不能手动调用。比如void* operator new(size_t size, int x)  
{  
    cout&lt;&lt;" x = "&lt;&lt;x&lt;&lt;endl;  
    return malloc(size);      
}  
void operator delete(void* p, int x)  
{  
    cout&lt;&lt;" x = "&lt;&lt;x&lt;&lt;endl;  
    free(p);  
}如下调用是无法通过的：A* p = new(3) A;//Ok
delete(3) p;//error C2541: “delete”: 不能删除不是指针的对象那么重载operator delete有什么作用？如何调用？事实上以上自定义参数operator delete 只在一种情况下被调用：当new运算符抛出异常时。
可以这样理解，只有在new运算符中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new运算符，编译器对于你自定义的new将一无所知，因此它只会按照你指定的delete运算符形式来调用operator delete，而至于为什么不能指定调用自定义delete(也就是只能老老实实delete p)，这个就不知道了。
细心观察的话，上面operator new用于调试的例子代码中，由于我们没有给出operator new对应的operator delete。在VS2008下会有如下警告：
warning C4291: “void *A::operator new(size_t,const char *,int)”: 未找到匹配的删除运算符；如果初始化引发异常，则不会释放内存
六 关于 new 和内存分配的其他
 1.set_new_handler
还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)。下面这段程序完成这个测试：#include &lt;iostream&gt;  
#include &lt;new.h&gt;// 使用_set_new_mode和set_new_handler  
void nomem_handler()  
{  
    std::cout&lt;&lt;"call nomem_handler"&lt;&lt;std::endl;  
}  
int main()  
{  
    _set_new_mode(1);  //使new_handler有效  
    set_new_handler(nomem_handler);//指定入口函数 函数原型void f();  
    std::cout&lt;&lt;"try to alloc 2GB memory...."&lt;&lt;std::endl;  
    char* a = (char*)malloc(2*1024*1024*1024);  
    if(a)  
        std::cout&lt;&lt;"ok...I got it"&lt;&lt;std::endl;  
    free(a);  
    system("pause");  
}程序运行后会一直输出call nomem_handler 因为函数里面只是简单输出，返回，系统尝试分配失败后，调用nomem_handler函数，由于该函数并没有起到实际作用(让可分配内存增大)，因此返回后系统再次尝试分配失败，再调用nomem_handler，循环下去。
在SGI STL中的也有个仿new_handler函数:oom_malloc
2.new 分配数组
A* p = new A[3];中，会直接调用全局的operator new[](size_t size)，而不管A中是否有operator new[]的重载。而delete[]p却会优先调用A::operator delete[](void*)(如果A中有重载)。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008下这个额外数据占4个字节，一个int大小。测试代码如下//A.h  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
  
    void* operator new(size_t size)  
    {  
        std::cout&lt;&lt;"call A::operator new[] size:"&lt;&lt;size&lt;&lt;std::endl;  
        return malloc(size);  
    }  
    void operator delete[](void* p)  
    {  
        std::cout&lt;&lt;"call A::operator delete[]"&lt;&lt;std::endl;  
        free(p);  
    }   
    void operator delete(void* p)  
    {  
        free(p);  
    }   
};//Test.cpp  
#include &lt;iostream&gt;  
#include "A.h"  
  
void* operator new[](size_t size)  
{  
    std::cout&lt;&lt;"call global new[] size: "&lt;&lt;size&lt;&lt;std::endl;  
    return malloc(size);  
}  
  
void operator delete[](void* p)  
{  
    std::cout&lt;&lt;"call global delete[] "&lt;&lt;std::endl;  
}  
int _tmain(int argc, _TCHAR* argv[])  
{  
    std::cout&lt;&lt;"sizeof A "&lt;&lt;sizeof(A)&lt;&lt;std::endl;  
    A* p1 = new A[3];  
    delete []p1;  
   
    system("pause");  
    return 0;  
}输出：


简单跟踪了一下：
operator new[]返回的是0x005b668 而最后new运算符返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。

在内存中，可以看到前面的四个字节额外数据是0x00000003 也就是3，代表数组元素个数。后面三个cd是堆在Debug中的默认值(中文的cdcd就是&#8221;屯&#8221;，栈的初始值为cc，0xcccc中文&#8221;烫&#8221;)。再后面的0xfdfdfdfd应该是堆块的结束标志，前面我有博客专门跟踪过。

注：其实在malloc源码中也有内存池的运用，而且也比较复杂。最近在参考dlmalloc版本和STL空间适配器，真没有想到一个内存分配能涉及这么多的东西。
C++ 内存分配(new，operator new)详解，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>52</docid>
    <url>http://blog.jobbole.com/106919/</url>
    <title>制作你的第一个 Atom 文本编辑器插件</title>
    <content>序言
这篇教程将会教你怎么制作你的第一个 Atom 文本编辑器的插件。我们将会制作一个山寨版的 Sourcerer，这是一个从 StackOverflow 查询并使用代码片段的插件。到教程结束时，你将会制作好一个将编程问题（用英语描述的）转换成获取自 StackOverflow 的代码片段的插件，像这样：

教程须知
Atom 文本编辑器是用 web 技术创造出来的。我们将完全使用 JavaScript 的 EcmaScript 6 规范来制作插件。你需要熟悉以下内容：

使用命令行
JavaScript 编程
Promises
HTTP

教程的仓库
你可以跟着教程一步一步走，或者看看 放在 GitHub 上的仓库，这里有插件的源代码。这个仓库的历史提交记录包含了这里每一个标题。
开始
安装 Atom
根据 Atom 官网 的说明来下载 Atom。我们同时还要安装上 apm（Atom 包管理器的命令行工具）。你可以打开 Atom 并在应用菜单中导航到 Atom &gt; Install Shell Commands 来安装。打开你的命令行终端，运行apm -v 来检查 apm 是否已经正确安装好，安装成功的话打印出来的工具版本和相关环境信息应该是像这样的：apm -v
&gt; apm  1.9.2
&gt; npm  2.13.3
&gt; node 0.10.40
&gt; python 2.7.10
&gt; git 2.7.4
生成骨架代码
让我们使用 Atom 提供的一个实用工具创建一个新的 package（软件包）来开始这篇教程。

启动编辑器，按下 Cmd+Shift+P（MacOS）或者 Ctrl+Shift+P（Windows/Linux）来打开命令面板Command Palette。
搜索“Package Generator: Generate Package”并点击列表中正确的条目，你会看到一个输入提示，输入软件包的名称：“sourcefetch”。
按下回车键来生成这个骨架代码包，它会自动在 Atom 中打开。

如果你在侧边栏没有看到软件包的文件，依次按下 Cmd+K Cmd+B（MacOS）或者 Ctrl+KCtrl+B（Windows/Linux）。

Command Palette可以让你通过模糊搜索来找到并运行软件包。这是一个执行命令比较方便的途径，你不用去找导航菜单，也不用刻意去记快捷键。我们将会在整篇教程中使用这个方法。
运行骨架代码包
在开始编程前让我们来试用一下这个骨架代码包。我们首先需要重启 Atom，这样它才可以识别我们新增的软件包。再次打开命令面板，执行 Window: Reload 命令。
重新加载当前窗口以确保 Atom 执行的是我们最新的源代码。每当需要测试我们对软件包的改动的时候，就需要运行这条命令。
通过导航到编辑器菜单的 Packages &gt; sourcefetch &gt; Toggle 或者在命令面板执行 sourcefetch:toggle 来运行软件包的 toggle 命令。你应该会看到屏幕的顶部出现了一个小黑窗。再次运行这条命令就可以隐藏它。

“toggle”命令
打开 lib/sourcefetch.js，这个文件包含有软件包的逻辑和 toggle 命令的定义。
&nbsp;toggle() {
 console.log('Sourcefetch was toggled!');
 return (
   this.modalPanel.isVisible() ?
   this.modalPanel.hide() :
   this.modalPanel.show()
 );
}toggle 是这个模块导出的一个函数。根据模态面板的可见性，它通过一个三目运算符 来调用 show 和hide 方法。modalPanel 是 Panel（一个由 Atom API 提供的 UI 元素） 的一个实例。我们需要在 export default 内部声明 modalPanel 才可以让我们通过一个实例变量 this 来访问它。this.subscriptions.add(atom.commands.add('atom-workspace', {
  'sourcefetch:toggle': () =&gt; this.toggle()
}));上面的语句让 Atom 在用户运行 sourcefetch:toggle 的时候执行 toggle 方法。我们指定了一个 匿名函数() =&gt; this.toggle()，每次执行这条命令的时候都会执行这个函数。这是事件驱动编程（一种常用的 JavaScript 模式）的一个范例。
Atom 命令
命令只是用户触发事件时使用的一些字符串标识符，它定义在软件包的命名空间内。我们已经用过的命令有：

package-generator:generate-package
Window:reload
sourcefetch:toggle

软件包对应到命令，以执行代码来响应事件。
进行你的第一次代码更改
让我们来进行第一次代码更改——我们将通过改变 toggle 函数来实现逆转用户选中文本的功能。
改变 “toggle” 函数
如下更改 toggle 函数。toggle() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    let reversed = selection.split('').reverse().join('')
    editor.insertText(reversed)
  }
}
测试你的改动

通过在命令面板运行 Window: Reload 来重新加载 Atom。
通过导航到 File &gt; New 来创建一个新文件，随便写点什么并通过光标选中它。
通过命令面板、Atom 菜单或者右击文本然后选中 Toggle sourcefetch 来运行sourcefetch:toggle 命令。

更新后的命令将会改变选中文本的顺序：

在 sourcefetch 教程仓库 查看这一步的全部代码更改。
Atom 编辑器 API
我们添加的代码通过用 TextEditor API 来访问编辑器内的文本并进行操作。让我们来仔细看看。let editor
if (editor = atom.workspace.getActiveTextEditor()) { /* ... */ }头两行代码获取了 TextEditor 实例的一个引用。变量的赋值和后面的代码被包在一个条件结构里，这是为了处理没有可用的编辑器实例的情况，例如，当用户在设置菜单中运行该命令时。let selection = editor.getSelectedText()调用 getSelectedText 方法可以让我们访问到用户选中的文本。如果当前没有文本被选中，函数将返回一个空字符串。let reversed = selection.split('').reverse().join('')
editor.insertText(reversed)我们选中的文本通过一个 JavaScript 字符串方法 来逆转。最后，我们调用 insertText 方法来将选中的文本替换为逆转后的文本副本。通过阅读 Atom API 文档，你可以学到更多关于 TextEditor 的不同的方法。
浏览骨架代码
现在我们已经完成第一次代码更改了，让我们浏览骨架代码包的代码来深入了解一下 Atom 的软件包是怎样构成的。
主文件
主文件是 Atom 软件包的入口文件。Atom 通过 package.json 里的条目设置来找到主文件的位置："main": "./lib/sourcefetch",这个文件导出一个带有生命周期函数（Atom 在特定的事件发生时调用的处理函数）的对象。

activate 会在 Atom 初次加载软件包的时候调用。这个函数用来初始化一些诸如软件包所需的用户界面元素的对象，以及订阅软件包命令的处理函数。
deactivate 会在软件包停用的时候调用，例如，当用户关闭或者刷新编辑器的时候。
serialize Atom 调用它在使用软件包的过程中保存软件包的当前状态。它的返回值会在 Atom 下一次加载软件包的时候作为一个参数传递给 activate。

我们将会重命名我们的软件包命令为 fetch，并移除一些我们不再需要的用户界面元素。按照如下更改主文件：'use babel';
import { CompositeDisposable } from 'atom'
export default {
  subscriptions: null,
  activate() {
    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'sourcefetch:fetch': () =&gt; this.fetch()
    }))
  },
  deactivate() {
    this.subscriptions.dispose()
  },
  fetch() {
    let editor
    if (editor = atom.workspace.getActiveTextEditor()) {
      let selection = editor.getSelectedText()
      selection = selection.split('').reverse().join('')
      editor.insertText(selection)
    }
  }
};
“启用”命令
为了提升性能，Atom 软件包可以用时加载。我们可以让 Atom 在用户执行特定的命令的时候才加载我们的软件包。这些命令被称为 启用命令，它们在 package.json 中定义："activationCommands": {
  "atom-workspace": "sourcefetch:toggle"
},有一些软件包需要在 Atom 启动的时候被加载，例如那些改变 Atom 外观的软件包。在那样的情况下，activationCommands 会被完全忽略。
“触发”命令
菜单项
menus 目录下的 JSON 文件指定了哪些菜单项是为我们的软件包而建的。让我们看看menus/sourcefetch.json："context-menu": {
  "atom-text-editor": [
    {
      "label": "Toggle sourcefetch",
      "command": "sourcefetch:toggle"
    }
  ]
},这个 context-menu 对象可以让我们定义右击菜单的一些新条目。每一个条目都是通过一个显示在菜单的label 属性和一个点击后执行的命令的 command 属性来定义的。"context-menu": {
  "atom-text-editor": [
    {
      "label": "Fetch code",
      "command": "sourcefetch:fetch"
    }
  ]
},同一个文件中的这个 menu 对象用来定义插件的自定义应用菜单。我们如下重命名它的条目："menu": [
  {
    "label": "Packages",
    "submenu": [
      {
        "label": "sourcefetch",
        "submenu": [
          {
            "label": "Fetch code",
            "command": "sourcefetch:fetch"
          }
        ]
      }
    ]
  }
]
键盘快捷键
命令还可以通过键盘快捷键来触发。快捷键通过 keymaps 目录的 JSON 文件来定义：{
  "atom-workspace": {
    "ctrl-alt-o": "sourcefetch:toggle"
  }
}以上代码可以让用户通过 Ctrl+Alt+O（Windows/Linux） 或 Cmd+Alt+O（MacOS） 来触发 toggle 命令。
重命名引用的命令为 fetch："ctrl-alt-o": "sourcefetch:fetch"通过执行 Window: Reload 命令来重启 Atom。你应该会看到 Atom 的右击菜单更新了，并且逆转文本的功能应该还可以像之前一样使用。
在 sourcefetch 教程仓库 查看这一步所有的代码更改。
使用 NodeJS 模块
现在我们已经完成了第一次代码更改并且了解了 Atom 软件包的结构，让我们介绍一下 Node 包管理器（npm） 中的第一个依赖项模块。我们将使用 request 模块发起 HTTP 请求来下载网站的 HTML 文件。稍后将会用到这个功能来扒 StackOverflow 的页面。
安装依赖
打开你的命令行工具，切换到你的软件包的根目录并运行：npm install --save request@2.73.0
apm install这两条命令将 request 模块添加到我们软件包的依赖列表并将模块安装到 node_modules 目录。你应该会在package.json 看到一个新条目。@ 符号的作用是让 npm 安装我们这篇教程需要用到的特定版本的模块。运行 apm install 是为了让 Atom 知道使用我们新安装的模块。"dependencies": {
  "request": "^2.73.0"
}
下载 HTML 并将记录打印在开发者控制台
通过在 lib/sourcefetch.js 的顶部添加一条引用语句引入 request 模块到我们的主文件：import { CompositeDisposable } from 'atom'
import request from 'request'现在，在 fetch 函数下面添加一个新函数 download 作为模块的导出项：export default {  
  /* subscriptions, activate(), deactivate() */
  fetch() {
    ...
  },
  download(url) {
    request(url, (error, response, body) =&gt; {
      if (!error &amp;&amp; response.statusCode == 200) {
        console.log(body)
      }
    })
  }
}这个函数用 request 模块来下载一个页面的内容并将记录输出到控制台。当 HTTP 请求完成之后，我们的回调函数会将响应体作为参数来被调用。
最后一步是更新 fetch 函数以调用 download 函数：fetch() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection)
  }
},fetch 函数现在的功能是将 selection 当作一个 URL 传递给 download 函数，而不再是逆转选中的文本了。让我们来看看这次的更改：

通过执行 Window: Reload 命令来重新加载 Atom。
打开开发者工具。为此，导航到菜单中的 View &gt; Developer &gt; Toggle Developer Tools。
新建一个文件，导航到 File &gt; New。
输入一个 URL 并选中它，例如：http://www.atom.io。
用上述的任意一种方法执行我们软件包的命令：


开发者工具让 Atom 软件包的调试更轻松。每个 console.log 语句都可以将信息打印到交互控制台，你还可以使用 Elements 选项卡来浏览整个应用的可视化结构——即 HTML 的文本对象模型（DOM）。
在 sourcefetch 教程仓库 查看这一步所有的代码更改。
用 Promises 来将下载好的 HTML 插入到编辑器中
理想情况下，我们希望 download 函数可以将 HTML 作为一个字符串来返回，而不仅仅是将页面的内容打印到控制台。然而，返回文本内容是无法实现的，因为我们要在回调函数里面访问内容而不是在 download 函数那里。
我们会通过返回一个 Promise 来解决这个问题，而不再是返回一个值。让我们改动 download 函数来返回一个 Promise：download(url) {
  return new Promise((resolve, reject) =&gt; {
    request(url, (error, response, body) =&gt; {
      if (!error &amp;&amp; response.statusCode == 200) {
        resolve(body)
      } else {
        reject({
          reason: 'Unable to download page'
        })
      }
    })
  })
}Promises 允许我们通过将异步逻辑封装在一个提供两个回调方法的函数里来返回获得的值（resolve 用来处理请求成功的返回值，reject 用来向使用者报错）。如果请求返回了错误我们就调用 reject，否则就用resolve 来处理 HTML。
让我们更改 fetch 函数来使用 download 返回的 Promise：fetch() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection).then((html) =&gt; {
      editor.insertText(html)
    }).catch((error) =&gt; {
      atom.notifications.addWarning(error.reason)
    })
  }
},在我们新版的 fetch 函数里，我们通过在 download 返回的 Promise 调用 then 方法来对 HTML 进行操作。这会将 HTML 插入到编辑器中。我们同样会通过调用 catch 方法来接收并处理所有的错误。我们通过用Atom Notification API 来显示警告的形式来处理错误。
看看发生了什么变化。重新加载 Atom 并在一个选中的 URL 上执行软件包命令：

如果这个 URL 是无效的，一个警告通知将会弹出来：

在 sourcefetch 教程仓库 查看这一步所有的代码更改。
编写一个爬虫来提取 StackOverflow 页面的代码片段
下一步涉及用我们前面扒到的 StackOverflow 的页面的 HTML 来提取代码片段。我们尤其关注那些来自采纳答案（提问者选择的一个正确答案）的代码。我们可以在假设这类答案都是相关且正确的前提下大大简化我们这个软件包的实现。
使用 jQuery 和 Chrome 开发者工具来构建查询
这一部分假设你使用的是 Chrome 浏览器。你接下来可以使用其它浏览器，但是提示可能会不一样。
让我们先看看一张典型的包含采纳答案和代码片段的 StackOverflow 页面。我们将会使用 Chrome 开发者工具来浏览 HTML：

打开 Chrome 并跳到任意一个带有采纳答案和代码的 StackOverflow 页面，比如像这个用 Python 写的 hello world 的例子或者这个关于 用 C 来读取文本内容的问题。
滚动窗口到采纳答案的位置并选中一部分代码。
右击选中文本并选择 检查。
使用元素侦察器来检查代码片段在 HTML 中的位置。

注意文本结构应该是这样的：&lt;div class="accepted-answer"&gt;
  ...
    ...
      &lt;pre&gt;
        &lt;code&gt;
          ...snippet elements...
        &lt;/code&gt;
      &lt;/pre&gt;
    ...
  ...
&lt;/div&gt;

采纳的答案通过一个 class 为 accepted-answer 的 div 来表示
代码块位于 pre 元素的内部
呈现代码片段的元素就是里面那一对 code 标签


现在让我们写一些 jQuery 代码来提取代码片段：

在开发者工具那里点击 Console 选项卡来访问 Javascript 控制台。
在控制台中输入 $('div.accepted-answer pre code').text() 并按下回车键。

你应该会看到控制台中打印出采纳答案的代码片段。我们刚刚运行的代码使用了一个 jQuery 提供的特别的 $函数。$ 接收要选择的查询字符串并返回网站中的某些 HTML 元素。让我们通过思考几个查询案例看看这段代码的工作原理：$('div.accepted-answer')
&gt; [&lt;div id="answer-1077349" class="answer accepted-answer" ... &gt;&lt;/div&gt;]上面的查询会匹配所有 class 为 accepted-answer 的 &lt;div&gt; 元素，在我们的案例中只有一个 div。$('div.accepted-answer pre code')
&gt; [&lt;code&gt;...&lt;/code&gt;]在前面的基础上改造了一下，这个查询会匹配所有在之前匹配的 &lt;div&gt; 内部的 &lt;pre&gt; 元素内部的 &lt;code&gt;元素。$('div.accepted-answer pre code').text()
&gt; "print("Hello World!")"text 函数提取并连接原本将由上一个查询返回的元素列表中的所有文本。这也从代码中去除了用来使语法高亮的元素。
介绍 Cheerio
我们的下一步涉及使用我们创建好的查询结合 Cheerio（一个服务器端实现的 jQuery）来实现扒页面的功能。
安装 Cheerio
打开你的命令行工具，切换到你的软件包的根目录并执行：npm install --save cheerio@0.20.0
apm install
实现扒页面的功能
在 lib/sourcefetch.js 为 cheerio 添加一条引用语句：import { CompositeDisposable } from 'atom'
import request from 'request'
import cheerio from 'cheerio'现在创建一个新函数 scrape，它用来提取 StackOverflow HTML 里面的代码片段：fetch() {
  ...
},
scrape(html) {
  $ = cheerio.load(html)
  return $('div.accepted-answer pre code').text()
},
download(url) {
  ...
}最后，让我们更改 fetch 函数以传递下载好的 HTML 给 scrape 而不是将其插入到编辑器：fetch() {
  let editor
  let self = this
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection).then((html) =&gt; {
      let answer = self.scrape(html)
      if (answer === '') {
        atom.notifications.addWarning('No answer found :(')
      } else {
        editor.insertText(answer)
      }
    }).catch((error) =&gt; {
      console.log(error)
      atom.notifications.addWarning(error.reason)
    })
  }
},我们扒取页面的功能仅仅用两行代码就实现了，因为 cheerio 已经替我们做好了所有的工作！我们通过调用load 方法加载 HTML 字符串来创建一个 $ 函数，然后用这个函数来执行 jQuery 语句并返回结果。你可以在官方 开发者文档 查看完整的 Cheerio API。
测试更新后的软件包
重新加载 Atom 并在一个选中的 StackOverflow URL 上运行 soucefetch:fetch 以查看到目前为止的进度。
如果我们在一个有采纳答案的页面上运行这条命令，代码片段将会被插入到编辑器中：

如果我们在一个没有采纳答案的页面上运行这条命令，将会弹出一个警告通知：

我们最新的 fetch 函数给我们提供了一个 StackOverflow 页面的代码片段而不再是整个 HTML 内容。要注意我们更新的 fetch 函数会检查有没有答案并显示通知以提醒用户。
在 sourcefetch 教程仓库 查看这一步所有的代码更改。
实现用来查找相关的 StackOverflow URL 的谷歌搜索功能
现在我们已经将 StackOverflow 的 URL 转化为代码片段了，让我们来实现最后一个函数——search，它应该要返回一个相关的 URL 并附加一些像“hello world”或者“快速排序”这样的描述。我们会通过一个非官方的google npm 模块来使用谷歌搜索功能，这样可以让我们以编程的方式来搜索。
安装这个 Google npm 模块
通过在软件包的根目录打开命令行工具并执行命令来安装 google 模块：npm install --save google@2.0.0
apm install
引入并配置模块
在 lib/sourcefetch.js 的顶部为 google 模块添加一条引用语句：import google from "google"我们将配置一下 google 以限制搜索期间返回的结果数。将下面这行代码添加到引用语句下面以限制搜索返回最热门的那个结果。google.resultsPerPage = 1
实现 search 函数
接下来让我们来实现我们的 search 函数：fetch() {
  ...
},
search(query, language) {
  return new Promise((resolve, reject) =&gt; {
    let searchString = `${query} in ${language} site:stackoverflow.com`
    google(searchString, (err, res) =&gt; {
      if (err) {
        reject({
          reason: 'A search error has occured :('
        })
      } else if (res.links.length === 0) {
        reject({
          reason: 'No results found :('
        })
      } else {
        resolve(res.links[0].href)
      }
    })
  })
},
scrape() {
  ...
}以上代码通过谷歌来搜索一个和指定的关键词以及编程语言相关的 StackOverflow 页面，并返回一个最热门的 URL。让我们看看这是怎样来实现的：let searchString = `${query} in ${language} site:stackoverflow.com`我们使用用户输入的查询和当前所选的语言来构造搜索字符串。比方说，当用户在写 Python 的时候输入“hello world”，查询语句就会变成 hello world in python site:stackoverflow.com。字符串的最后一部分是谷歌搜索提供的一个过滤器，它让我们可以将搜索结果的来源限制为 StackOverflow。google(searchString, (err, res) =&gt; {
  if (err) {
    reject({
      reason: 'A search error has occured :('
    })
  } else if (res.links.length === 0) {
    reject({
      reason: 'No results found :('
    })
  } else {
    resolve(res.links[0].href)
  }
})我们将 google 方法放在一个 Promise 里面，这样我们可以异步地返回我们的 URL。我们会传递由 google返回的所有错误并且会在没有可用的搜索结果的时候返回一个错误。否则我们将通过 resolve 来解析最热门结果的 URL。
更新 fetch 来使用 search
我们的最后一步是更新 fetch 函数来使用 search 函数：fetch() {
  let editor
  let self = this
  if (editor = atom.workspace.getActiveTextEditor()) {
    let query = editor.getSelectedText()
    let language = editor.getGrammar().name
    self.search(query, language).then((url) =&gt; {
      atom.notifications.addSuccess('Found google results!')
      return self.download(url)
    }).then((html) =&gt; {
      let answer = self.scrape(html)
      if (answer === '') {
        atom.notifications.addWarning('No answer found :(')
      } else {
        atom.notifications.addSuccess('Found snippet!')
        editor.insertText(answer)
      }
    }).catch((error) =&gt; {
      atom.notifications.addWarning(error.reason)
    })
  }
}让我们看看发生了什么变化：

我们选中的文本现在变成了用户输入的 query
我们使用 TextEditor API 来获取当前编辑器选项卡使用的 language
我们调用 search 方法来获取一个 URL，然后通过在得到的 Promise 上调用 then 方法来访问这个 URL

我们不在 download 返回的 Promise 上调用 then 方法，而是在前面 search 方法本身链式调用的另一个then 方法返回的 Promise 上面接着调用 then 方法。这样可以帮助我们避免回调地狱
在 sourcefetch 教程仓库 查看这一步所有的代码更改。
测试最终的插件
大功告成了！重新加载 Atom，对一个“问题描述”运行软件包的命令来看看我们最终的插件是否工作，不要忘了在编辑器右下角选择一种语言。

下一步
现在你知道怎么去 “hack” Atom 的基本原理了，通过 分叉 sourcefetch 这个仓库并添加你的特性 来随心所欲地实践你所学到的知识。
制作你的第一个 Atom 文本编辑器插件，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>53</docid>
    <url>http://blog.jobbole.com/106910/</url>
    <title>QA，从 1.0 到 4.0</title>
    <content>迄今为止，敏捷开发方法在各个公司都有了长足的发展，曾经的测试人员慢慢的在向QA职能过渡，但依然很多人不了解QA和测试的区别是什么。
敏捷实践不断地演化过程，使项目中各个角色不断弱化，同时，对每个成员的要求也越来越高。“全功能团队”的提出，不单单是对开发的要求，对QA来说，想要在快速变革中具备竞争力，就现在所具备的技能来说，还是远远不够的。
简单聊聊我所经历的“QA发展史”

(图片来自ThoughtWorks UX设计师 高媛媛)
QA 1.0 —— 机械化流水线作业
在我实习的那年，软件领域还很少提及QA，伴随着瀑布模型的兴起、软件工程规模的不断扩大以及市场对软件质量要求的提高，催生出了“测试工程师”这样一个角色。那时他们的职能很单一，每天的工作就是在各种测试环境中按照详细设计的文档，编写测试用例，并逐条测试，检查功能完整性，发现软件中可能出现的功能缺陷，并进行追踪。
这个时期是软件测试的原始时期，对测试人员的技能要求不高，只要对文档理解透彻，做事细心，是很容易胜任的。此时的产出和交付物可度量，虽然如此，测试工程师只是执行者，能力和价值都无法最大化，却被每天重复的工作所累。
QA 2.0 —— 过程化带来不同的工作内容和价值体现
我毕业的时候，开始接触敏捷方法，团队规模从百人变成了仅有十人左右，信息平等取代了逐级传递，分散的信息源（ 客户的每一封邮件和每一句对话都可能是我们将要做的功能 ）取代了几十甚至百页的文档，测试不再仅是提出软件缺陷和编写、执行测试用例，而是成为了团队的数据库和字典。

当用户提出一个功能的时候，测试人员可以快速的进行需求分析，回顾并确定是否与此前的功能有冲突。当开发人员对某一块业务不了解的时候，测试人员也可以组织会议进行阐明。由于对业务和客户的深入了解，测试人员可以为客户提出建设性意见和功能，有时也会是做出决策的人。
高效、频繁的沟通，大大提升了QA的软技能。此时的测试人员已经过程化，对软件质量的理解，从“发现缺陷”提升到“对软件开发过程的质量控制和风险预估”，我们定义这样的测试工程师为QA。
QA 3.0 —— 自动化技能提高生产力
随着工程实践的日益成熟，QA的角色和工作日益复杂，这使得他们在大量重复、繁杂的工作与更有意义的角色之间频繁切换，这对软件质量也产生了一定影响。

QA从开始的手工测试、探索性测试等手段，逐渐发展成为可以利用工具和程序对测试进行快速的回归，对软件性能进行有效监控，无论是前端还是后端、web应用还是移动平台。这使得自己从繁杂的重复性工作中解脱出来，去做更有意义的事情。他们通过项目的积累以及团队成员的帮助，对测试技术有了一定的认识。
QA 4.0 —— 角色向多技能、服务化转型
记得几年前，前公司领导对我说，“不管开发换了什么技术栈，你做的自动化框架都可以继续使用，对你来说没有任何影响。”当时我也赞同，认为框架已经足够好，可以适用于任何场景和业务。
从某个角度来说确实是这样， 测试相对于开发技术的指数级发展，平稳的太多。不论是在互联网还是移动互联网时代，缓慢的发展速度给了我们一种太平盛世的错觉，似乎我们掌握的技术足够坐吃几年。
来到ThoughtWorks之后，我发现了类似的事情，不论是在交付还是咨询的过程中，会有意无意中推一些我们认为的最佳实践，当遭到客户质疑和challenge的时候，我们似乎很沮丧。
在北京出差的日子，有幸做了一次咨询，虽然只有几天，让我学到一件事，我们认为的最佳实践和方法，并不完全适应于所有场合，尤其是在我们这样的咨询公司，对客户实施怎样的方案，取决于客户的领域、产品/项目特性、用户群、技术水平、政治文化、技术栈以及目标和期望等等。

如果对于“最佳实践”过于坚持，也会影响客户关系和咨询效果。之后咨询同事讲的几个故事也似乎让我认识到，虽然我们对现在的工作和技能足够的熟练，但依然不够。
我们似乎还需要具备以下的能力：
1.尝试用不同的方法写“茴”
经验丰富的QA对于测试技术中的关键点都烂熟于心， 除了我们正在使用的方案和技术，尝试用不同的语言、框架去实现关键点和难点。这样的好处在于，我们可以通过深入的学习和使用，对流行方法、过程和框架进行比较，了解各自的优势和劣势，不但可以增强自身的技能，当面对不同客户的时候，也可以给出客观的分析，为客户提供精准服务，同时如果可以对客户现有的技术和方案、流程和方法提供有价值的意见，也可以提高在客户现场的生存率，轻松俘获客户。
2.If you cannot test it, dev it.
软件过程中，QA可以在需求分析和定义阶段介入，为项目提供不可估量的价值，但另一方面，QA技能实践（此处指Tech）是一个相对受限的领域，我们很难绕过未实现的代码和工程去做更多的事情。
你可能会说，“没有做过mobile的项目，如何去学习移动端的测试技能？”如果恰好你对行业的发展具有前瞻性和敏感度，例如你可能认为IoT和VR是一个趋势，你却没有机会去这样的项目中做QA。
那么我们是不是可以像开发一样，提升自己的学习能力和适应力，保持对技术的敏感度和热忱，了解不同技术领域，对该领域的开发、测试、构建和集成部署都有一定的了解？所以，如果你想比其他人走的快那么一点，go dev!

3.真正的全功能
QA的领域虽然相对受限，但幸运的是角色相对不受限。在日常的开发过程和项目积累过程中，不但能对业务有深刻的理解、对用户行为有独到的见解，而且对技术也有一定的认识。
在需求分析过程中，QA总是可以从技术和业务结合的角度扮演好一个BA的角色，成为一个优秀的PM，甚至我们可以在客户提出一些需求的时候尝试着从一个UX的角度去设计原型，如果具备前端的能力，也可以自己去Dev、UI，不断拓展自己的技能领域，使自己成为真正的全功能。
总结
真正的全功能，并不是单纯意义上让QA去做Dev，而是最大程度弱化角色的概念，逐步强调和培养技能多元化。如何把对需求的理解能力强化为业务分析能力，把质量控制能力强化为项目管理能力。强化自身的优势，跳出自己的舒适区，使自己能够轻松胜任。这样我们才不会在看到去QA和QA消亡之类的观点后，无所适从。
QA，从 1.0 到 4.0，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>54</docid>
    <url>http://blog.jobbole.com/106912/</url>
    <title>C++ 虚函数和虚继承浅析</title>
    <content>本文针对C++里的虚函数，虚继承表现和原理进行一些简单分析，有不对的地方请指出。下面都是以VC2008编译器对这两种机制内部实现为例。

虚函数
　　一下是百度百科对于虚函数的解释：

定义：在某基类中声明为 virtual 并在一个或多个派生类中被重新定 义的成员函数[1]
语法：virtual 函数返回类型 函数名（参数表） { 函数体 }
用途：实现多态性，通过指向派生类的基类指针，访问派生类中同名覆盖成员函数

函数声明和定义和普通的类成员函数一样，只是在返回值之前加入了关键字“virtual”声明为虚函数。而虚函数是实现多态的重要手段，意思是只有对虚函数的调用才能动态决定调用哪一个函数，这是相对于普通成员函数而言的，普通的成员函数在编译阶段就能确定调用哪一个函数。举个栗子：

#include &lt;stdio.h&gt;

class A {
public:
    void fn() { printf("fn in A\n"); }
    virtual void v_fn() { printf("virtual fn in A\n"); }
};

class B : public A {
public:
    void fn() { printf("fn in B\n"); }
    virtual void v_fn() { printf("virtual fn in B\n"); }
};

int main() {
    A *a = new B();
    a-&gt;fn();
    a-&gt;v_fn();
    return 0;
}

基类A有两个成员函数fn和v_fn，派生类B继承自基类A，同样实现了两个函数，然后在main函数中用A的指针指向B的实例（向上转型，也是实现多态的必要手段），然后分别调用fn和v_fn函数。结果是“fn in A&#8221;和&#8221;virtual fn in B&#8221;。
这是因为fn是普通成员函数，它是通过类A的指针调用的，所以在编译的时候就确定了调用A的fn函数。而v_fn是虚函数，编译时不能确定，而是在运行时再通过一些机制来调用指针所指向的实例（B的实例）中的v_fn函数。假如派生类B中没有实现（完全一样，不是重载）v_fn这个函数，那么依然会调用基类类A中的v_fn；如果它实现了，就可以说派生类B覆盖了基类A中的v_fn这个虚函数。这就是虚函数的表现和使用，只有通过虚函数，才能实现面向对象语言中的多态性。
以上只是虚函数的表现和用途，下面来探讨它的实现机制。在此之前，先来看一个问题，还是以上的代码，基类A的大小为多少，也就是“printf(&#8220;%dn&#8221;, sizeof(A));&#8221;的输出会是多少呢？A中一个成员变量都没有，有人可能会说是0。额，0是绝对错误的，因为在C++中，即时是空类，它的大小也为1，这是另外的话题，不在本文讨论。当然1也是不对的，实际结果是4（32位系统），4刚好是一个int，一个指针（32位）的大小，派生类B的大小同样为4。这四个字节和实现多态，虚函数的机制有着很重要的关系。
其实用VC2008调试上面代码的时候，就会发现指针a所指向的实力中有一个成员常量（const），它的名字叫做vftable，全称大概叫做virtual function table（虚函数表）。它实际指向了一个数组，数组里面保存的是一系列函数指针，而上面的程序中，这个表只有一项，它就是派生类B中的v_fn函数入口地址。假如我们用一个A的指针指向一个A的实例呢？它同样有一个vftable，而它指向的表中也只有一项，这项保存的基类的v_fn函数入口地址。这用代码表示，就类似于下面这样：

void* vftable_of_A[] = {
    A::v_fn,
    ...
};

class A {
    const void* vftable = vftable_of_A;
    virtual void v_fn() {}
};

void* vftable_of_B[] = {
    B::v_fn,
    ...
};

class B {
    const void *vftable = vftable_of_B;
    vritual void v_fn() {}
};

上面vftable的类型之所以用void*表示，实际上一个类中所有虚函数的地址都被放到这个表中，不同虚函数对应的函数指针类型不尽相同，所以这个表用C++的类型不好表述，但是在机器级里都是入口地址，即一个32位的数字（32位系统），等到调用时，因为编译器预先知道了函数的参数类型，返回值等，可以自动做好处理。
这样我们就能更好的理解虚函数和多态了。第一个代码中，a指针虽然是A*类型的，但是它却调用了B中的v_fn，因为不管是A类，还是A的基类，都会有一个变量vftable，它指向的虚函数表中保存了正确的v_fn入口。所以a-&gt;v_fn()实际做的工作就是从a指向的实例中取出vftable的值，然后找到虚函数表，再从表中去的v_fn的入口，进行调用。不管a是指向A的实例，还是指向B的实例，a-&gt;fn()所做的步骤都是上面说的一样，只是A的实例和B的实例有着不同的虚函数表，虚函数表里也保存着可能不同的虚函数入口，所以最终将进入不同的函数调用中。通过表来达到不用判断类型，亦可实现多态的作用。还有一点指的提醒的是，因为虚函数表是一个常量表，在编译时，编译器会自动生成，并且不会改变，所以如果有多个B类的实例，每个实例中都会有一个vftable指针，但是它们指向的是同一个虚函数表。
上面一段中说到了，A和B的实例有着不同的虚函数表，但是虚函数表中只是可能保存着不同的v_fn，那是因为C++允许派生类不覆盖基类中的虚函数，意思就是假如派生类B中没有实现v_fn这个函数（不是重载），那么B的实例的虚函数表会保存着基类A中v_fn的入口地址。也就是说B类不实现v_fn函数，但是它同样提供了这个接口，实际上是调用基类A中的v_fn。假如某个类只是一个抽象类，抽象出一些列接口，但是又不能实现这些接口，而要有派生类来实现，那么就可以把这些接口声明为纯虚函数，包含有纯虚函数的类称为抽象类。纯虚函数是一类特殊的虚函数，它的声明方式如下：
class A {
public:
virtual 返回值 函数名（参数表）= 0；
};
在虚函数声明方式后加一个“=0”，并且不提供实现。抽象类不允许实例化（这样做编译器会报错，因为有成员函数没有实现，编译器不知道怎么调用）。纯虚函数的实现机制和虚函数类似，只是要求派生类类必须自己实现一个（也可以不实现，但是派生类也会是个抽象类，不能实例化）。
顺带提一下，java中的每一个成员函数都可以以理解为C++中的virtual函数，不用显式声明都可以实现重载，多态。而java的接口类似于C++中的抽象类，需要实现里面的接口。
虚继承
C++支持多重继承，这和现实生活很类似，任何一个物体都不可能单一的属于某一个类型。就像马，第一想到的就是它派生自动物这个基类，但是它在某系地方可不可以说也派生自交通工具这一个基类呢？所以C++的多重继承很有用，但是又引入了一个问题（专业术语叫做菱形继承？）。动物和交通工具都是从最根本的基类——“事物”继承而来，事物包含了两个最基本的属性，体积和质量。那么动物和交通工具都保存了基类成员变量——体积和质量的副本。而马有继承了这两个类，那么马就有两份体积和质量，这是不合理的，编译器无法确定使用哪一个，所以就会报错。JAVA中不存在这样的问题，因为JAVA不允许多重继承，它只可能实现多个接口，而接口里面只包含一些函数声明不包含成员变量，所以也不存在这样的问题。
这个问题用具体代码表述如下所示：

class A {
public:
    int a;
};

class B : public A {
};

class C : public A {
};

class D : public B, public C {
};

int main() {
    D d;
    d.a = 1;
    return 0;
}

这个代码会报错，因为d中保存了两份A的副本，即有两个成员变量a，一般不会报错，但是一旦对D中的a使用，就会报一个“对a的访问不明确”。虚继承就可以解决这个问题。在探讨虚函数之前，先来一个sizeof的问题。

#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
};


int main() {
    printf("%d\n", sizeof(B));
    return 0;
}

B的大小是？首先回答0的是绝对错的，理由我之前都说了。1也是错的，不解释。4也是错的，如果B不是虚继承自A的，那么4就是对的。正确答案是8，B虚继承A了之后，比预想中的多了4个字节，这是怎么回事呢？这个通过调试是看不出来的，因为看不到类似于vftable的成员变量（实际上编译器生成了一个类似的东西，但是调试时看不到，但是在观察反汇编的时候，可以见到vbtable的字样，应该是virtual base table的意思）。
虚继承的提出就是为了解决多重继承时，可能会保存两份副本的问题，也就是说用了虚继承就只保留了一份副本，但是这个副本是被多重继承的基类所共享的，该怎么实现这个机制呢？编译器会在派生类B的实例中保存一个A的实例，然后在B中加入一个变量，这个变量是A的实例在实际B实例中的偏移量，实际上B中并不直接保存offset的值，而是保存的一个指针，这个指针指向一个表vbtable，vbtable表中保存着所有虚继承的基类在实例中的offset值，多个B的实例共享这个表，每个实例有个单独的指针指向这个表，这样就很好理解为什么多了4个字节了。用代码表示就像下面这样。

class A {
public:
    ...
};

int vbtable_of_B[] = {
　　offset(B::_a),
    ...
};


class B ：virtual public A{
private:
    const int* vbtable = vbtable_of_B;
    A _a;
};

每一个A的虚派生类，都会有自己的vbtable表，这个派生类的所有实例共享这个表，然后每个实例各自保存了一个指向vbtable表的指针。假如还有一个类C虚继承了A，那么编译器就会为它自动生成一个vbtable_of_C的表，然后C的实例都会有一个指向这个vbtable表的指针。
假如有多级的虚继承会发生什么情况，就像下面这段代码一样：

#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
public:
　　int b;
};

class C : virtual public B {
};


int main() {
    printf("%d\n", sizeof(C));
    return 0; 
}

程序运行的结果是16，按照之前的理论，大概会这么想。基类A里有1个变量，4个字节。B类虚继承了A，所以它有一个A的副本和一个vbtable，还有自己的一个变量，那就是12字节。然后C类又虚继承了B类，那么它有一个B的副本，一个vbtable，16字节。但实际上通过调试和反汇编发现，C中保存分别保存了A和B的副本（不包括B类的vbtable），8字节。然后有一个vbtable指针，4字节，表里面包含了A副本和B副本的偏移量。最后还有一个无用的4字节（？），一共16字节。不仅是这样，每经过一层的虚继承，便会多出4字节。这个多出来的四字节在反汇编中没发现实际用途，所以这个有待探讨，不管是编译器不够智能，还是有待其它作用，虚继承和多重继承都应该谨慎使用。
还是以上面的例子，假如C类是直接继承B类，而不是使用虚继承，那么C类的大小为12字节。它里面是直接保存了A和B的副本（不包含B的vbtable），然后还有一个自己的vbtable指针，所以一共12字节，没有了上一段所说的最后的4个字节。
但是如果想下面一种继承，会是什么情况？

#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
};

class C : virtual public A {
};

class D : public B, public C{
};


int main() {
    printf("%d\n", sizeof(D));
    return 0; 
}

D从B，C类派生出来，而B和C又同时虚继承了A。输出的结构是12，实际调试反汇编的时候发现，D中继承了B和C的vbtable，这就是8字节，而同时还保存了一个A的副本，4字节，总共12字节。它和上面的多重虚继承例子里的12字节是不一样的。之前一个例子中只有一个vbtable，一个A的实例，末尾还有一个未知的4字节。而这个例子中是有两个仅挨着的vbtable（都有效）和一个A的实例。

C++ 虚函数和虚继承浅析，首发于文章 - 伯乐在线。</content>
</doc><doc>
    <docid>55</docid>
    <url>http://www.smzdm.com/p/6544825/</url>
    <title>SALONPAS 撒隆巴斯 镇痛贴 140枚*2件 153.8元包邮包税，2件起购</title>
    <content>好评镇痛贴，近期好价~宝贝格子目前售价76.9元，2件起购，包邮包税，近期好价格，需要的可以入手了。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>56</docid>
    <url>http://www.smzdm.com/p/6544775/</url>
    <title>双11预售：《CLAMP 魔卡少女樱》库洛牌完全复刻版套装 官方版 337元包邮（40元定金，11.11付尾款需用券）</title>
    <content>隐藏着黑暗力量的钥匙啊，在我面前显示你真正的力量，与你定下契约的小樱命令你，封印解除~天猫国际目前开启双11预售活动，支付定金40元，可在11月11日当天享受定金膨胀优惠，再叠加满300减20优惠券，实付337元包邮，朋友们，是时候证明自己是一枚合格的樱厨了~本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>57</docid>
    <url>http://www.smzdm.com/p/6544604/</url>
    <title>DECATHLON 迪卡侬 DOMYOS WAW 女士运动上衣  29.9元</title>
    <content>天鹅绒，运动自如~天猫迪卡侬旗舰店目前上衣售价29.9元，原价129元，尺码十分齐全，实属入手好价。穿着舒适，有需要的可以下手了~本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>58</docid>
    <url>http://www.smzdm.com/p/6544818/</url>
    <title>凑单品：Cadet 宠物零食 整只鸡胸肉170g  8.9元</title>
    <content>100%纯肉质，适口性佳~狗民网商城目前售价8.9元，来到之前推荐的好价格，需要的可以凑单入手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>59</docid>
    <url>http://www.smzdm.com/p/6544729/</url>
    <title>双11预售：Ronshen 容声 BCD-639WD11HYA 639升 对开门冰箱  2849元包邮（预付100元定金）</title>
    <content>支持App远程操控，639升大容量对开门冰箱历史新低。天猫容声官方旗舰店目前开启双11预售，预售价3299元，现支付100元定金可抵扣150元并赠送400元专用优惠券，在11月11日1点支付尾款后，可做到实付2849元包邮到手的好价，刷新推荐历史价格新低，已是目前为止全网电商渠道最优报价，有需要的朋友可以关注一下。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>60</docid>
    <url>http://www.smzdm.com/p/6544724/</url>
    <title>双11预售：illy 意利 意式浓缩深度烘焙咖啡粉 250g*2罐 94元（定金10元，11.11付尾款）</title>
    <content>深度烘焙，香味浓郁~天猫国际海外直营当前售价114元，可用定金15元，抵30，11.11付尾款。虽然有税，但可领一张免税券，还可在天猫国际首页进口商品5元无门槛优惠券，下单实付94元包邮，折47元/瓶，入手好价。喜欢的可以入手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>61</docid>
    <url>http://www.smzdm.com/p/6544431/</url>
    <title>双11预售：Danisa 丹麦皇冠 风味曲奇饼干 908g 56元含税包邮（需10元定金，11.11付尾款）</title>
    <content>天猫国际attent海外旗舰店目前售价61元，可支付10元定金抵15元，11月11日支付46元尾款，实际到手56元含税包邮，近期低价，喜欢这个口味的值友可以关注。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>62</docid>
    <url>http://www.smzdm.com/p/6544805/</url>
    <title>Tefal 特福 钛铸涂层红点设计不粘锅平底锅 D47419 28cm 196元 </title>
    <content>红点技术，控制油温~西集网目前售价196元，来到之前推荐的好价格，需要的可以入手了。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>63</docid>
    <url>http://www.smzdm.com/p/6543856/</url>
    <title>拼单好价，移动端：Pelikan 百利金 P480系列 钢笔 F尖 亮绿色*4件 287.16元包邮，合71.79元/件</title>
    <content>高口碑入门钢笔，多色可选，拼单好价。京东全球购移动端目前售价99元，购买4件参加满299减50活动，再叠加全球购满299-100券，实付287.16元包邮到手，每件折合低至71.79元。新低价。目前蓝色，红色和绿色均是好价。可根据颜色喜好拼单购入。喜欢的朋友不要错过。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>64</docid>
    <url>http://www.smzdm.com/p/6544766/</url>
    <title>WMF 厨房套装 压力锅快易锅6.5L+中华炒锅32cm+煎锅平底锅24cm 1599元包邮</title>
    <content>套锅历史低价，蒸焖炖汤均可~亚马逊中国目前售价1599元包邮，低于历史推荐好价。淘宝同款套装（不含炒锅铲）售价5000元以上。这次的价格优势较大，需要的值友可以关注一下。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>65</docid>
    <url>http://www.smzdm.com/p/6544370/</url>
    <title>双11预售：Puritan's Pride 普丽普莱 双倍氨糖软骨素 240粒*2瓶 169元+22.49元税费（需30元定金，需用券）</title>
    <content>双倍浓度，缓解关节疼痛~聚划算普丽普莱海外旗舰店目前售价219元，可付30元定金抵60元，11月11日支付尾款159元，再叠加20元优惠券，实付169元包邮，另需税费22.49元。折后含税每瓶95元左右，有需要的值友可以关注一下。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>66</docid>
    <url>http://www.smzdm.com/p/6543826/</url>
    <title>预售：WHALEY 微鲸 WTV55K1J 55英寸 4K平板电视 2499元包邮</title>
    <content>10bit面板，赠品丰富，55英寸4K预约好价。苏宁易购目前售价2699元，11月1日0点至1点下单立减200，实付2499元到手。持平历史最低价。前500名还可获得价格199元手环及一年微鲸会员。相比于天猫预售，不必支付定金就可以做到同价。55英寸4K不到2500就能入手还是比较合适的。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>67</docid>
    <url>http://www.smzdm.com/p/6544490/</url>
    <title>MEIZU 魅族 MX6 全网通手机 1609元包邮(1639-30)</title>
    <content>4GB+32GB，双色温闪光灯，近期好价。新蛋中国目前售价1639元，可以使用蛋券“sm60”做到1609元到手的价格，有兴趣的值友可以关注一下。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>68</docid>
    <url>http://www.smzdm.com/p/6544737/</url>
    <title>LANCOME 兰蔻 水份缘舒缓系列套装 2件套 599元包邮包税</title>
    <content>日霜+晚霜组合，清爽不油腻，入手好价~网易考拉海购目前售价599元，下单包邮包税。入手好价，有需要的值友可考虑下手~本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>69</docid>
    <url>http://www.smzdm.com/p/6544734/</url>
    <title>SUPOR 苏泊尔 YS24ED 好帮手不锈钢压力锅 24cm+美厨三层蒸锅 26CM 254元包邮（双重优惠后）</title>
    <content>双重安全阀门，导热均匀~1号店目前售价299元，参加满199减80活动，还可叠加使用满299减50优惠券，凑单售价85元的蒸锅，双重优惠后实付254元，折合近期好价格。更多商品可以到活动页面挑选，另外可以用券的页面在此。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>70</docid>
    <url>http://www.smzdm.com/p/6544606/</url>
    <title>凑单品：NUK Vario Cup多色带盖婴儿防漏 学饮杯 12个月以上 39元</title>
    <content>材质安全，宽口径，有防漏垫片，税前好价。京东全球购目前报价39元，持平之前推荐价格，算上税费也是好价，适合凑单带回，有需要的朋友可以入手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>71</docid>
    <url>http://www.smzdm.com/p/6544371/</url>
    <title>双11预售：Onitsuka Tiger 鬼塚虎 OKT037 中性款休闲T恤 135元（15元定金，11.11付尾款）</title>
    <content>嘘~萌不萌~天猫Onitsuka Tiger官方旗舰店双11预售价为145元，定金15元，双11可低付25元，最终实付135元。还有类似款也是好价。
                            
                                
                                
                                    Onitsuka Tiger 鬼塚虎 OKT044 休闲T恤
                       价格￥135天猫精选					
                                
                            
                        	本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>72</docid>
    <url>http://www.smzdm.com/p/6544615/</url>
    <title>tutuanna 300D 纯色加厚踩脚裤  79元</title>
    <content>入手好价，有需可入~ 天猫精选tutuanna旗舰店目前售价79元，不包邮，可凑单至129元包邮带回。需要注意的是只有一个尺码可选，适用于身高150~165cm的妹子，此外店内还有满159元减10元、满259元减20元等优惠券可领，有需要的值友可考虑下手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>73</docid>
    <url>http://www.smzdm.com/p/6544673/</url>
    <title>2016双11预售：Tong Tai 童泰 秋冬季 婴儿睡袋加厚款 79元包邮（10元定金，11.11付尾款）</title>
    <content>分腿睡袋，安全拉链，秋冬加厚款~天猫童泰旗舰店目前售价99元，10定金可抵30，下单实付79元，平日售价在150左右，还有一款黄色也是同价。有需要的家长可以关注。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>74</docid>
    <url>http://www.smzdm.com/p/6544593/</url>
    <title>双11预售：皇上皇 金福 五花腊肉 500g 51元包邮（用券）（定金10元，11.11付尾款）</title>
    <content>肥瘦均匀，微醺酒香，地道广式风味~天猫皇上皇旗舰店目前售价59元，可用10元抵15元，11.11付尾款，同时可在店铺首页领取3元无门槛优惠券，下单实付51元包邮，入手好价。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>75</docid>
    <url>http://www.smzdm.com/p/6544226/</url>
    <title>SIEMENS 西门子 SK23E800TI 嵌入式洗碗机 2580元包邮</title>
    <content>6套清洗容量，冷凝烘干，近期好价。国美在线目前特价至2580元包邮，再到近期好价，有需求的不要错过。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>76</docid>
    <url>http://www.smzdm.com/p/6544660/</url>
    <title>GUCCI 古驰 133483 3G200 双G提花图案羊毛围巾 ￥1299+￥154.58含税直邮（约￥1454）</title>
    <content>降低196元。多色可选，经典双G，柔软舒适~京东全球购目前售价1299元，多色可选，加上154.58元的税费，到手约1454元，比之前推荐的降低196元。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>77</docid>
    <url>http://www.smzdm.com/p/6544708/</url>
    <title>WMF 福腾宝 Perfect 压力锅 6.5 L 1059元包邮</title>
    <content>不锈钢中加入18%铬+10%镍，更防锈耐腐蚀~亚马逊中国目前售价1059元，持平之前推荐的秒杀价格，需要的可以看下。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>78</docid>
    <url>http://www.smzdm.com/p/6544699/</url>
    <title>凑单品：THERMOS 膳魔师 APA-800 保温杯清洁器 109元</title>
    <content>终于找到清洗保温杯的正确姿势了~西集网目前售价109元，来到之前推荐的好价格，需要的可以凑单入手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>79</docid>
    <url>http://www.smzdm.com/p/6543607/</url>
    <title>九点夜读：《红楼梦日历》、《牡丹亭日历》 日历之周——感悟古典文学之美</title>
    <content>每晚九点，每天两册，主题灵活，夜夜精彩。各位值友大家好，这里是九点夜读，我是当值小编夜读君。从本周一开始，夜读开启了为期五天的“日历之周”，我们将从市面纷繁的日历中按主题挑选一些特色产品推荐给大家，以供各位读者品鉴、收藏或者送礼。今晚我们的推荐的是两本大家耳熟能详，且颇有文艺风的日历,《红楼梦日历》《牡丹亭日历》献给热爱文学的朋友们。&nbsp;
                            
                                
                                
                                    《红楼梦日历2017》
                       价格￥77.7京东					
                                
                            
                        	&nbsp;封面赏析特色介绍这本日历是专为喜欢古典文学尤其是红楼梦爱好者制作的日历，是以曹雪芹《红楼梦》的生活美学为切入点，甄选了红楼梦中曾出现的二百余种植物为主题，它们均出自诗词、典故、俗语等中，以果实、块茎、纤维、树脂、种子、茎秆等制成品的形态出现在书中。日历按照以植物生长时令为主线进行设计，春天花卉，夏天草木，秋天果实，冬天松竹等耐寒植物。同时，延续了以往的设计风格，保留了三九、三伏天的起始日，阴历、阳历日期、节气、民俗提示，记事栏用以记录当下生活备忘，《红楼梦》当日大事提示等，同时选取了传世名画配图，并引用并引入原文标注，由红楼学者对种植物进行了诗意解读，是一份非常文艺清雅的日历。作者简介曹雪芹，名沾，字梦阮，号雪芹，又号芹溪。早年成在南京江宁织造府亲历了一段锦衣纨绔、富贵风流的生活，后因曹家亏空获罪而跟随家人迁回北京，后移居北京西郊，靠卖字画和朋友救济为生。因为家庭遭遇的变故和经历的大起大落而奋笔疾书，终于穷尽一生精力，数次删改撰写而完成了旷世巨著《红楼梦》，成为中华传统文学不朽的经典。书摘配图小编点评说不完的红楼梦，道不尽的谜。红楼之人，都被曹公赋予了各自的守护神，他们是花草树木，存在于天界人间，皆有灵性。翻开这本红楼梦日历，在时光荏苒中，我们每天不仅能够在生活的空隙中去品读红楼，也能大概识辨一些植物，通过这些植物，我们亦能从中收获些许知识，感受事物之美好。&nbsp;
                            
                                
                                
                                    《牡丹亭日历·2017》
                       价格￥77.7京东					
                                
                            
                        	封面赏析特色介绍日历以白先勇先生所创作的青春版《牡丹亭》剧照为日历配图，搭配原著的故事剧情和其中俏皮有趣的宾白以及婉转典丽的唱词为主体内容，其中穿插点缀了导演、演员和摄影师的手记，有关《牡丹亭》相关的昆曲知识，让读者在品读牡丹亭“生者可以死，死可以生”的爱情故事和至情至性之美的同时，进一步领略昆曲的美感与韵味。作者介绍汤显祖，字义仍，号海若、若士、清远道人，明代戏曲家和文学家。万历年间曾任礼部祠祭司主事等职，后因目睹官僚腐败而上书谏言被贬，后愤而辞官，潜心于戏剧及诗词创作，最终创作出《牡丹亭》《南柯记》和《邯郸记》《紫钗记》等戏剧，成为继关汉卿之后的又一位伟大的戏剧家。书摘配图小编点评情不知所起，一往而情深，生者可以死，死者可以生。作为昆曲中最为经典的曲目之一，在缱绻瑰丽的唱词中，杜丽娘对于爱情的勇敢追求和对自由的向往曾经拨动了多少少女的心弦？在每个人的青春岁月中又有多少人为此而甘愿付出灵魂之爱。即便岁月已逝，青春苍凉，甚至是昆曲也已没落成小众的爱好，但终归还会有一些人会念出“原来姹紫嫣红开遍，似这般都付与断井颓垣。良辰美景奈何天，赏心乐事谁家院？”的唱词来，这就足够了。往期推荐《亲子日历》、《高考日历》 日历之周——私人定制的实用之选《单向历》、《笺谱日历》 日历之周——365天的文艺之旅更多往期瞅我....（瞅啥瞅，快来订阅）如何订阅：九点夜读是什么值得买（SMZDM.COM）最新的图书专栏，以丰富值友视野，传播优质图书为己任，不以价格为主要判断依据。专栏每晚九点左右准时推出，以限定关键词为条件，每天甄选2册优质作品，题材及风格不限，唯二的判断标准就是有价值+好看。感兴趣的朋友只要在手机APP端打开本文，点击右上角订阅按钮，添加相关的“九点夜读”标签，然后回到首页的右上角“我的订阅”中进行推送设置，即可在第一时间收到我们每期的更新内容。夜读精彩，你我相伴。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>80</docid>
    <url>http://www.smzdm.com/p/6540563/</url>
    <title>Ventry 温特瑞 泰国天然乳胶欧罗枕/面包枕 429元包邮（需用券）</title>
    <content>专为爱睡高枕的你设计~西集网售价459元，使用本站满299立减30元的优惠券，实付429元包邮到手，使用积分还能做到更便宜。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>81</docid>
    <url>http://www.smzdm.com/p/6544192/</url>
    <title>27日6点开始，移动端：POVOS 奔腾 S1556 电水壶 1.5L 59元</title>
    <content>食品级304不锈钢、加厚双层材质，再到好价。京东移动端将于26日6点特价至59元，近期好价。近期有需求的朋友可以留意。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>82</docid>
    <url>http://www.smzdm.com/p/6544304/</url>
    <title>双11预售：Crocs 卡骆驰 中性 11001 沙滩洞洞鞋 184元（30元定金，11.11付尾款）</title>
    <content>经典款~天猫crocs户外旗舰店双11预售价199元，现在付定金30元，双11时可抵用45元，最终实付184元包邮，喜欢的可以考虑~本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>83</docid>
    <url>http://www.smzdm.com/p/6544671/</url>
    <title>Finish 亮碟 洗碗机机体清洁剂 250ml*10件 199元包邮（299-200）</title>
    <content>清除顽固污渍，保护被碗碟和洗碗机不受腐蚀~京东目前售价39.9元，参加满399减200活动，下单10件，满减后实付199元，折合19.9元/件，近期好价格，适合拼单入手。本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>84</docid>
    <url>http://www.smzdm.com/p/6544339/</url>
    <title>Jabra 捷波朗 Eclipse 智能通话蓝牙耳机 557元包邮</title>
    <content>价格实惠、功能强大。京东全球购自营售价498元&nbsp;Jabra 捷波朗 ECLIPSE 壹石 （需缴纳11.9%跨境电商综合税）共557元本文来自什么值得买网站（www.smzdm.com）。</content>
</doc><doc>
    <docid>85</docid>
    <url>http://songshuhui.net/archives/96601</url>
    <title>小朋友的涂鸦（三）：地图的魔术</title>
    <content>本文作者：方弦
前文回顾：
小朋友的涂鸦（一）：从8和9说起
小朋友的涂鸦（二）：球面覆盖
地图的魔术
我们先回到一开始的问题：对于某个正整数k，假设有两个互质的多项式P(x),Q(x)，其中P(x)的次数是3k，Q(x)的次数是2k。那么，多项式R(x)=P(x)^2-Q(x)^3的次数最小可以有多小？
我们现在用别雷函数、球面覆盖和二部地图的眼光来看这个问题。首先，我们来考虑分式f(x)=\frac{-Q(x)^3}{R(x)}。可以证明，如果f(x)除了0、1和∞以外还有别的分支点的话，我们就得不到最优解。所以，我们可以假设f(x)是别雷函数。
函数f(x)在0处的分支点就是Q(x)^3的根，也就是Q(x)的根（计算重数的话，一共有2k个），但每个根的重数要乘以3。同样的道理，它在∞处的分支点就是R(x)的根，再加上无穷远点x=\infty，因为R(x)的次数比Q(x)^3要小，所以当x趋向于无穷时，f(x)也会趋向于无穷。那么，它在1处的分支点又怎么样呢？这就是我们选取f(x)的目的：f(x)-1就等于\frac{-P(x)^2}{R(x)}，所以，f(x)在1处的分支点，就是P(x)的根（计算重数的话，一共有3k个），但每个根的重数要乘以2。我们可以假定f(x)没有别的分支点。我们要问的问题实际上就是：f(x)在∞处的分支点至少有多少个？
我们重温一下球面覆盖和二部地图概念之间的翻译表。



别雷函数
平面二部地图


覆盖的次数
边的条数


0处的分支点
黑色顶点


1处的分支点
白色顶点


∞处的分支点
面


0处和1处分支点的重数
顶点的度数


∞处分支点的重数
面的度数的一半



如果将所有这些要求翻译成二部地图的概念，我们实际上要解决的是这样的一个问题：
如果一个二部地图，它的白色顶点度数都是偶数，并且加起来是6k，而黑色顶点的度数都是3的倍数，加起来也是6k，那么，它至少有多少个面？（在这里，我们不能说白色顶点的度数都是2，因为P(x)可能有重根，黑色顶点同理）
如果k很小的话，试着画画也就可以了。但因为现在k可以要多大有多大，乱试一通大概不太管用。这就是借助别的数学工具的时候了。18世纪的大数学家欧拉（顺带一提，按博士导师的师承关系的话，他是笔者以及很多人的祖师爷）在开辟图论这一领域时，证明了下面的等式：如果一个平面地图有v个顶点、e条边和f个面（最外面的也算一个面）的话，那么必然有
 v-e+f=2. 
我们把这个等式套到我们的问题上，看看会得到什么。容易知道，我们的二部地图必定有3k条边，也就是说e=3k。把等式改写一下，我们得到f=2-v+e。因为我们想知道至少有多少个面，所以我们应该尝试寻找最大可能的v，也就是最大化顶点的个数。因为白色顶点的度数都是偶数，并且加起来是6k，要获得最多的顶点，最好的方法就是要求每个顶点的度数都是2，这样就能拿到最多的3k个顶点。同理，对于黑色顶点，最好的情况就是每个顶点的度数都是3，这样能拿到最多的2k个顶点。所以，顶点的总数合起来最多是5k个，也就是v \leq 5k。代入欧拉的等式，得到的就是f \geq k+2，也就是说这样的平面地图至少有k+2个面。考虑到其中一个面对应的是无穷远点x=\infty，这就意味着R(x)的度数至少是k+1，而且要达到这个度数，R(x)必须不能有重根，也就是说每个面（除了最外边）的度数都是2。
我们得到了想要的下界，但还要证明这个下界能够达到，而我们又不想计算无穷个满足条件的多项式，怎么办呢？这就是别雷定理出场的时候了：它告诉我们，只要对应的二部地图能画出来，那么满足要求的分式必定存在，而且系数都是代数数。所以，我们根本不需要计算，只需要画出满足条件的二部地图就足够了。这样的地图画法非常简单：首先画出一棵有2k个黑色顶点的三叉树（也就是没有圈的地图，而分叉的顶点度数都是3），在每个叶顶点（也就是度数为1的顶点）上画一条跟自身连接的边，然后在每条边中间插入一个白色顶点，就得到了满足条件的二部地图。可以证明，满足条件的二部地图必定能用这样的方法构造出来。根据别雷定理，既然二部地图能画出来，那么满足要求的分式存在，也就是说使R(x)达到最小度数k+1的P(x),Q(x)是存在的。
三叉树的构造，蒙A. Zvonkine惠允
实际上，我们可以给P(x),Q(x)施加更复杂的限制，用同样的办法，也能得到R(x)的最小度数。这个推广首先由U. Zannier在1995年给出，后来A. Zvonkine等利用二部地图的方法给出了简单得多的证明。
不仅如此，根据别雷定理，二部地图和分支点只有0、1和∞的分式有着一一对应的关系，所以，要知道有多少组P(x),Q(x)能使R(x)达到最小度数，只需要知道有多少个由2k个顶点组成的三叉树地图。我们之前考虑k=5的情况，截至2000年，数学家找到了两组解。但要知道一共多少组，只要在纸上随便画画，很容易数出来一共有四组解：
k=5的四组解，蒙A. Zvonkine惠允
通过这些地图，我们不仅能知道解的个数，还能部分推断出解的性质。树a和d各自拥有镜像对称性，所以它们对应的解的系数应该都是实数；树b和c分别是各自的镜像，所以它们对应的解的系数可能不是有理数，而是各自的复共轭。因为已知的两组解的系数都是有理数，它们对应的必定是树a和d，而未知的两组解应该向复数领域寻找。果不其然，剩下的两组解在2005年被日本数学家盐田徹治给出，这些解的系数在\mathbb{Q}(\sqrt{-3})中，一如预测。
这些预测又从何而来？镜像对称跟系数又有什么关系？要说清楚，就不得不提及二部地图的另一个名字——儿童涂鸦（dessin d'enfant），还有这个术语的创造者，也是现代代数几何的奠基者，伟大的数学家，亚历山大·格罗滕迪克。
</content>
</doc><doc>
    <docid>86</docid>
    <url>http://songshuhui.net/archives/96581</url>
    <title>小朋友的涂鸦（二）：球面覆盖</title>
    <content>本文作者：方弦
前文回顾：小朋友的涂鸦（一）：从8和9说起
球面覆盖
我们每天睡觉亲密接触的被褥，它的卫生状况值得重视，偶尔就要把被套拆下来洗一洗，洗完再套上去。但这不是个顺当的活计，尽管有系绳，但固定还是相当困难，手艺不好的，实在是难以把它弄得服服帖帖，总是会有些褶皱。这时候难免萌生出偷懒的想法，懒得把被套拉链拉开然后把内芯塞进去了，就随便用被套把内芯当粽子捆了，反正严格来说，的确也是用被套把内芯“套住了”，被套也完成了自身的责任：把内芯的每一处都“挡住”，不让睡觉的人把内芯弄脏。可惜被套一般没有弹性不能延伸，包起来的“粽子”实用面积实在太小，否则这也不失为一个好办法。
无论是正常的还是包粽子的方法，我们都可以说，被套把内芯“覆盖”了。最完美的当然是从头到尾平整光滑的覆盖，内芯上每个地方都被一层被套覆盖；稍差一些，有点皱褶的话，皱褶的地方就会有至少三层被套覆盖着内芯的同一个地方，而且还会有一些“分支点”，皱褶在这些点上开始，又在这些点上终结。如果是包粽子的话，那就不好说了，不过可以肯定的是，内芯上每个点至少有两层被套覆盖。
覆盖的折痕，来自Wikipedia
在数学家眼中，被套可以看成一个球面：假设被套有弹性，那么在里边装一个气球，再把气球吹起来，被套自然会鼓起来变成球面。同样，内芯也可以看成一个球面。如果我们先在内芯放一个气球，然后把内芯和覆盖它的被套缝起来，不让它们移位，最后将气球吹起来，那么我们就得到了被套这个球面对内芯这个球面的一个覆盖。这样的覆盖变化多端，可以是平滑的，也可以有皱褶，在每一点处，覆盖可以是单薄的，也可以是多重的。
把这些直观印象翻译成数学概念，这是数学家们的拿手好戏。球面之间的覆盖，用数学术语来说，就是从一个球面（被套）到另一个球面（内芯）的连续满射函数f，如果x是被套上的一点，那么f(x)就是内芯上被x这一点覆盖的点。我们要求函数是连续的，因为我们不想把被套扯坏，所以要求被套上的一小块“保护”的也是内芯上的一小块，而不是“分隔异地”的两块；我们要求函数是满射，因为我们希望保护内芯不被弄脏，所以要求内芯上的每一点都有被套保护。当然，数学毕竟是数学，比现实要更天马行空一些。现实中的被套不能穿过自身，而数学中的覆盖则可以。正因为如此，在数学中我们可以把覆盖的皱褶“抚平”，只留下一个个孤立的分支点，这在现实中是不可能的。而我们要求除了分支点以外，球面上的其他点被覆盖的次数都相同，这个次数又被称为球面覆盖的次数。

视频原作者：Dugan Hammock，他的Youtube频道上有更多关于曲面的精美视频。
然而，这些东西跟多项式又有什么关系呢？
对于数学家来说，关系非常大。因为他们知道，复数组成的复平面，差不多就是一个球面。有一种叫“球极平面投影”的方法，可以将复平面转化为只缺一个点的球面。而如果我们将“无穷大”也加到复平面里，就能把球面缺的点补上，得到的就是所谓的“黎曼球面”。而黎曼球面上的有理函数，也就是两个多项式的商，实际上就是一个球面覆盖。通过研究球面覆盖的性质，数学家们就能间接得知对应的有理函数的性质。
球极平面投影，来自Wikipedia
我们接下来考虑有理函数给出的球面覆盖。球面覆盖的许多性质都被它的分支点所决定，因为分支点以外的地方都非常平滑，到了乏善可陈的地步，而分支点正是曲面“叠起来”的地方，自然包含了我们想要的性质。我们可以说，球面覆盖的分支点越少，它就越简单。
那么，对于有理函数来说，怎么寻找它的分支点呢？还是拿被套作例子。当被套有皱褶时，皱褶的部分实际上是三层被套覆盖同一点，但同样应该属于皱褶一部分的分支点上，却只有一层被套。也就是说，分支点覆盖的层数比正常的要少一些。如此类推，对于函数f(x)引出的球面覆盖来说，假设它的覆盖次数是d，那么说某个点a是分支点，就相当于说f(x)=a这个方程的解值少于d个，因为这个方程的每一个解其实都是“被套”上覆盖a的一点。换句话说，a是分支点当且仅当f(x)=a有重根。
举个实际的例子。我们考虑函数
 f(x) = -\frac{(x-1)^3 (x-9)}{64x} 
显然方程 f(x)=0 有三次重根x=1，所以0是它的一个分支点；而稍微令人意想不到的是，如果我们将它减去1，就会得到
 f(x) - 1 = -\frac{(x^2-6x-3)^2}{64x} 
可以看出来，方程f(x)-1=0有两个二次重根，分别是二次方程x^2-6x-3的两个解，所以1也是一个分支点。最后还有一个分支点比较难想像，那就是无穷远点，因为当x趋向无穷或者0时，f(x)也趋向于无穷，所以无穷远点也是一个分支点。可以证明，这个函数再也没有别的分支点了。
最简单的球面覆盖，一个分支点都没有，就是最标准的把内芯塞进被套里的方法。球面到自身的恒等映射f(x)=x就是这样的一个例子。可以证明，不存在只有一个分支点的球面覆盖，也就是说，接下来第二简单的情况就是拥有两个分支点的球面覆盖。可以证明，所有拥有两个分支点的球面覆盖，都可以利用适当的变换来“拉扯”变形到f(x)是多项式的情况。
数学家们接下来要研究的，自然就是拥有三个分支点的球面覆盖。利用有名的莫比乌斯变换
 z \mapsto \frac{az+b}{cz+d}, 
我们可以将三个分支点分别移动到0、1和无穷远点（∞），而莫比乌斯变换不会改变球面覆盖的本质。所以说，我们只需要研究分支点分别在0、1和∞的球面覆盖，而能产生这样的球面覆盖的函数又叫别雷函数（Belyi function，正确地说是球面上的特殊情况），它的名字来源于20世纪的俄罗斯数学家别雷（G. V. Belyi）。但实际上，别雷并不是第一个研究别雷函数的人。早在19世纪末，大数学家菲利克斯·克莱因（Felix Klein）就已经利用别雷函数构造过一些特殊的球面覆盖（更精确地说，是单值群为有限单群PSL(2,11)的球面覆盖，它是一个11次覆盖）。

节选自《Möbius Transformations Revealed》，原作者为Douglas Arnold和Jonathan Rogness，完整版本可在视频页面找到。
但球面覆盖毕竟太抽象，即使是数学家，不借助适当的工具也难以“脑补”某个具体函数引出的覆盖，而对于一般人来说，光是球面可以穿过自身这一点就足够喝一壶的了，更不要说想像那些“折痕”都集中在几个分支点上的高次覆盖。要研究这些球面覆盖，似乎是难于登天。
但数学家却说，三个分支点的球面覆盖，其实简单得连小朋友都能画出来。
小朋友的涂鸦
要讨论别雷函数，就要对球面覆盖和复分析有些更深入的了解。接下来的内容可能有一点抽象，如果实在不适应，可以跳过，直接看本节最后的结论。
我们要研究的，是分支点分别在0、1和∞的球面覆盖，或者说某个别雷函数f(x)。既然球面覆盖的所有玄妙之处都蕴藏在分支点里，那么肯定要抓住这些分支点来研究。我们之前考虑过一个例子：
 f(x) = -\frac{(x-1)^3 (x-9)}{64x} 
它是一个别雷函数，对应着一个球面覆盖。用一点点复分析的知识（代数基本定理），容易知道除去一些特殊情况外，对于任意的常数a，f(x)=a都有4个解。也就是说，这个别雷函数对应着一个次数为4的球面覆盖。我们再来看看这个函数的分支点。它在f(x)=0处有一个分支点，因为x=1是这个方程的三重根，但它还有另一个根x=9，也就是说，0这个分支点实际上对应两个不同的点：三重根x=1和单根x=9。同理，1这个分支点同样对应两个不同的点，两个都是双重根。我们能看到，两个分支点的分支方式不同，但既然它们从属于同一个球面覆盖，那么之间必然有某种联系。怎么样才能考察它们之间的联系呢？
办法很简单：直接把两个点连起来就好了。也就是说，我们希望观察这两个分支点的每一层覆盖分支之间是如何连接起来的。
更具体地说，因为球面覆盖就是一个球面覆盖着另一个球面，只要在被覆盖的球面上连结0和1两个点，在得到的线段上涂上极浓重的颜料，等到颜料渗透到覆盖的每一层之后，再将覆盖展开，得到的就是球面上的一幅图。用术语来说，就是研究f^{-1}([0,1])。那么，我们得到的图像会是怎么样的呢？还是用刚才的函数来举例，我们得到的图像如下：
由方弦使用Maple制作
在上图中，黑点代表0对应的点x=1和x=9，而白点代表1对应的点x=3+2\sqrt{3}和x=3-2\sqrt{3}。因为这个球面覆盖的次数是4，所以线段[0,1]上的点实际上被覆盖了四次，也就是说，当覆盖展开之后，我们将会看到四段曲线（四条边），它们连接着0对应的两个点x=1和x=9，还有1对应的两个点x=3+2\sqrt{3}和x=3-2\sqrt{3}。三重根x=1上连着三条边，单根x=9只有一条，而两个双重根x=3+2\sqrt{3}和x=3-2\sqrt{3}各自连接两条边。函数在x=0和x=\infty两个点上发散，而这个图恰好又有两个面，外部的面对应x=\infty，而内部的面对应x=0，而这些面的度数（也就是边界的长度）与函数在对应点上发散的度数相关。也就是说，单单从这幅图像里，我们就能读出函数本身的许多代数性质。如果把顶点连接的边的数目称为顶点的度数的话，图像性质与代数性质的对应可以归纳成下面的列表：



别雷函数
平面二部地图


覆盖的次数
边的条数


0处的分支点
黑色顶点


1处的分支点
白色顶点


∞处的分支点
面


0处和1处分支点的重数
顶点的度数


∞处分支点的重数
面的度数的一半



实际上，对于所有的别雷函数，展开对应的球面覆盖后，线段[0,1]的图像总是包含着我们想要的很多代数性质：边的数目对应着覆盖的次数，黑点对应着f(x)=0的分支，白点对应着f(x)=1的分支，面对应着无穷大的分支，而每一个点和每一个面连接多少条边，都对应着球面覆盖在对应的分支上“折叠”起来的方法。
那么，别雷函数对应的这些图像，到底又是什么呢？
我们先忽略那些点和线的具体位置和形状，而只关注它们是如何在球面上连结起来的。用数学术语来说，就是先忽略它们的几何性质，而专注于它们的组合性质。首先，因为每条边实际上都来自线段[0,1]，所以它们连结的必定是一个对应着f(x)=0的黑点和一个对应着f(x)=1的白点。也就是说，别雷函数对应的图像，实际上可以抽象成一个二部图，这类图的顶点，一黑一白，而每条边的两端恰好是一黑一白两个顶点。但这些图像跟一般所说的二部图不完全一样。在数学中，一个图就是一堆顶点加上连结顶点的一些边，但连结同一个顶点的边之间并没有什么特别的关系。但别雷函数对应的图像实际上是一个画在了球面上的图，所以连结同一个顶点的边会在围绕在顶点周围，这就给它们赋予了顺序关系。这样画在了球面（或者别的封闭曲面）上的图，又叫组合地图。而别雷函数对应的图像，正式的名称是平面上的二部地图。在这里，组合地图即使画歪了一点，只要保持顶点、边以及边之间的关系，还算是同一个地图。
一个亏格为1的二部地图，由方弦制作
现在我们知道，每个别雷函数都对应着一个平面上的二部地图，那么是不是所有这样的地图都对应着一个别雷函数呢？事实上，利用一些复分析方面的知识，可以证明别雷函数与球面上的二部地图有着一一对应的关系。不仅如此，我们还能把这些别雷函数限定为系数是代数数的分式（代数数就是整系数多项式方程的解）。这实际上就是别雷的贡献：他在1979年证明了，对于一大类重要函数（所谓的“光滑代数曲线”），它们（的适当的等价类）与别雷函数引出的球面覆盖有着一一对应的关系。这些“光滑代数曲线”可以粗略理解为分支点只有0、1和∞，系数是代数数的分式。也就是说，如果我们要找分支点满足某些条件的分式，只需要看看根据这些条件能不能在平面上画出一个二部地图就可以了。
总结一下：三个分支点的球面覆盖，等价于所谓的“平面上的二部地图”，在这个地图上有黑色和白色两种顶点，而每条边都连接一黑一白两个顶点，从而把所有顶点连成一片。而球面覆盖的许多性质，都能反映在地图上的顶点、边和面上。别雷证明了，“光滑代数曲线”（大概就是某一类系数是代数数的分式）与三个分支点的球面覆盖有着一一对应的关系。所以，要寻找分支点满足某些条件的分式，只需要看看能不能画出满足对应条件的二部地图。而任意一个二部地图，哪怕是小朋友的涂鸦作品，也必然存在对应的分式，它的球面覆盖展开之后就是这个二部地图。
涂鸦的例子，作者为Laurent Bartholdi
说了半天，云里雾里的，这又有什么意义？
</content>
</doc><doc>
    <docid>87</docid>
    <url>http://songshuhui.net/archives/96565</url>
    <title>小朋友的涂鸦（一）：从8和9说起</title>
    <content>本文作者：方弦
从8和9说起
看到题目，你也许会问：8和9，两个普通的数字，又有什么可说的呢？但在数学家眼中，这两个数字可不寻常：9比8大1，8是一个立方数，它是2的立方，而9是一个平方数，它是3的平方。8和9，就是一个立方数紧紧挨着平方数的例子。那么，数学家自然会问：还有没有别的立方数，它紧紧挨着一个平方数呢？
 
或者用数学的语言来说， x^2 - y^3 = 1 这个方程，除了x = 3, y = 2外，还有别的正整数解吗？
我们先在直觉上探索一下，平方数和立方数，当它们越变越大的时候，在所有正整数当中也会越来越稀疏。就像两个越来越不喜欢出外的人，即使是邻居，也许一开始会打个照面，但之后出门的次数越来越少，也就越来越不可能碰上面。数学家们甚至猜测，即使不限定于平方数和立方数，就算是任意大于1的次方数，它们“碰面”也只有8和9这一回。用严谨的数学语言来说，就是方程x^a - y^b = 1，在a和b大于1的条件下，只有一组解，就是x=3, a=2, y=2, b=3。这又被称为卡特兰猜想（Catalan's conjecture）。
直觉上，卡特兰猜想应该是对的，但直觉毕竟是直觉，它不是数学证明。虽然平方数和立方数它们越来越稀疏，但是正整数有无限多个，它们有无数次碰面的机会，谁知道它们会不会在通向无限地平线的路途中就抓住了又一次机会呢？所以，我们需要数学证明，只有数学证明，才能从逻辑上根本地否决这种可能性。
我们来看看数学家是怎么思考的。
数学家们想要的是一个数学证明。我们重新考虑方程x^a - y^b = 1。在这个方程里什么东西最麻烦呢？减法很简单，等于号很简单，剩下的就是乘幂操作了。那么，有什么办法能去掉乘幂这个麻烦事呢？这个办法就是对数，大家在中学都学过。对数能将乘幂转化为更简单的乘法：\ln(x^a) = a\ln(x))。我们先将方程改写成x^a=y^b+1，然后两边取对数，就得到了a\ln(x)=\ln(y^b+1)。
现在，方程里最麻烦的又是什么呢？就是对数里边的加法，因为对数和乘法很友好，但跟加法实在谈不来，\ln(x+y)并没有一个好的表达式。有什么方法可以绕过去呢？我们想到，y^b是一个次方数，它可以非常大，要多大有多大，而相比之下，加上去的这个1非常小非常小，小得几乎可以忽略不计。而对数函数增长得又非常慢非常慢，ln(20)大概是3，ln(400)大概是6，要想对数值增加3，原来的数要增加20倍，要等到10^13，也就是万亿，对数值才达到30。而对于一万亿来说，这个小小的1实在是零头中的零头。
对数函数的图像
但数学是严谨的，虽然这个1很小，带来的影响更小，但我们不能直接说可以把1去掉。但这难不倒数学家：既然不是直接相等，划个界限总可以吧？用一点简单的高等数学，我们可以得到如下的不等式：
 b\ln(y) 
也就是说，去掉1和不去掉1，对于对数值的影响只有y^{-b}，也就是y^b的倒数。因为y^b可以非常大，它的倒数也就非常小。如果它增长十倍，它的倒数就会变成原来的十分之一。我们刚才说到，y^b要达到万亿，它的对数值达到30，这时候它的倒数，也就是加1造成的误差，只有万亿分之一。这是个什么概念呢？相当于在测量地球到太阳的距离时，不小心多加了根头发丝。在现实世界中，即使多么严谨的测量，这种程度的误差可能也就放过去了。但在数学中，无论多小的误差，不应该舍弃的时候就不能舍弃。
将这个误差的结论代入原来的方程，我们得到：
 |a \ln(x) - b \ln(y)| 
也就是说，我们要寻找两个正整数，它们的对数值的某个倍数非常接近。这就需要对正整数的对数进行深入的研究。在1966年到1967年，数学家阿兰·贝克（Alan Baker）写出了一系列的文章，其中给出了正整数乃至所谓“代数数”（也就是多项式方程的解），它们的对数的倍数之间距离的一个下界。也就是说，上面的不等式左边其实不会太小，它会大于某一个关于a,b,x,y的函数，可以写成：
 C(x,y,a,b)  
那么，如果我们能证明对于绝大部分的x,y,a,b都有 y^{-b} " /> C(x,y,a,b) > y^{-b} ，那么两个不等式就会产生矛盾，方程也就不可能有整数解，这不就解决了卡塔兰猜想了吗？
Alan Baker
当然，实际上这种简单粗暴的方法并不能解决问题。C(x,y,a,b)这个函数，虽然可以明确计算出来，然而得出的函数太小，不足以解决问题。但引出矛盾的方法不只一种。为了证明这类型的结论，贝克发明了一种方法，可以在不同的角度上引出矛盾。而另一位数学家Tijdeman利用贝克的方法，找到了一个巧妙的角度，证明了当a和b足够大的时候，方程必定没有解。而此前人们已经证明了，当a和b固定的时候，关于x和y的方程最多只有有限个解，而且给出了这些解的一个上界。结合两个结果，数学家们证明了，整个关于a,b,x,y的方程最多只有有限个解。现在在波尔多大学的数学家米歇尔·朗之万（Michel Langevin）计算出了一个明确的上界：
 e^{e^{e^{e^{730}}}}. 
也就是说，只要检查比这个数小的所有正整数，如果没有找到别的解，那么就说明8和9是唯一一对靠在一起的次方数。但这个任务看起来容易，做起来却是无计可施。 e^{e^{e^{e^{730}}}} 有多大？在现实中，能与其相比的数字根本不存在，即使是1后面添上宇宙里所有的原子当作0，这样得到的无量大数，还是连零头的零头都赶不上。对于这么大的数字，表达它都有困难，更何况检查！
数目远超银河中原子个数，图片来自Wikipedia
你可能觉得，这样找正整数的对数之间的关系，又有什么用呢？好不容易得出一个结果，却只是“原则上可以验证”，根本不能实际计算，这种方法又有什么用？但不要忘记，方法之所以是方法，就是因为它能应用到许多问题上。贝克的这套方法，可以应用到所谓的“丢番图方程”，也就是系数和解都是正整数的方程。大家耳熟能详的费马大定理，可能大家不太熟悉的完美长方体问题，都是悬而未决的丢番图方程。而对这类方程的研究，涉及数论的方方面面。贝克的方法给丢番图方程地研究带来了全新的工具，他也因此获得了1970年的菲尔兹奖，那时离他发表相关论文还不到四年。
但卡特兰猜想仍然悬而未决。要等到2002年，罗马尼亚的数学家Preda Mihăilescu才最终证明了卡特兰猜想。他的方法大量用到了分圆域与伽罗华模的知识，这些都是代数数论中的艰深概念，哪怕是稍稍涉猎，恐怕也需要本文十倍以上的篇幅才能讲个大概。但无论如何，我们现在终于可以确定，8和9在自然数中的确是绝无仅有的一对，在无限的可能中，唯一一对能紧靠在一起的次方数。
卡特兰猜想还有别的变体，比如说人们猜想，对于任意的正整数k，间距为k的次方数对只有有限个。对这些变体的探索也非常引人入胜。
但这不是这篇文章的主题。
从整数到多项式
我们在中学里就学过多项式。对于一个变量x，我们取它的一些次方x^a, x^b等等，乘上系数，然后加起来，就得到了一个多项式，比如说x^7+6x^3+4，就是一个关于x的多项式。在这里，我们考虑那些系数都是复数的多项式，也就是复系数多项式。
数学家们很早就发现，这些多项式与正整数有一种神奇的相似性：可以做加法、减法、乘法，也可以分解因数，可以求最大公约数和最小公倍数，同样有着唯一分解定理：正整数可以唯一分解成素数的乘积，而多项式也能唯一分解成所谓“不可约多项式”的乘积。基本上，在数论中对正整数性质的研究，很多都可以直接搬到多项式上来。于是，遇上有关正整数的问题，把它迁移到多项式之中，未尝不是一个提出问题的好办法。自然，因为多项式本来结构就比较复杂，相关的问题也更难解决，但这不妨碍数学家的步伐，毕竟他们要攻克的就是难题。
注：更准确地说，因为正整数和多项式都组成了所谓的“欧几里德整环”（Eucliean domain），所以它们共享非常多的数论性质，比如说，它们都是所谓的“主理想整环”，它们的所有理想都是主理想，也就是某个元素的倍数组成的理想。此处插播一则笑话：为什么QQ只有QQ群？因为QQ没有理想……
在1965年，Birch、Chowla、Hall和Schinzel问了一个问题：如果有两个多项式P和Q，它们是互质的，那么P的平方和Q的立方之间的差距，也就是说P^2-Q^3，可以有多小？这个问题很显然是卡塔兰猜想的延伸。卡塔兰猜想最原始的版本问的是，除了8和9以外，平方数和立方数的距离能不能达到1。而Birch等人现在问的是，多项式平方和立方的距离最小能达到多少？
当然，要回答这个问题，首先要想办法衡量多项式的大小。对于不同的多项式P(x)，当x趋向于正无穷时，P(x)趋向无穷的速度各有千秋，而决定这个速度的主要因素，就是多项式的次数，也就是多项式中x的最高次方是多少。所以，我们选择多项式的次数作为衡量多项式大小的标尺。现在，我们可以用更严谨的方式叙述那四位数学家的问题：
对于某个正整数k，假设有两个互质的多项式P,Q，其中P的次数是3k，Q的次数是2k。那么，多项式R=P^2-Q^3的次数最小可以有多小？
我们能看出来，在这个问题中P和Q的次数不是随便选取的。如果P的平方和Q的立方次数不一样的话，那么R就跟P,Q一样大。只有上面的选择方法，才能至少使两者的最高次项互相抵消，使问题变得不那么无聊。另外，对于任何一个例子，我们只要将所有多项式都乘上一个合适的常数，就能得到另一个本质上相同的例子。所以，我们只考虑本质上不同的那些例子。
在论文中，四位数学家给出了一个k=5的例子：
 P = \frac{1}{27} t^{15} + \frac{1}{3} t^{12} + \frac{4}{3} t^9 + \frac{8}{3} t^6 + \frac{5}{2} t^3 + \frac{1}{2} 
 Q = \frac{1}{9} t^{10} + \frac{2}{3} t^7 + \frac{5}{3} t^4 + \frac{4}{3} t 
 R = \frac{1}{36} t^6 + \frac{7}{54} t^3 + 4 
在这个例子里，P, Q, R的次数分别是15、10和6。虽然P^2和Q^3的次数都是30，但是它们凑巧在前24项的系数都相同，而它们的差仅仅只是一个六次多项式，真是一个难得的巧合。但数学家总是有些贪心，面对这个例子，他们想的是：能不能把R的次数再压低一点？能不能找到差距更小的平方多项式和立方多项式？这个想法非常自然，但在反反复复的尝试中，似乎找不到次数更低的例子了。于是，这四位数学家就猜想：这个例子是不是已经无法改进了呢？他们提出了这样的猜想：
对于两个互质的多项式P,Q，假设其中P的次数是3k，Q的次数是2k。那么，多项式R=P^2-Q^3的次数至少也有k+1，而且总能找到使R的次数恰好是k+1的例子，也就是说这个下界是紧的。
在刚才的例子中k=5，而R的次数恰好就是5+1=6，符合猜想。数学家们想寻找更多的这样达到最小差距的例子，尝试在其中寻找规律。但出人意料的是，k=5的第二个例子，要到35年之后的2000年，才被Elkies发现，而且这个例子的复杂度远远超出了预期。在上面的例子中，我们看到的系数都是相对简单的分数。而现在，请看Elkies的这个例子：
 P = x^{15} - 3x^{14} + 51x^{13} - 67x^{12} + 969x^{11} + 33x^{10} + 10963x^9 + 9729x^8 
 \quad + 96507x^7 + 108631x^6 + 580785x^5 + 700503x^4 + 2102099x^3 
 \quad + 1877667x^2 + 3904161x + 1164691 
 Q = x^{10} - 2x^9 + 33x^8 - 12x^7 + 378x^6 + 336x^5 
 \quad + 2862x^4 + 2652x^3 + 14397x^2 + 9922x + 18553 
 R = - 2^6 3^{15}(5x^6 - 6x^5 + 111x^4 + 64x^3 + 795x^2 + 1254x + 5477) 
在这个新例子中，多项式的系数大大膨胀了，这就解释了为什么寻找第二个例子花了这么长的时间。我们也能从另一个侧面窥见这个问题的难度。比方说，我们希望用待定系数法寻找例子：先将多项式P, Q的系数都设为未知数（最高次的系数设为1），然后计算R的所有系数，它们都是之前未知数的多项式。在k=5的情况下，我们要求R从x^{29}到x^7的这23个系数都是0，这样就得到了23个方程。将它们联立起来，就得到了一个关于25个变量的23个方程组成的高次方程组，理论上只需要解出这个方程组，就能得到所有的例子。但问题是，这个方程组的总次数是6198727824，大约是六十亿！这样的方程，不要说是人脑，就是计算机也几乎无法解开。但至少，我们知道这些系数都是所谓的“代数数”，也就是代数方程的解。这样庞大而困难的问题，难免令人望而却步。寻找新的例子已经如此困难，更不要说穷尽所有例子了。
但有一帮数学家，光是看了看问题，在餐巾纸上随手涂鸦了一下，就拍着胸脯宣称：k=5的情况一共就只有4个例子，还有两个就继续找吧；不光这样，对于任意k的情况，我们都能证明你们的猜想是对的，而且还能帮你们计算所有本质上不一样的例子一共有多少个。
这是什么魔法？
</content>
</doc><doc>
    <docid>88</docid>
    <url>http://songshuhui.net/archives/96650</url>
    <title>胃难受？快去考古研究所做个检查，证明你来自未来！</title>
    <content>本文作者：Sheldon

如果你经常胃难受，一定要重视起来！







（美指：牛猫 | 绘制：赏鉴）
注：1. 碳-14呼气试验的放射性很微弱，对人体是安全的。被试者吃下去的尿素也会通过尿液排出，因此不用担心。
2. 有资料称，如果胃里含有幽门螺旋杆菌，但没有不适的症状，可以选择不去管它。
3. 杀灭幽门螺旋杆菌的三联用药有很多种组合，例如阿莫西林+克拉霉素（这两种是抗生素）+奥美拉唑（这是抑制胃酸的药物）。
本文已发表于《不存在日报》
</content>
</doc><doc>
    <docid>89</docid>
    <url>http://songshuhui.net/archives/96628</url>
    <title>一分钟看懂2016年诺贝尔化学奖</title>
    <content>本文作者：Sheldon
美指：牛猫 | 绘制：赏鉴
2016年诺贝尔化学奖，就是三个化学家学会用分子造车。
第一步，先学会造轮胎。
第二步，把轮胎套在轴上，让他们“动次打次”动起来。
第三步，让轮胎绕着轴转动。
&nbsp;





</content>
</doc><doc>
    <docid>90</docid>
    <url>http://songshuhui.net/archives/96622</url>
    <title>一分钟看懂2016年诺贝尔物理学奖</title>
    <content>本文作者：Sheldon
美指：牛猫 | 绘制：赏鉴
2016年诺贝尔物理学奖，说白了就是在3维世界研究2货。




</content>
</doc><doc>
    <docid>91</docid>
    <url>https://xbeta.info/rule-41.htm</url>
    <title>[转]反对修订《美国联邦刑事诉讼规则和证据规则》第 41 条</title>
    <content>收到一位国外朋友的邮件，建议转发对美国拟修订第41条规则的抵制。大概研究了一下， 《美国联邦刑事诉讼规则和证据规则》第 41 条为「搜查和扣押」 。美国政府准备修订相关条款，而该修订行为会对个人信息安全造成损害。美国很多科技媒体、社群、个人，都在抵制这一修订。转发一下，也欢迎大家发表意见。毕竟，这个世界是紧密联系在一起的！

不要让美国政府侵入个人的计算机 – 停止修订第41条规则
Ariel Hochstadt (前谷歌雇员，国际科技讲师)

美国政府希望采用一种模糊不清的程序——修订一条称为第41条规则的联邦规定——从而充分扩大他们侵入我们计算机的权限。第41条规则的修订将会使其更容易闯入我们的计算机、收集数据、进行远程监控。这些修订可能会影响在世界任何地方使用联网计算机的任何人。然而，他们对采用隐私保护技术如Tor和 VPN的人员的影响则不尽相同。美国国会直到12月1日才可阻止修订的生效。我们需要大声疾呼。与你的朋友以及在你的博客上分享这个帖子。提高人们对修订第41条规则的意识！
什么是第41条规则？它如何对生活在美国之外的你产生影响？
第41条规则授权联邦治安法官签发执法搜索和查封的许可。但它含有一条重要限制：它要求政府必须获得其所欲执行搜索的管辖区域法官的许可，某些有限的情况除外。第41条规则的修订将会削弱这条限制，允许政府在某一管辖区域申请许可，执行对位于另一管辖区域的计算机的远程搜索。修订将会适用于下列情况：
* 有人采用“技术手段”隐藏其计算机的位置时；或
* 调查僵尸网络时，此时受损的计算机位于5个或更多行政区。
50家组织 – 包括公共利益集团、隐私工具提供商以及因特网公司 – 团结起来，大声疾呼，反对修订第41条规则。vpnMentor与noglobalwarrants.org协调一致，领导要求撤销所提议的第41条规则修订的全球性努力。虽然noglobalwarrants.org专注于美国公民，鼓励他们联系其国会代表，但对这条规则的全球性意识依然极为重要，因为美国政府也将能够侵入采用 VPN 或 Tor 浏览器的全球用户。这就是我们将“行动呼吁”翻译为26种语言、尽最大努力在全球分享的原因。
reject rule 41 changes
修订第41条规则错在哪里？
规则修订可能会极大增加执法人员侵入我们计算机的频率。这是因为修订条款将会授权这个国家几乎任何联邦治安法官签发这类许可。执法人员可择地诉讼，找到美国最利于起诉或最不懂技术的地方法官，签发这些危险的许可。根据这些规则的修订条款，如果人们的隐私保护技术使其计算机的位置模糊不清，美国几乎任何行政区的法官都可能授权执法人员远程搜索或侵入他们的计算机。这就意味着，极其在意隐私的人有可能受到这一规则修订大小不一的影响。
在很多情况下，地方法官可能会不顾其他国家的法律保护，在不知情的情况下签发侵入位于世界各地，而非只是美国的计算机的许可。
规则修订还会致使执法人员寻求远程搜索成千上万计算机的单一许可 – 违反美国宪法第四条修正案和国际人权法的保护条款。
非法侵入 – 秘密闯入计算机、复制数据、删除数据或执行代码 – 可能会对用户及其设备产生严重后果。比之僵尸网络本身，政府代表实际上可能会在僵尸网络调查期间对无辜用户的计算机造成更大的损害。如果国会采取极端措施，授权政府非法侵入，则必须对何时允许此类行动进行严格限制，对遵守美国宪法和国际法的用户给予强有力的保护。
如果美国国会不采取行动，这条新规则的更新则将于2016年12月1日生效。这就是我们必须大声疾呼，要求否决这一规则修订的原因。在社交网络和你的博客上分享这条帖子吧。
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>92</docid>
    <url>https://xbeta.info/maibu-watch.htm</url>
    <title>麦步智能手表试用体验：超长待机是硬道理，开放平台是未来</title>
    <content>2 周前，收到麦步智能手表的邮件：介绍其特点，询问试用意向。读完邮件，印象很好：文字、配图都比较详细，也写了不少针我的个性内容，十分用心。而智能手表作为新兴事物，难免存在众多不足。无论当下领先一点、落后一点，只要用心，坚持就能做好。介绍的产品特点——智能手表上的番茄钟 app、超长待机，又继续增加了印象分。我进而看其官网，见到「极客实验室」、「麦步应用遵循知识共享协议」的用语，印象分继续加持。于是，接受试用，等待发货。
开机体验
关注开箱图和细节，参见：用了 2 周「麦步智能手表」，它是这个样子的｜小众软件
总体来说，开机过程非常流畅，对普通用户（当然不是全体人，而是有较大概率的潜在用户），不存在任何问题。在蓝牙配对成功、表/机相连的时刻，考虑到很可能是人们第一次佩戴智能手表，所以，不妨做得更有仪式感。比如在手机端出现一个特殊的页面，并允许分享到社交网络。
开机过程中看到了电量，还有一大半。基于对「超长3周待机」的信任，直接使用，懒得充电。
开机后，默认表盘实用而简洁，非常简洁：

省电屏幕，只有黑白两色。
上部，约占屏幕 60%，是黑底白字

第一行是星期、日期，小字，最简洁的格式： 周五 4/22
第二行是时间，大字，也是最简洁的格式： 15:57


下部，约占屏幕 40%，是白底黑字，大字显示当天的运动步数。


同事看到后，直接表示：他一直寻找的跑步设备就是——比手机更便携、能显示时间、能记录运动。
关于「智能」的体验
在我看来，可穿戴设备的「智能」，有三项主要意义。
一是消息提醒功能：智能手机的提醒消息，通过近场蓝牙，传送到手表上。
人与工具（尤其是手机、穿戴设备、PC）这样的高级工具，越来越集成为一个系统，共同与外部世界交互。但同时，因为工具（或工具系统）复杂性的提升，人机界面也在不断进化整合。最明显的例子，先是工具输入端的「inbox/收件箱」，后是工具输出端的「notification center/通知中心」。而可穿戴设备，在传统的收集方面，并无优势。相比而言，通知中心的价值尤显重要。
我自己的手机提醒，已经做过长期的优化、自定义，提醒项数量频度符合我的需求。因此，我没有关注是否有手机→手表的中间过滤机制。
实用体验来看，确实比手机方便了不少。抬腕即看，比从口袋/桌上拿起手机，更为快捷。有时走在路上，手机收到消息提醒，你可能不方便查看，又担心错过消息。但手表几乎消除这个死角场景。
而同时，虽然开了蓝牙，但减少了手机的操作，手机待机时间或许更长。——这个附加价值，也是我很看重的。比如，我推荐 Kindle 的一个理由，就是让 iPhone 待机变长 :-)
另外，震动提醒（目前震动力度稍弱，需要像小米手环那样，更强一些），也减少了对他人的干扰。
  
二是可以安装app
对手表而言，表盘是一类特殊的 app，很容易体现个性化。所以，官方区分了表盘和功能应用，做了区分。
表盘：表盘实际就是一个桌面app，相当于一直开启，显示最常用的信息。在开机体验中，也介绍了「星期+日期+时间+步数」的默认表盘。此外，官方提供了多种表盘，有能力的用户也可以自己开发表盘，来展示更多信息，或采取不同的样式。我作为一个实用主义者，非常满意默认表盘，在商店预览了所有表盘后，基本没有尝试。
应用：目前应用数量不多，限于硬件性能、展现面积，并没有特别让人眼前一亮的应用。
但几个效率类应用，值得特别说一下：

番茄钟：我一直觉得，作为一款「计时」工具，番茄钟若非独立实体，最合适的虚拟环境就一定是手表。因为它天生就是专为计时而生！推荐试用+使用。
滴答清单：能同步 5 条任务，每条任务显示的字数也比较少，主要起提醒作用。可以在手表上查看任务，也可以「确定」标记为完成。但偶尔会出现与手机端滴答清单app失去连接的情况。（此时，手表手机的蓝牙连接仍然正常）不过，仍然赞一下麦步与滴答两家，对时间管理爱好者的支持，和创新的勇气！相信在几款时间管理工具相差无几的情况下，对手表端的支持，或许成为选择的关键因素。
记事表盘：虽然是表盘，但也算是提醒、效率类。适合把自律自勉的话，放在表盘上，时刻提醒。变态一点，也可以把要记忆的内容，发送到表盘上。

  
闹钟功能：最初使用时，发现手表本身除了「整点提醒」外，没有闹钟功能。应用市场有「静音闹钟」，还提醒占用较大存储空间，也让人感觉不太放心。后来，iOS手机端继安卓手机端之后，也增加了闹钟功能：手机上设置，同步到手表。但使用过程中，仍然有些不方便。或许有技术原因，但我坚持认为，手表上直接设置闹钟，应该是基本功能。如果做同步，那应该把手机系统设置的闹钟，直接可选择地传到手表。
整点提醒：因为震动稍弱，此功能有时感知不到；有时感知到了，以为有消息提醒，看表，疑惑一下，才想起是整点；至今仍然不理解的是：夜间的震动是自动关闭了？还是我睡熟了没有感觉到？
总体来看，麦步在效率应用上，是特别用心的。这方面有需求的朋友，可多关注、多尝试、多反馈，相信厂家会快速跟进的。
「智能」的第三个含义是人性化，是在前面基本功能做到的情况下，更人性的做法。比如，现在设置中的「晃动亮屏」，思路很好，但我这里无效。我相信随着传感器的进步、大数据算法的改进，未来会有更多更人性化的场景。仅就上文中提到的 2 个场景进行展开：

抬腕亮屏：什么算抬腕，通过算法/反馈学习用户习惯去判断；如果光线亮，也不必要亮屏；用户一直抬着手腕，屏幕背光就不要关闭。
震动提醒：不同环境的强度，应该是不同的；不同类型的提醒，也可以是不同的节奏；用户抬腕之后，震动就应该停止了。

「智能」之外的功能，也很重要
手表
智能手表，首先是手表。而手表，作为一个独立产品、行业，需求已经被证明。因此，单从「时间」感这个维度上，就足以发掘很多用户。很多年轻人已经没有佩戴手表的习惯，但作为「手表+」，接受起来就容易得多。对那些有戴表习惯的用户，「手表+」的概念也容易转换。我之前不佩戴手表，要看时间就需要掏出手机，不仅不方便，还会出现这种情况：打开手机，发现一个提醒消息，看一下或处理一下，又放回了口袋——然后意识到刚才是要看时间！佩戴手表期间，对时间的掌控、减少手机的使用频次，都有明显改善。
与手环对比，能更好理解「手表」的基础定位。手环，几乎是全新无依托的事物。我不知道其他用户的情况如何，我自己使用过一段时间的小米手环后，最后还是停用送人了。
因此，智能手表，是基于手表的7分功能，增加2分新功能，再增加1分有趣，就有很大市场。而智能手环，抛开价格便宜的因素，实用功能，尤其是强需求的实用功能，其实不多。
计步
计步是一个简单，但容易快速吸引用户的功能。
需要「计时+计步」功能的同事，非常有兴趣的试用了麦步手表。尽管几天后归还，表示功能还是太简单不满足需求——跑步需要 GPS、速度……
我女儿，刚 6 周岁，上学路上佩戴手表，格外高兴。走几步就看一下步数、时间。
其他感想
不要夸大智能
我自己，并不是「智能」设备的狂热用户，更算是一个宏观上抱着信心和支持，但微观上持实用主义。这大概与我的年纪有关，也与我从事「智能电视」创业有关。「智能」设备，最典型的当然是手机。而「智能」手机也确实不负这个称呼，完全超越了手机打电话、发短信的功能，几乎具备了计算机的大部分功能，并且体验极佳，称为「智能」，实至名归。而「智能电视」，则因为行业在硬件、设计方面的历史包袱、落后、懒惰，仍然很难使用。冠以「智能」，固然是用了同样的 Android 系统，但更是为了营销的需要、估值的需要。所以，在用户看来，智能手机，确实是能做很多事，并且真带来生活改变、日常惊喜的手机。而智能电视，则更多是「能上网、价格便宜，但自己也没觉得有什么不同」的电视。
夸大智能，不一定是厂家本意。很多情况下，因为风险投资的参与，就要追求极限（甚至超越客观规律）的增长率，带来了透支性、过度宣传、超前宣传。
苹果手表：只简单试用过，但我宁可用黑白屏换取长待机。
用心积累
文中所述，试用手表之前的好感，来自于邮件的用心、官网体现的理念。有付出，细心的用户一定能感受到。
试用几天之后，突然想起：不久前在朋友圈见过佐拉的文章，似乎就是麦步。核实，果然。因为佐拉的好评，以及他还动手制作了表盘的参与，更拉近了距离。
滴答：作为先开拓国际市场，后开拓国内市场的优秀产品，很多重度或早期的时间管理爱好者已经选定了自己的工具。但他们对智能手表这一新兴领域的重视、抢先支持，肯定会在新用户、及老用户再次选择时，取得先机。至少在我，虽然没有从目前的主力工具转移到滴答，但印象分至少增加了5分。
工具只是工具，善用才是王道
早上送女儿上学，麦步手表都是她戴着。那天刚好生日，我就用妻子的手机给我发微信：安安，祝你生日快乐！小家伙感到震动，抬腕查看，惊喜有加！（后续：过了会儿，她说：爸爸，肯定是你发的。为什么能在手表上显示啊。于是我讲了 妈妈的手机→基站→千里之外腾讯服务器→基站→我手机→蓝牙到手表的 路径，小家伙表示很有意思）
麦步市场中，有个特别的「手机防丢表盘」，就是巧妙利用了手机随身，如果蓝牙断开，则自动提醒的功能。那么，稍加改进，也可以在特殊情况下，让孩子佩带手表，启用安全模式，在断开时手机端也向家长进行提醒。
总结
作为一款简洁实用的手表，超长待机、消息提醒，这两项功能足以保证它可以长期使用。而开放的系统，又为它提供了足够的扩展空间。所以，想尝试智能手表的朋友，不妨从麦步 开始。
官方售价 399 元。麦步 官方向善用佳软的读者赠送了优惠码——但是，为了更方便，大家还是直接用小众软件的优惠吧，哈哈：领取天猫优惠券！
PS：如果大家有兴趣，可以留言，说不定能争取更多流转试用的机会。
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>93</docid>
    <url>https://xbeta.info/activepresenter.htm</url>
    <title>【转载+补充】最强免费萤幕录影软体 ActivePresenter 教学影片神器</title>
    <content>2016-04-12 更新：感恩 yuxiaoxu 网友，AP 的简体/繁体中文语言包已经翻译并发布了。大家可以下载后，解压到 AP 安装目录的 ……\ActivePresenter\locales\ 下，然后 view → language 切换到「简体中文」，重新启动即可生效。下载 http://xici800.cn/5opXo2
xbeta序
看到电脑玩物发了ActivePresenter 的文章，非常高兴和激动。我几年来介绍ActivePresenter的愿望，终于由老朋友代为实现了。先说结论：来自越南的 ActivePresenter 是最强大的免费录屏软件，相当于 BB FlashBack 的收费版，非常适合『有更高要求+愿花时间学习复杂软件+愿花时间精心编辑录屏视频』的用户。
1、令人赞叹的 ActivePresenter
ActivePresenter 绝对是功能最强大的免费录屏软件（另有收费版）。但非常可惜，无论在国内还是国外，它的知名度都很低。
从技术角度，AP是一款非常强大的软件，并且无论官网设计还是软件UI，都是大公司风范。如果其他软件算是“录屏软件”的话，那对AP来说，“录”只是它的1/3功能，此外的“制作”和“编辑”的功能，也极为强大。比如，一个视频项目可以由多个slide（本意是幻灯片的一页，但我认为理解为一节视频更合适）组成，每个slide可以是图片、ppt、视频；每个slide可以添加多层对象、多音轨；每个对象/音轨，可以进行多种编辑——分割、起止时间、截取片段……
从商业角度，AP的免费版提供了大量在其他软件的收费版才具有的功能。甚至，一般用户都没有必要购买它昂贵的收费版。
而还有两项一般用户不太注意的地方，也令人赞叹：它的帮助文档（如图），简直可与早期的电器说明手册相媲美。而它的出处，更是让人意想不到：ActivePresenter 来自越南~ 公司所在地就在越南河内。这大概是它没能被搜索引擎、科技媒体、软件爱好者广泛发现的原因。

2、为什么迟迟没有介绍 ActivePresenter
我早期写博客文章，无知无畏，所以写了很多Vim和Total Commander的文章。越到后面，越感觉难以下笔，尤其是面对一些极其优秀的软件。
比如当时面对 ActivePresenter ，我的感觉是：

从文章看，要写近万字才有介绍全它的功能。但如此长文，如何还能引起读者的阅读兴趣？如何让文章与作品同样优秀？在当时的精力下，都比较困难。
这样复杂的软件，只有文章恐怕仍不易入门，最好有视频教程……
竟然出自越南，我应该采访一下开发团队，并促成国内合作。
不过，联系采访之前是不是应该把官网先翻译了……

其实上面每一项都启动过，但也都没有完成。所以，积累了一些素材，但文章始终没发。
3、接触与使用 ActivePresenter 的历程
2013年12月，研究录屏软件时，在为知笔记中记录了 ActivePresenter 3个版本（当时只有免费/标准/专业版，尚无现在的教育版）之功能对比，做了大部分翻译。此后有大量各软件录制视频的参数对比记录。
2013年2月，用它制作了一段给女儿讲故事的视频：①把女儿的绘本每页拍照；②各照片导入ActivePresenter，成为N个片段；③讲故事并录音；④把录音文件用Audacity去除噪音，并分割；④在AP中，N幅照片与N段录音融合；⑤导出视频。
2015年7月，用ActivePresenter录制了一些公开发布的视频（当时是刚发现B站的无二压上传）。用AP主要是为了添加封面和目录。
比如 《在TC中一键压制x264视频》 中明显不是直接录制的视频，实际前几段都是用ActivePresenter制作的，导入图片再添加文字（或者直接在PowerPoint中制作并导入ActivePresenter）；后面的目录字幕，也是用AP添加的。如图：

邮箱大师 Windows版的安装与基本界面 视频中，开篇的语音就是利用AP的功能自动生成的！也就是说，我标注上文字，就可以让AP来自己配音：男声、女声、时长……见图：

4、ActivePresenter的功能补充
A。各版本功能比较
3个版本（免费/标准/专业）共有的功能：

导出图片 (PNG, JPEG)
导出视频(AVI, MPEG4, WMV, WebM, MKV)
导出SCORM 1.2, SCORM 2004

标准版和专业版的额外功能：

导出flash（flv）
导出HTML幻灯片
导出PDF
导出MS Word
导出MS Excel
导出MS PowerPoint
导入MS PowerPoint

专业版独有的功能：

导出HTML5交互
导出flash交互

从上面的对比来看，免费版仿佛功能很少。但实际上，上述对比仅限于导入/导出功能。而该软件强大的录制、编辑功能，在各个版本都是具备的。它们包括——

智能录制：在鼠标或键盘按下时，捕获屏蔽。每个动作将形成独立的片段（slide），这样既方便后续编辑，也方便观众/用户仔细了解每个操作步骤。
完整动作录制（FMR：Full Motion Recording）：把完整的屏幕操作录制下来，并作为一个片段（slide），后续可以编辑——文字注释、语音解说、点击声音、标题、过渡效果……
交互与分支：录制教程并用AJAX/Flash模拟格式发布后，用户可以通过点击等方式进行交互，教程会根据用户的行为反馈不同内容。
音频视频编辑：可以同时或分别对视频、音频的不同音轨进行编辑：剪切、删除、裁剪、合并、分割、改变音量、添加冻结帧。
事件与动作：丰富灵活的事件-动作机制，可以定义不同的学习场景、步骤，来响应用户的不同行为。比如，用户鼠标左击如何，右击如何，正确如何，错误如何……
标注样式：录制内容上还可以添加各种标注。并且这些标注支持不同的边框线型、填充、文字效果、阴影。
过渡效果：对片段、视频、标注对象，都可以添加丰富的过渡效果。
智能标注：会根据你的动作自动添加标注，比如“双击xx图标”。这样制作教程非常迅速。

关于导出，不仅可以导出AVI, FLV, WMV,  MP4，WebM（较新格式，目前实用性不强，但体现了软件的前瞻性）等视频格式，并且支持帧频、关键帧、质量等参数，以便于平衡视频质量与文件大小。并且可以导出HTML5，这样在PC、平板、手机的浏览器中都能正常运行。
注：SCORM是一种数字教学内容的格式规范。全称 Shareable Content Object Reference Model，译为共享内容对象参考模型或共享组件引用模式，由ADL (Advanced Distribution Learning Initiative)集成各个学习标准制定而成。
5、录屏方案的选择
对ActivePresenter的赞叹和欣赏是一方面，但从实用角度，估计大多数人是不需要它的。功能虽然强大，但操作起来也比较繁琐。实际上，我自己的录屏方案是这样的：

wink 已经停用：最早推荐方案是Wink，原因是录制flash教程画面无损、体积超小、精确交互。但现在，flash时代已经过去，尤其难以找到上传空间。并且，软件久不更新（该团队后面还开发过手机上录屏直播的app）。
屏幕录像专家：界面很简陋但性能很好的国产软件。我是付费用户，但不注册的使用限制也比较少。它的优点是适合长时间录制，占用资源少，操作便捷，转码mp4很快很方便。如果只发给少数人，则独有的lxe文件格式更清晰小巧。1小时的录屏可以压缩到100MB。
ActivePresenter：如果需要制作封面、目录页、或添加文字注释，我就使用ActivePresenter。
转码/压缩工具：小丸工具箱（强力推荐）
如果别人问起，我通常推荐 BB FlashBack Express：因为它免费、入门易、网站的介绍也比较多。

6、录屏之后的发布
现在是在线视频的时代，但PC操作录屏发布，却没有特别好的普遍方案。大家看一下各软件博客偶尔录制并发布的在线视频就明白：明明录制时极为清晰，上传后却画质极渣。
实际上，我在这方面投入的研究实验时间，比研究录屏软件更长。用不同的参数录制、压制，上传到不同网站，做过各种对比。最早找到的是sina无二压方案；后来也用过土豆的原画方案——但这些方法现在已经过期。目前可用的，主要是B站上传方案。说起来又是一篇长文，也曾在知乎介绍过，此处不展开。
我现在如需发布，是操作录屏则发B站（低码率而清晰，真正高效环保）；拍摄的视频则直接iPhone录制，用优酷/腾讯等视频客户端直接上传。
好，序言结束，下面开始转载：
最强免费萤幕录影软体 ActivePresenter 教学影片神器
作者：电脑玩物 　　 出处：http://www.playpcesor.com/2016/01/activepresenter.html
Windows 上有很多免费萤幕录影软体，例如我之前介绍过的：免费萤幕录影神器！推荐这款比软体好用 Chrome 套件 、桌面萤幕录影免费软体推荐：超简单在教学影片上画重点解说
这些萤幕录影软体都各有优点，今天要跟大家推荐的这款「 ActivePresenter 」也有自己的特色。
或许我不会说「 ActivePresenter 」是最好用或是最佳桌面录影工具，但是「 ActivePresenter 」绝对是「最强大」的免费萤幕录影软体，这是什麽意思呢？因为「 ActivePresenter 」介面或许不是那麽好上手，但丰富的功能却可以满足真正要「製作专业教学影片」、「编辑各种数位教材」的需求！所以最强大当之无愧。
如果你是一位老师、训练人员、产品客服，或是你在任何情况下要製作一段包含短片、包含简报、包含语音、包含各种操作说明特效的完整教学影片，而你发现一般萤幕录影软体没办法满足你进阶需求时，免费的「 ActivePresenter 」或许能帮上你的忙。
1. 最快上手！录製包含点击特效的软体操作影片
「 ActivePresenter 」功能有点複杂，介面也很有特色，或许刚刚安装后的你会有点摸不着头绪。
没关係，在还没有搞清楚他的所有进阶功能前，我们还是可以把「 ActivePresenter 」当作一款简单的桌面萤幕录影软体来使用！
只要点击［ New Capture ］，选择第一项「 Record Software Demo 」，也就是录製桌面软体操作影片即可。

这时候会弹出「 ActivePresenter 」的录影工具列，我们可以决定要全萤幕或局部录影，可以选择高画质，可以录下系统的声音，或是外接麦克风的声音。
更棒的是，录影过程中我们的每一次滑鼠或操作点击，都会在影片中自动加上特效！
按下红色的录影按钮，就开始录製桌面操作影片。
而录製中按下［ Ctrl ］+［ End ］，就可以结束录影。

结束录影后，会进入「 ActivePresenter 」的影片编辑介面，你会看到「 ActivePresenter 」也是一个很完整的影片编辑器，我们可以在这裡剪接影片，去掉教学影片中不想要的段落，或是继续录製其他片段，最后把它们合併成完整教学影片。

2. 进阶需求！聪明录影功能，自动帮每次操作建立分段影片教材
开始慢慢熟悉「 ActivePresenter 」后，就让我们来看看他更强大的教学教材製作功能，这时候我们在［ Capture ］中选择［ Smart Capture ］。
这个「聪明录製」模式有什麽特色呢？他会在录影过程中，根据我们每一次的操作点击，自动把教学影片分割成一段一段的短片。

并且会在每一个操作动作的短片简报中，在正确操作位置自动加上教学说明图解。
这样一来，是不是更轻鬆的产生一个可以自动重组、修改的教学影片专桉？我们可以像是製作简报那样，开始在这些分段的短片中快速编辑，产生有模有样的教学影片。

3. 更全面的免费版本：无浮水印、无时间限制、个人非商业使用
而本文提到的所有「 ActivePresenter 」录影与编辑功能，都是可以提供个人非商业性免费使用的！这对学校老师来说非常有帮助。
而且「 ActivePresenter 」的免费版不会有浮水印，也没有影片製作的时间限制。

4. 有动有静的影片简报编辑
「 ActivePresenter 」既然是为了製作教学影片、数位教材而诞生的软体，那麽除了前面的录影与剪接外，他还具备了很多额外的注解互动特效。
例如你真的可以在影片中插入其他简报、插入图片，快速在「 ActivePresenter 」类似简报软体的编辑画面中，製作有动（操作短片）有静（说明简报）的教学影片。

5. 针对录製教学影片的丰富教学特效元素
「 ActivePresenter 」也有丰富的教学特效素材可以使用，让我们放到简报或影片上！
例如可以用聚光灯效果来聚焦影片中的某个重要操作动作，或是加上新的滑鼠游标说明轨迹等等，大家可以在製作教学影片的过程慢慢研究。

6. 支援输出各种影片格式
而最后「 ActivePresenter 」编辑而成的教学教材，可以转档输出成许多格式，免费版就支援输出成各种格式的影片档桉。
「 ActivePresenter 」或许不是最简单易用的萤幕录影软体，但却是最强大的教学影片製作工具，想要製作数位教材的老师、训练人员、产品客服，都值得好好利用。（转载结束）
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>94</docid>
    <url>https://xbeta.info/aiya.htm</url>
    <title>[已结束]过完节，关爱一下牙齿吧~</title>
    <content>【2016-02-26 星期五 更新】活动结束，已经给如下朋友发出邮件（按评论所留邮箱），请按要求于2月28日中午前提供收货地址。prcgolf 补习生 心如新入 Baldur Rockey 蠢蛋小丑鱼
春节前收到一份有意思的礼物——牙膏+牙刷+杯子。
有意思，是因为：
（1）此前深刻感悟：日常实用之物为礼，每次都能睹物思人，感情效率极高。
（2）曾对蜂产品比较了解，所以，见到propolis （蜂胶）自动脑补了很多信息。
（3）2015回顾，我最满意的新硬件就是电动牙刷（爱妻所赠），远超小米手环。
后面聊天才得知，赠礼的朋友在「爱牙」工作。「爱牙」是一款集牙齿健康问题免费在线咨询牙医、实时预约牙科看牙、牙友互动交流和口腔护理用品一站式购买等众多功能于一身的牙齿健康管理 APP。就此创业项目，我认为，在牙齿健康方面，国内还有极大增长空间。而此种消费，很适合订阅模式。而用户在知识、用品选择上，也非常需要可信的推荐精选、新鲜尝试。只是我并没有试用 app，感觉从网站切入，远比app 要轻便很多。
更多礼物来了！朋友说，也愿意给善用佳软的其他朋友们，也提供一些福利。我认为是好事，并思考了「软件」博客，与牙齿这款「硬件」的关系。
先想起老子。我的记忆中，关于软硬之辩，最早源于《道德经》，比如“柔弱胜刚强” “天下之至柔，驰骋天下之至坚”。甚至，也产生了最早的心灵鸡汤，传说孔子拜访老子时，老子曾经让他看自己的牙——差不多掉光了；再看舌头——完好无损；所以，柔弱胜刚强。今天的苏州金鸡湖畔，还有一尊如此场景的刚柔之道老子像，露仅有的一颗门牙，吐出长长的舌头，受到网友吐嘈。
又想起鲁迅。年前在读许寿裳所著《鲁迅传》；春节期间到绍兴，参观了先生故居；回来后整理补充了故居族谱中未显示的部分（xbeta 整理的鲁迅族谱）。毛泽东曾称“鲁迅的骨头是最硬的”，这当然是指“没有丝毫的奴颜和媚骨”的精神品质，而非生理意义。因为骨头最硬的鲁迅先生，自己及父亲曾经饱受牙病困扰。1925年先生在《从胡须说到牙齿》中称，“我从小就是牙痛党之一”。1930年3月，因左联及自己被通缉严压，49岁的鲁迅焦愤上火、牙齿肿痛，最后拔去全部牙齿，改以假牙。
鲁迅先生的名字，很容易令人联想起一句古话：一年树谷，十年树木，百年树人。而我又联想到近人的话：想一年领先，可每天多工作一小时；想十年领先，可每天多学习一小时；想一生领先，请每天多锻炼一小时。
锻炼一小时太难，那就从更容易的爱牙 10 分钟做起吧。
珍爱牙齿，用心留言，就有机会收到 爱牙 app 送出的惊喜（名额有限）。
Who Will Write My Essay For Me Thank god for thousands of viruses incessantly caused him college paperweights Our name of truehearted reversive customers whobuy essaysof the highest timbre from us is getting yearner day by day. Buy Sociology Essays Online Secure Hua had demonstrated so rapidly that in the close an with-it, outside
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>95</docid>
    <url>https://xbeta.info/irfanview-v441.htm</url>
    <title>顶级免费看图软件IrfanView v4.41发布：提供平板UI</title>
    <content>顶级免费看图软件 IrfanView 升级到 v4.41，加强了对平板电脑的支持。推荐平板用户尝试、反馈。现翻译其版本更新日志，以示支持。  [下载IrfanView 4.41]
IrfanView 4.41（2015-11-29发布，xbeta译）
64位版本：如果64位扫描驱动未安装，自动改用32位驱动。
为平板电脑设计的新对话框/图形界面。
新热键：shift+tab 用来启动/结束平板模式的对话框。
新热键：ctrl+insert：复制
新热键：Q 暂停/继续，用于定时翻页的幻灯播放
新命令行参数：写入到csv文件: /info=infofile.csv
安装插件的新参数：/silent 静默安装， /folder 指定目录。详见 FAQ。
移除了&#8221;Amazon 1Button App&#8221;。
修正其他bug（自动颜色校正；PNG压缩；64位路径）

Version 4.41 ( &#8211; CURRENT VERSION &#8211; ) (Release date: 2015-11-29)
64-bit version: Use 32-bit TWAIN drivers if 64-bit drivers not installed
New dialog/GUI on Windows tablets (&#8220;2 in 1&#8221;, Thanks to Arun Anbu from Intel)
New hotkey: SHIFT + Tab: Start/End Tablet mode dialog
New hotkey: CTRL + Insert: Edit-&gt;Copy
New Slideshow hotkey: Q = Pause/Resume a timer slideshow
New option for /info command line: write CSV file: /info=infofile.csv
Added PlugIns-Installer options for: /silent and /folder (Check FAQs page)
&#8220;Amazon 1Button App&#8221; offer removed
Some fixes (Auto color correction, PNG compression, UNC-Paths in 64-bit)
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>96</docid>
    <url>https://xbeta.info/wechat.htm</url>
    <title>欢迎加入微信：一些准备工作</title>
    <content>因工作繁忙，本博客更新日益减少。
微博更新相对多一些：@善用佳软  http://weibo.com/xbeta
微信公众号（扫码添加）偶尔会写一些内容。
关注微信公众号之后，也可以按操作找朋友拉入微信群：xbeta微信试验群 ——如何使用，还没想好  。加入后保先持沉默即可，不用打招呼。反正我不太聊天。

-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>97</docid>
    <url>https://xbeta.info/ditto.htm</url>
    <title>Ditto:首选的剪贴板增强软件（更新）</title>
    <content>注重效率的用户都喜欢剪贴板增强软件[1]。早期，我推荐免费小巧的 ClipX 和 CLCL 。而最近几年，善用佳软明确推荐：Ditto 是最好的免费剪贴板增强软件，是提高效率的首选方案。
目录：
一、Ditto简介
二、界面展示
三、Ditto 亮点与不足
1. 搜索
2. 合并粘贴
3. 纯文本粘贴
4. 基于永久条目的命名粘贴（推荐）
5. 网络分享
6. 文件回收站
7. 支持主题
8. Ditto的不足之处
四、Ditto使用指南：入门篇
1. 下载与安装
2. 使用中文语言
3. 中文字体设定（重要）
4. 开始使用：复制/粘贴
五、Ditto使用指南：进阶篇（待补）
六、常见问题（Ditto FAQ）
附录
总体内容亦可参见下图：

一、Ditto简介　　[返回目录]
Ditto 是一款开源、免费、强大的剪贴板增强工具。可以把复制过的所有内容保存起来（可以设定保存日期或条目总数），快捷地供后续调用。还可以合并粘贴，纯文本粘贴，支持分组、置顶、快速搜索、热键粘贴功能。并且，还可以通过网络共享剪贴板内容。
主页：http://ditto-cp.sourceforge.net/
教程：http://xbeta.info/ditto.htm
最新语言包：http://jianguoyun.com/p/DUxYPEIQpvLnBRi1-A0 （比官方语言包翻译更完整，且优化了alt热键。2015-09）
二、界面展示　　[返回目录]
平常情况下，Ditto只是系统托盘中的图标。按下热键（默认 ctrl+`）后，会出现的粘贴主界面；再点击右键会弹出功能丰富的菜单。参见下图：

通过其较为复杂的设置界面，你可以间接了解，Ditto的功能是如何丰富。参见flash（566&#215;498，60+KB）：

三、Ditto 亮点与不足　　[返回目录]
我最看重的优点有：搜索、合并、命名粘贴。
1. 搜索
Ditto中可以保留大量（取决于数据库容量）的历史记录。如果想搜索某条记录，只须在主界面的搜索框中输入文字，过滤后的结果会实时展现出来。
说明：
&#8211; 实时过滤的方式，比传统的“搜索词→回车→搜索结果列表”更为易用。
&#8211; 支持中文。
&#8211; 早期中文显示会旋转90°，新版已经修复。
&#8211; 并非对每条记录的“全文”进行搜索，而是前N个字符，这是为了搜索效率。[2]
2. 合并粘贴
Ditto允许合并粘贴，就是把多条记录，一次性粘贴到目标窗口。在收集资料时，这点尤其有用。
使用方法：弹出窗口中，按住Shift或Ctrl再点击鼠标左键。
3. 纯文本粘贴　　[返回目录]
如果复制了带格式文本（比如，来自网页、office文件），默认是带格式粘贴，但 Shift+Enter 表示纯文本粘贴。
以前很多人还要通过记事本中转来消除格式，有了Ditto后，一切简单了。
4. 快捷粘贴
经常有一些内容需要重复使用。比如，电话号码、邮箱、公司地址…… 。这些信息可以通过输入法实现，也可以用剪贴板工具实现。
早期Ditto 有一项非常强大的功能——命名粘贴（Named Paste）。很多用户（包括我）是此功能的粉丝，但开发者自己对此功能并不喜欢，在2010年12月23日发布的 v3.17.0.17 版本中，取消了该功能的热键。受到了很多用户的反对。尽管作者声称，也可以按照用户呼吁恢复此热键，但迄今为止，此功能仍然缺失。
快速粘贴的基本原理是这样的：首先，某些复制的条目要设置为“不自动删除”，防止过期后自动清理。其次，要为它们提供快捷调用方式。和其他剪贴板工具一样，Ditto也支持设置全局热键、鼠标调用。但条目数量较多后，用类似“缩写输入”的方式更为有效。而新旧版的差异，在于调用“缩写输入”的方式变化。
使用步骤举例：
&#8211; 在任何程序中打出一段常用文本，比如“——善用佳软，免费软件义工”。
&#8211; 选中，复制。
&#8211; 进入 Ditto，选中此条目：右键→“属性” 或 直接按下 Alt+Enter。
&#8211; 在如下界面中，设定此条目为“不自动删除”（因为是常用文本）；Quick Paste Text 为“x1”（就是设定缩写）；热键和组也十分有用，但此处暂且略过。确定，保存。

&#8211; 要使用这一条目时，早期操作如下：进入任一程序（比如记事本）。按下热键win+v（取决于你的设定，上述演示flash中设定为win+v），会弹出一个窗口，“Ditto-给粘贴指定”，这时输入“x1”——不要引号，不用在意显示的大写。奇迹就发生了：“——善用佳软，免费软件义工”自动上屏。
&#8211; 而目前的做法只能是：按下普通的热键（默认ctrl+`）显示Ditto主界面，在查询框键入 『\q x1』 ，然后回车。相比之前要多输入『tab \q 空格』。
取消命名粘贴后，此功能近乎鸡肋。完全可以不使用 quick paste text，而通过修改 title 来实现。比如在常用的条目title中加一个 cy 表示常用，然后，在搜索时除一般关键词再增加 cy 即可。
对于要求最高的快捷上屏条目，建议改用条目属性中的热键实现。比如上屏中指定了x键，则按下 Ditto 主热键后，再按 x 可实现文字上屏。这里的条目热键，既可以定义单键，也可以定义 ctrl-x, ctrl-shift-x 这样的组合键。
需要说明的是，快速粘贴常用条目的功能，可以理解为输入法、常用文本输入工具。但Ditto比通常工具更为强大的是，它能输入的不仅是一个“词条”，而可以是“多行文本、带格式的文本、图片和文件”。
&nbsp;
5. 网络分享
即一个组内，多人共享剪贴板。暂从略。
6. 文件回收站
这是一个变通应用。但是，软件的变通应用非常重要！
如果你 ctrl+x 方式把一个文件删除了，过后又想恢复，就可通过Ditto的历史记录来实现。
7. 支持主题　　[返回目录]
我虽然自己喜欢简近乎陋的界面，并且主张软件是拿来用的，不是拿来欣赏的。但很多网友对美化、DIY有一些需求，而 Ditto 是支持更换主题（themes）的，可参见 http://ditto-cp.wiki.sourceforge.net/Current+Themes 。
8. Ditto的不足之处
顺序粘贴：和大多数免费剪贴板软件一样，Ditto也缺乏“顺序粘贴” 或 “强力粘贴”功能。有需求者，可参照 Hamsin Clipboard 顺序粘贴功能 进行试用。支持此功能的免费软件，目前只发现 Hamsin Clipboard 一款。”
四、Ditto使用指南：入门篇　　[返回目录]
1. 下载与安装
好的下载习惯是到官方网站，这样可以得到最新、安全的软件。Ditto官网 首页上，有多个下载链接：区分了32位和64位版本，区分了便携版与安装版。
有网友反映，便携版遇到过Ditto窗口背后的程序无法操作的问题（鸣谢 dexter，2015-09），而安装版则无此问题。
2. 使用中文语言
下载包中，已经包含了简体中文语言文件 &#8230;\Ditto\Language\Chinese.xml 。但该语言包过于陈旧，请使用本文开头提供的链接，由我补充翻译。某些内容仍为英文，原因是开发者未提供这些文字对应的翻译资源。

为了精简，可删除多余的语言文件，只保留简体中文和English。
3. 中文字体设定（最新版已经不需要）　　[返回目录]
　　早期版本有如下bug，最新版本已经修复。
问题一：主界面字体太小，汉字躺倒显示。
解决方法：请修改字体（如下图）。

第1：改用合适的字号。
第2：字体选择“宋体”等，不要选择“@宋体”这样的（@ 表示横向字体）。
第3：保存设定，重启Ditto。
问题二：经过上述设置后，搜索框键入的字体是躺倒的，如下图。

解决方法：
方法1：和善用佳软一样，无视之。
方法2：chen bin 网友提供修了bug改版。『这里是重新编译的ditto (unicode版本)，修复了中文字体躺倒的问题。https://files.getdropbox.com/u/858862/Ditto.exe (提示:从非官方网站下载的版本,例如我的版本,可能中毒,感染木马,风险自负)』
方法3：暂时忍受，待官方修复版。热心的 chen bin 网友已经提交bug报告和修复，见 https://sourceforge.net/forum/forum.php?thread_id=3313122&amp;forum_id=287511 。
4. 开始使用：复制/粘贴
复制……复制……复制……到需要粘贴的程序中，按下热键（默认 Ctrl+`），在弹出的条目列表上，按下对应数字，或用鼠标点击所需条目，相应内容就粘贴好了。
五、Ditto使用指南：进阶篇（待完善）
Ditto v3.16.8.0 新增了如下功能：按下热键（默认ctrl+`）后，弹出ditto剪贴条目列表，此时不要放开ctrl键，可以：
&#8211; 继续键入`移动光标，至合适条目放开，则此条目上屏。（适用于v3.16.8.0）
&#8211; 键入数字，直接第N条上屏。（v3.16.8.0之前或许有效）
六、常见问题（Ditto FAQ）　　[返回目录]
问：在 cmd 或 gvim.exe 等程序中，Ditto无法粘贴？(Custom key strokes)
答：这是因为你用了免安装版，缺少了某些配置。手工修改注册表，或用重新安装 Ditto 可以修复。
原理是这样的：正常情况下，在 Ditto 中双击某一条目后，Ditto 会首先把此内容放在windows粘贴板，然后，向目标程序发送模拟按键 Ctrl+V。这样大家就清楚了，因为在 cmd 或 gvim.exe 中，Ctrl+v 并不是粘贴。有鉴于此，Ditto 提供了个性化按键的配置方法（参见 Ditto-clip\Help\DittoCustomKeys.htm）。
就是在注册表的 [HKEY_CURRENT_USER\Software\Ditto] 项下，新建三组键值，分别个性化“复制”“剪切”“粘贴”功能。当然，最主要的是“粘贴”。安装版 Ditto 会默认添加对gvim.exe 和 cmd 的支持，参见下图：

上图表示，在 cmd 中，ditto 发送“% {Delay100}ep”，即先按下“alt+空格”（弹出菜单），延时100毫秒，再按下e（编辑）p（粘贴）。这样，就在cmd中实现了粘贴。参见下图：

同理，gvim.exe 中的粘贴采用了 &#8220;+gP 的按键。
需要注意的是，模拟按键时，一定要避免处于中文输入法状态。另外，还要注意上述设定对应的是 gvim 的 normal 状态，而不是插入状态。
问：粘贴图片或带格式文字时，输出的格式有错误？
答：此问题是关于剪贴板格式的，Ditto有相关配置。参见下面的两个例子。
例1：“貌似在第二次粘贴带有图片的内容时会直接变成纯文本！？” “找到了解决方法：在选项里有个支持的类型，选上里面的html 和其他rich text 等等，就可以了。”
例2：“似乎还不够完美,我复制的动态gif图像通过Ditto粘贴出来变成静态的了,复制的透明背景的png粘贴出来也成了黑色背景色~不知该如何解决?” 【善用佳软：剪贴板相当于是一个动态多格式混合体，而保存和调用时，需要支持某种特定格式才可以。出于效率，默认情况下Ditto仅支持少数主要格式，所以，出现了上述情况。“选项”→“支持的类型”→“添加”相关类型即可。具体上述问题需要何种格式，不是很清楚（你也可以逐一尝试），但我添加全部格式后，至少透明背景动态gif是支持的。】“试过了,gif如果与文本混排可以通过HTML方式粘贴出来而不改变图像格式,但如果是单张gif图像就只能以CF_DIB类型粘贴为png图像。”
问：删除条目太慢？
答：最新的 Ditto v3.17.0.17 已经修复删除条目太慢的问题。
（正文完）

附录　　[返回目录]
附录：注释
[1]：更多同类软件参见 http://xbeta.info/clipx-clcl-ditto.htm
[2]: 过滤框的快速搜索，严格说来，并不是搜索“剪贴板条目”本身，而是搜索此条目的“描述（Description）”。Ditto 选项中，General 下 有一条 Amount of text to save for description ，就是设定把剪贴板内容的前多少个字符当作描述。默认值是 500 。在 官方帮助 中也提到：Every Clip also has a Description that is extracted from the beginning of the Clip’s CF_TEXT Format. The Description is used to represent the Clip in Ditto’s list and is searchable using the Filter Box。明白这一点，对Ditto的应用有如下几点指导意义：　　① 搜索（称过滤更准确）并非全文。所以，某些时候认为有相应条目但搜不到，请考虑一下，是否关键字在剪贴内容的前N个字符以外。　　② 描述可以手工修改，可以与剪贴内容不同。举例来说，“唵嘛呢叭咪吽” “897932384626”“10311019491001123”“http://www.ghisler.com/”这样的剪贴内容不容易通过搜索调用，但如果把描述改为“六字大明咒”“圆周率N位”“身份证号”“tc website”，就容易搜索得多了。变通使用，也可提高安全性。
附录：文章更新历史
2015-09-21：重写很多文字，更易读；更新了新版本的特性；推荐安装版（感谢dexter）。
2011-01-13：新版弱化了命名粘贴功能，本文给出新的推荐做法；补充新版修复删除条目速度过慢的问题。感谢sandox。
2009-09-26：增加注释 [2]。
2009-07-15：增加目录。
2009-06-29：增加 FAQ 之格式；修改“命名粘贴”；补充缺点。
2009-06-28：重写 FAQ 之 Custom key strokes 部分。
2009-06-25：增加了入门篇和FAQ部分内容。
2009-06-24：初稿，未完稿。

-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>98</docid>
    <url>https://xbeta.info/clipx-clcl-ditto.htm</url>
    <title>剪贴板增强软件综述:CLCL,ClipX,Ditto等（更新CLCL v2.0）</title>
    <content>剪贴板是一个伟大的创新。它让跨程序、跨文档传递数据变得前所未有的轻松，让 Ctrl+C、Ctrl+V （或Ctrl+Insert、Shift+Insert）成为最常用的快捷键。但是，windows 自身的剪贴板管理功能太弱（只能容纳一条记录），远不足以发挥剪贴板的真正功能。于是，世界各地的程序员开发了上百种增强工具，来“升级”剪贴板。
如何从中选择最合适的一款呢？如果你愿意支付 35 usd 的注册费，并且愿意承受庞大的体积，不会因为众多功能而困惑，你可以选择最经典（但现在过于臃肿）的 ClipMate。但是，我并不推荐一般用户这样做。因为这个世界上还有很多优秀免费软件可供选择。其中最优秀的 3 款，都体积小巧，运行快速，使用方便——这就是善用佳软推荐的 Ditto、CLCL、ClipX。我自己长期使用的，是 Ditto。
一、概述
本部分待整理
各款软件的差异：
普遍性的差异：不同的剪贴板增强软件，除了体积大小、占用资源多少方面的差距
剪贴板功能方面：
强化思路方面：
数量、格式（图/文/文件）、临时vs管理，内存
共享，存储，合并，导出
强化思路：输入：历史，多个（软件，vim）。输出：转格式、合并、自动化
这类软件的基本功能：

支持多个剪贴板，数量可以自己设定。我常用9个（好处是可以按数字键调用）。
不仅支持文本，也支持图片。没有其他工具时，可以兼职用作图片收集器。(注:复制图象，和复制一个图像文件是不一样的)
热键操作方便。多次Ctrl+C后，到要粘贴的地方，CLCL按Alt+C再按数字或用鼠标选中适当的条目即可。ClipX的呼出热键可自定义。
关机后剪贴内容不消失。
支持固定内容（模板）作为剪贴板条目，比如常用的信息（地址、签名档、电话、Email等）
顺序粘贴真方便。比如要填一个表格，有8个字段。用CLCL的方式是：先清空历史，把8条内容依次复制。到第一个空处，按Alt+C 8，就把第一条（因为最先复制，所以被后面的7条新内容挤到了第8位）粘贴了；再到第二个空处，仍按Alt+C 8（因为原第8位的被应用后，排到了第一位，其他顺延），第2条就上屏了。这样，实际上实现了依次粘贴的功能。

二、CLCL、ClipX、Ditto：三强详介
CLCL、ClipX、Ditto是三款最实用的软件。追求资源节约、易用的用户，可以选择 CLCL 和 ClipX；追求功能多，存储数据量大的用户，则可选择 Ditto。详细介绍如下。
(1) CLCL：Alt+C呼出真方便
CLCL 是一款强大、小巧、绿色、免费、开源、日本出品的免费剪贴板增强工具。
官网（日文、英文）：http://www.nakka.com/soft/clcl/index_eng.html
最新版本：v2.0，2015-09-05
汉化版（旧版）：http://www.hanzify.org/index.php?Go=Show::List&amp;ID=7712


支持丰富的剪贴板格式：纯文本、Unicode文本、RTF富文本、位图……
热键 &#8220;Alt+C&#8221; 弹出剪贴列表菜单，非常方便。然后就可以用鼠标选择条目，或者按数字键选择条目。
自定义“模板”：

模板的作用，就是把常用内容保存为固定条目，可以是纯文本（比如地址、电话）、图片（比如图像文件）。
模板可以新建，也可以把已经采集到剪贴板的内容，直接设定为模板
模板可以按文件夹进行组织，可以设定名称（比如“我的手机号”）

模板支持热键调用：比如，F8，alt+F8，win+shift+u ……



能够设置忽略的窗口，比如不想把记事本的复制内容保存到CLCL中，可如下设定： 
可使用插件来扩展功能。官方提供了几款扩展，带有若干功能，但感觉比较鸡肋。下图展示了对文字添加&lt;tag&gt;标签，及变为小写的功能。
  
能够为每个窗口设置粘贴热键（没感觉有太大意义）
能够设置格式过滤。
丰富的选项：


(2) ClipX：占用内存更小
汉化下载｜原版下载｜主页｜
CLCL如此好，为什么还推荐ClipX？是因为

ClipX不比CLCL差（除了在Maxthon和其他一些IE外挂中不能用）
CLCL是日本产软件，一些用户会介意
ClipX占用内存更少（几百K。CLCL近2M）
ClipX支持Unicode——对一些用户，这一点很重要。（如下图所示。如果显示其他字符集不正确，很可能是显示所用的字体不支持Unicode，换一种应该就OK了）
ClipX可以通过菜单清除历史记录，比CLCL更方便。

下图：点击系统托盘区的 Clipx ，所显示的菜单。来自官网。

下图：在应用程序中使用 ClipX 的情况。来自官网。

下图：ClipX 的设置界面。善用佳软+ClipX汉化版+GIMP 制作。

(3) 于两者间选择
这些人用ClipX：

需Unicode的
对于日系软件有抵触心理的（其实不必）
喜欢一个exe，不要dll的（CLCL运行并不要dll，但设置时需要）
喜欢内存占用更少的

这些人用CLCL：

经常向Maxthon中贴入内容的（ClipX对IE外壳的部分浏览器扩展支持有问题）

另外，有意思的是，CLCL要插件才支持Unicode，ClipX直接支持；而CLCL直接支持固定条目（模板），但ClipX则要插件才能做到这点。
再一点，我认为 CLCL 的 Alt+C 按键很方便，但在 ClipX 中无法定义此键（呵呵，很有意思。因为在自定义界面上，按Alt+C，就响应了&amp;Cancel，即取消设置）。
好软件并非没有缺点，比如：CLCL如果能直接在菜单上清除某些条目、把所有历史合并（代替文本收集器之类的小工具）就更好用了。
(4) 最推荐：开源的 Ditto
【说明】关于Ditto，请详见 http://xbeta.info/ditto.htm，下文不再更新：
上述两款软件均为免费，而 Ditto 则属于开源软件，即懂编程的朋友可以修改它的源代码，让它更符合自己的需求。
相对于前2款，它的特点是可以存放更多剪贴板记录，并通过滚动条来翻查，或者输入部分内容进行匹配。另外，它还可以在局域网内共享剪贴板内容。
&#8211; 到主页下载，这是便携版 (zip file，1+MB)
&#8211; 如果喜欢不同的视觉效果，可下载主题
&#8211; 如果需要其他语言文件（xml格式）（下载包已含简体中文），可在主页下载，存放于Language目录。为了精简，可删除多余的语言文件，只保留简体中文和English。
&#8211; 这样设置为中文。

&#8211; 默认情况下，字体太小，且中文躺倒显示，请修改字体（如下图），然后重启 Ditto。

&#8211; 但是，搜索框中的中文字体无法设定（仍保持躺倒方向），暂时忍受一下吧。
从使用来看，有3种使用方式：
&#8211; 极度频繁使用时，可以设为窗口总处于顶层
&#8211; 少数条目频繁使用时，可设定启用 ctrl+0~ctrl+9 快捷键
&#8211; 通常情况下，通过热键 Ctrl+` 调用
3款推荐软件的内存占用情况：

四、以下这些软件也不错
1. Hamsin Clipboard v3.03
免费的剪贴板增强软件Hamsin Clipboard v3.03 ，除了体积非常小巧（100KB，1exe）外，最大优点是支持顺序粘贴，缺点是历史条目固定为10条。

顺序粘贴（Incremental paste）使用方法：
尽管作者自称软件非常易用，但此功能的设计、文字说明，对用户都不友好，故做如下说明。关键点是“先激活Incremental paste，再复制” 。如果先复制，再激活，是无效的。
1、清空：考虑到只能存储10条剪贴历史，请先清空历史（右键菜单&#8211;special&#8211;clear history，默认热键win+del)
2、设定：激活 Incremental paste 选项。
3、复制：选中内容1，ctrl+c；选中内容2，ctrl+c……。
4、粘贴：到目标程序中，ctrl+v、ctrl+v……
由此可知，它的顺序粘贴（Incremental paste）相当于共享软件 ClipMate 的强力粘贴（power paste）的一半功能。所谓强力粘贴，或顺序粘贴，是指先多次ctrl+c，然后只管按下ctrl+v，先后复制的内容会依次粘贴过来。所谓一半功能，是指 Hamsin Clipboard 并不能对已经复制过的内容，进行顺序粘贴。而只能是先进入顺序粘贴模式，再多次复制，再多次ctrl+v，才会顺序粘贴。实际上，称为“临时顺序复制/粘贴”更准确。
从原理上，可以这样理解：Hamsin 的顺序粘贴，并不是对原有功能的增强（增强理解为乘法 [1]），而是增加的一个新功能（理解为加法）。进入此模式后，它会重新做一个序列记录，当你按下ctrl+v之后，自动加载下一条记录。并且，只能使用一次，如果要再使用，必须再依次ctrl+c。这与ClipMate可以对任意选中的记录，进行正/逆序的强力粘贴是有较大差距的。
但无论如何，Hamsin Clipboard 是唯一具备顺序粘贴功能的免费软件。【善用佳软/2009-12-08补充：Clipboard Magic 也支持。】

Incremental paste：官方相关说明
　　When &#8216;Incremental paste&#8217; option is on, several clips can be copied to the clipboard one after another and pasted in the same order (Actually, in this mode each clip is placed into the history only, whereas each pasting automatically places the next clip onto the clipboard for the next pasting operation).
另外，它从3.0版开始写注册表，以前配置记录于ini文件。除了顺序粘贴外，还支持 Win+数字键 直接粘贴内容、合并剪贴板、常用条目。支持很多格式，但历史条目仅包含10条，加多不行，减少也不行；只能以有限长度的文字显示已记录内容（不如CLCL那样可以在图标上显示图片格式内容的缩略图、可以在鼠标移到菜单的条目上时可以用工具提示显示全部内容）等。
2. ArsClip：多热键、分场景、支持表格模式（2010-07-08更新）
软件主页：http://www.joejoesoft.com/vcms/120/
最新版本： ArsClip v3.1.4，2010-07-06
性质：免费、开源（下载包含源代码）
最佳免费剪贴板增强工具是这样评价 ArsClip 的：在软件功能与简洁方面实现了较好的平衡。它和Clipomatic、ClipX一样小巧快速，又能记录更长的剪贴历史。它的聪明之处在于，记录全部历史， 但只显示一小部分。要显示另外一部分，需要再点一下按钮或菜单。它的历史记录也是可以搜索的。ArsClip 也支持永久条目，并且通过分组（比如论坛发文、邮件地址、签名档等）扩展了功能，在弹出菜单上分级显示。ArsClip 还提供了一键编辑内容的功能。它还有一大优点就是，ArsClip无须安装，可以运行在便携介质上，这样剪贴内容就可以永随身边。”
默认使用方法：
运行ArsClip后，照旧应用 Ctrl+X/C/V，按下 Ctrl+Shift+Z 会弹出菜单。
优点（*表示优于Ditto）：
永久条目支持快捷键，比如按下 ctrl+alt+x，一长串文字就可上屏。
* 有表格粘贴模式。
* 条目列表中，有来源程序的图标，便于识别。
支持图片。
支持Unicode。
* 条目操作有些快捷键：比如按住F1点击仅放发送到剪贴板。
* 可以针对不同程序，设定不同粘贴方式（如下图）。
* 永久条目组，可以针对不同程序。比如，让Email组仅在邮件程序中启用。
有搜索功能，但需要进入搜索界面，不如Ditto唤出后直接键入搜索方便；搜中文崩溃。

缺点（与Ditto相比）：
搜索不便；
无合并粘贴功能；
无命名粘贴。
ArsClip更多介绍： 《ArsClip：超強圖文剪貼簿》 by Dr.J.
Clipomatic
http://www.mlin.net/Clipomatic.shtml 很小啊很小，100KB级
clip magic
好象是freeware，小巧，安装文件 1.5MB。功能好象很强大 http://www.clipmagic.com/more.html 下载 http://www.clipmagic.com/software/cmsetup.exe
其他 Kana Clip（对剪贴内容进行加工）、Clipguru、Yankee Clipper 3、Freeclip也都是不错的软件。
四、相关软件
除了纯正的剪贴板增强软件，还有一些软件也具备相关功能。比如资料管理类软件，甚至是某些编辑器，都具有剪贴板监视功能。AutoHotkey 等脚本工具，也能实现类似功能。还有一些小工具，把选中文本发送到 notepad 等。（此部分未完成）
（正文完）
注释
[1]: 乘法与加法是一个重大区别。乘法是融会贯通，一通百通。而加法只是简单堆积。乘法的例子：Total Commander、Vim、Google 增加一项小功能后，这个小功能可以与以前的N个基本功能结合起来，效果提升非常明显。
文章更新历史
2015-09-07：CLCL从Ver 1.1.2更新到 Ver 2.0.0，重写本部分。
2012-02-14：说明Hamsin Clipboard 的顺序粘贴功能使用方法。
2010-07-08：重写ArsClip的介绍。
2009-08-21：重写 Hamsin Clipboard 的顺序粘贴功能。
2009-06-25：更新小标题及多处文字，突出 Hamsin Clipboard 的顺序粘贴功能。
2008-06-23：增加Ditto部分。
2005-09-09：初稿。
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>99</docid>
    <url>https://xbeta.info/rightnote.htm</url>
    <title>RightNote:让Evernote支持树状目录的经典桌面笔记软件</title>
    <content>2015-8-20更新：点击查看flash演示，内容：基本界面；设置项；与Evernote集成。
【善用佳软注】在我看来，Tranglos KeyNote 是笔记软件类的经典与鼻祖。而它的最佳继承者则是 RightNote。今天发现，RightNote 已经可与Evernote集成同步，让Evernote支持多层级结构。我非常赞赏这一特性，故志愿推广RightNote。以下内容摘自RightNote官网，感谢 Tingxun Shi、guestwind、封畅的翻译。
RightNote：更佳组织信息，让Evernote也支持树状笔记
RightNote 能帮助你免于信息过载。
它可以把海量的零散信息集中保存，并通过全局搜索，实时找到所需信息！
使用RightNote，你就能掌控信息碎片：知道如何存储，随时找到所需。
它拥有丰富的功能。
软件类型：免费版；标准版（$29.95）；专业版（$59.95）
最新版本：V3.31（2015-08-06）
下载链接：http://bauerapps.com/downloads/

二、RightNote特性
支持更多层级
每个 RightNote 笔记本，可包含无数个页面(page)；每个页面，可建立自己的树状笔记结构。用户在组织海量信息方面，具有极高的灵活性，和强大的功能。
处理不同类型的信息
RightNode的笔记可以有多种类型——文字处理、电子表格以及源代码类型。这允许你在单个笔记本中无缝囊括不同类型的信息。
Evernote同步——在云端存储笔记
可以把选中的笔记存储在Evernote并与之同步，这样你就可以从任何浏览器、移动设备或者操作系统上访问它们（仅限专业版）。
快速查找！
内置的全文搜索引擎允许你超快找到你想要的东西。没有复杂的搜索对话框——输入文字时，搜索结果即刻高亮！
保证安全
RightNote含有一种灵活的保护体系结构，允许你在任何笔记、树或者笔记本中，使用工业标准的128位加密安全地保护信息。
强大的web导入
RightNote的高级HTML粘贴功能，可准确导入网页中的图片、样式，使得导入的内容与原始网页高度一致。
高效
各种键盘快捷键、预定义的热键、预定义的文字和背景颜色，以及近期/经常使用的笔记列表，可更容易、更有效地处理常见的、重复性的任务。
让数据自由
强力的导入和导出选项，允许你从各种数据源导入数据；也可以把数据导出成常见的文件格式，如.txt, .rtf, .rvf, .html和.xls等。
可定制的界面
RightNote含有很多应用选项，允许你根据个人喜好定制界面。
程序便携
你可以随身携带你的重要信息。在任何电脑上插入优盘，并在其上运行程序即可，不会影响宿主电脑的设置。
免费版也足够强大
免费版包含大量与商业版共有的特性，可用在个人用途，亦可用在商业用途。
三、更高效地管理信息
把所有笔记存放在唯一的地方。当你遇到新的信息时，可立刻想到该放在何处。
可以在这里存储各种类型的信息。RightNote可以处理文本、html、财务数据、源代码、一般列表、待办事项列表、联系人列表等。
知道在何处找到你的信息。如果你把信息放在一处，你自然知道该去哪儿找！
高效的工作空间、工作流。让RightNode最小化在系统托盘图标中：需要时以全局热键呼出，不再使用时用esc将其最小化。
四、独特功能
文件夹树：使用新的“文件夹树”功能，轻松导航，管理含有大量节点的树。

自动添加标签：对于一个文件夹笔记，其所有子笔记自动获得父笔记的标注。这允许你把笔记组织和添加标签同时进行。

Evernote同步：Evernote同步功能允许你在任意移动设备、桌面或浏览器上访问选定的笔记（通过Evernote服务）

五、RightNote 注册与购买
购买后，我们会给你的邮箱发一封邮件，包括一个注册码（序列号），通过这个来解锁试用版，并允许你继续使用程序。注册用户在接下来12个月内，或下一个大的版本号升级之前（可能比12个月还长！）可以免费升级。通过MYCOMMERCE进行付款，它可以提供安全的交易处理功能。
六、各版本的功能比较
1、免费、标准、专业版的共有功能
&#8211; 支持的笔记类型
* 富文本笔记：支持基本的文本格式能力（如写字板）
* 源代码笔记：可以对大多数常见编程语言进行语法高亮
* 纯文本笔记
* 链接笔记类型：快速、容易的访问你硬盘上的相关文件
&#8211; 富文本笔记，包括一个预先定义的格式工具，以及文本高亮工具
&#8211; 即刻搜索：输入搜索内容，即可看到搜索结果
&#8211; 高亮的搜索结果：方便看到该看哪条搜索结果
&#8211; 新：文件夹笔记和文件夹树可以轻易在大的树中导航
&#8211; 新：自动添加标签：文件夹笔记和子笔记自动从文件夹标注中获取标签
&#8211; 笔记保护：使用工业标准的AES加密方法，加密选定笔记的内容
&#8211; 包含海量图标（用于树节点和标签），您也可以添加自己的图标
&#8211; 强大的标签系统，允许你通过不同方式对笔记节能型分类
&#8211; 可以给标签添加图标，这样树中的笔记可以高亮，分外突出
&#8211; 从常见格式的文件中导入笔记，可将笔记导出成常见格式的文件
&#8211; “最爱”工具条，可以快速访问常用文件
&#8211; 可以使用页面转换和浮动树工具，轻松在文件之间传输页面和笔记
&#8211; 截屏工具，可以把屏幕保存到你的笔记中
&#8211; 使用全局剪切热键，从其它应用中把文本剪切进RightNote
&#8211; 同时提供便携版（USB）和安装版
&#8211; 个人、商业均可使用
2、标准版、专业版增加的功能
&#8211; 富格式笔记类型：支持高级的文本编辑功能，包括多图像支持、高级表格支持、高级段落布局和格式调节、预定以文本和段落样式工具
&#8211; 拼写检查（对富格式笔记）
&#8211; 电子表格笔记类型：支持大多数excel函数、可以对列进行排序、填充命令、固定头部的行、合并/拆分单元格、单元格备注、单元格链接和图像
&#8211; 从MS Excel文件导入及导出
&#8211; 创建到其它笔记的链接（富格式笔记和电子表格笔记）
&#8211; 附件笔记类型 &#8211; 在一个RightNote数据库（文件）中存储文件的任何类型
&#8211; 高级剪切功能：对网页内容进行剪切可以保留格式和图像
&#8211; 新：分枝提升功能：把树的某个分枝提升，仅显示该部分，有助于注意力集中。
 3、RightNote 专业版增值功能
&#8211; 索引附件：txt, rtf, htm, html, pdf, doc, docx, csv, xls 和 xlsx 。
&#8211; 多笔记本搜索：同时搜索你的所有笔记本。
&#8211; 保存网页为网页类型的笔记。
&#8211; 并排视图：便于在不同页面（同一笔记本，或不同笔记本）间移动笔记。
&#8211; 新:Evernote 同步：全面支持所有的 Evernote 笔记元素，包括图片、checkboxes、锁定、附件。可通过任意移动设备、桌面 (Mac/Windows) 、浏览器访问同步的笔记。
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>100</docid>
    <url>https://xbeta.info/freewb-history.htm</url>
    <title>极点五笔完整更新历史: v1.0-v7.2内测版（2012-01-16）</title>
    <content>极点五笔是善用佳软使用超过10年的输入法。出于感激和对优秀软件的宣传，很希望为它做点事情。考虑到极点五笔没有官方的完整版本更新记录，特此整理如下，供极点爱好者参考。
相关链接：官网｜@心系极点｜非官方博客｜旧版下载｜五笔学习经验｜杜志民专访-1｜专访-2
官方介绍：极点五笔，全称为“极点中文汉字输入平台”，作者杜志民。 极点五笔输入法是一款免费的多功能五笔、拼音输入软件平台，同时完美支持一笔、二笔等各种以 a-z 为编码的“型码”、“音型码”。
我的评价：在善用佳软看来，极点五笔是后起之秀（相对于早期的五笔而言），却已成经典；它始终免费纯净，并且促使（迫使）另外几款五笔输入法也走向免费；它的作者无暇宣传，却有一大批粉丝积极（而不偏激）地推广；它功能丰富，却从来不让人感觉多余；它自定义能力极强，却依然稳定、快速、小巧；它简洁质朴，但拥有众多粉丝制作的各种词库、皮肤。并且，杜志民老师的人品也深为广大用户尊敬。“已所不欲，勿施于人；已所欲，勿强施于人”——很认同杜志民老师的这句话。能在学习五笔后不久接触到极点，我也感到很幸运。
鸣谢：以下信息源自极点官网、五笔爱好者论坛、维基百科，由xbeta整理。感谢dinosaurhxe、today等网友补充指正。
目前正式发布的最高版本为7.15十周年纪念版。论坛上流出的最高内测版为7.2内测版（2012-01-16）。目前，杜志民先生忙于工作、家庭，继续更新极点五笔的可能性很小。
一、简明版：极点五笔版本历史
2012-01-16，极点五笔7.2内测版，这是极点五笔的最高版本，但未正式发布，是内测网友在论坛上传的
2011-12-30，极点五笔7.15十周年纪念版发布，这是正式发布的最后版本
2010-08-09，极点五笔7.13版发布 （极点五笔官网信息似乎丢失过，恢复后停留在此版本）
2010-04-28，极点五笔7.12版发布
2009-08-07，极点五笔7.0 预览版
2009-??-??，极点五笔6.6正在准备中……
2009-02-09，极点五笔6.5版
2008-10-31，极点五笔6.4正式版
2008-09-20，极点五笔6.3版（标准版及便携版）发布
2008-06-12，极点五笔汶川地震纪念版
2007-11-11，极点6.1正式版（Unicode版）
2006-11-07，极点五笔Unicode第二测试版；
2006-10-23，极点五笔支持中日韩三国大字符集的Unicode测试版；
2006-03-18，极点五笔5.1版；
2005-12-25，极点五笔5.0正式版；
2005-10-01，极点五笔4.5SE（简体版）发布；
2005-08-23，极点五笔4.5《电脑商情报》专版；
2004-08-26，极点五笔4.0；
2003-12-31，极点五笔3.5；
2003-12-24，极点五笔“便携”版；
2003-06-22，极点五笔3.2；
2003-03-31，极点五笔3.1；
2003-02-01，五笔拼音输入法（极点前身）3.1；
2003-01-06，五笔拼音输入法3.01；
2002-12-14，五笔拼音输入法3.0beta2；
2002-11-25，五笔拼音输入法2.5；
2002-11-19，五笔拼音输入法2.4；
2002-11-15，五笔拼音2.3；
2002-11-03，五笔拼音2.0a；
2002-10-30，五笔拼音2.0beta6；
2002-09-16，五笔拼音1.8；
2002-08月底或9月初，五笔拼音1.7试用版在输入法论坛提供下载；
2001-09-10，五笔拼音1.0测试版供内部使用、测试。
二、详尽版：极点五笔更新历史
极点五笔7.2内测版（2012-01-16），通过论坛流出的，这是极点五笔的最高版本，但未正式发布
下载链接: http://pan.baidu.com/s/1qWsXWQg 密码: zuj4
使用方法：将下载的升级包解压到极点安装目录，覆盖同名文件。在极点没有使用的情况下运行registry.exe进行升级即可。
7.2内测版更新记录
2012年1月3日
1、修正64位系统下IE9中不能使用智能标点输入——和……问题。
2、修正删除一个逗号或句号后，接着输入逗号或句号删除前一个字符的问题。
3、修正联想提示框词组提示框不消失的问题。
2012年01月4日
1、修正标点配对中单字输入，系统提示词组后，回车换行的问题。
2012年1月9日
1、修正切换词库时不更新快捷码表问题。
2012年1月12
1、数字,数字,输入——的问题(“3，3，”输出的是“3，——”)3,3,3,3,3,3, 3 ，3,3,
2、Excel2010执行VBA后退出非法
3、状态栏自动缩展时显示多余图标的问题
4、微调候选窗的显示处理（刷新方式）
2012年1月15日
1、修正：切换到自动缩展皮肤时，皮肤处于扩展状态的问题。
2、完善：新造词后将系统词调到首位，再编辑用户词库后又跑到后面的问题。
2012年01月16日
1、恢复：查询及造词时自动判断是否为剪切板造词
2、完善：启用智能标点时，判断用户是否进行了鼠标定位操作，防止误输出
2011-12-30，极点五笔7.15十周年纪念版
本版主要是增强程序稳定性。
1.修正：使用极点造成应用软件异常退出的问题
2.修正：切换或编辑词库失效的问题
3.修正：在PE系统下无法注册的问题
4.修正：桌面上显示多个极点状态栏的问题
5.添加：候选窗鼠标划词查询功能
6.添加：智能标点功能
附：2011年对极点五笔所做的详细更新记录 [via]
2011年12月10日
修正：备份文件日期有误引起状态栏右键非法的问题
修正：自定义[元]后，数字转换不正确的问题
2011年12月5日
完善：Excel及WPS 电子表格标点配对功能
修正：IE页面内无法用键盘切换全半角/中英文的问题
完善：状态栏的显示与定位
2011年11月30日
1、修正：用鼠标打开极点后快捷键不能立即使用的问题
2、修正：在线调序未保存的问题
3、修正：www.转英文后不能用鼠标切回中文
4、修正：切换词库后状态栏未及时刷新
5、修正：多状态栏的问题
6、添加：日期0自定义功能[system]段零=[0]
7、完善：系统设置快捷键设置以中文键名显示
2011年11月20日
1、修正：极点设为默认输入法有时切换词库失败的问题
2011年11月8日
1、修正：重写词库的加载与卸载模块
2、添加：用复制内容造词快捷键：ctrl+alt+=
3、修正：精简状态栏菜单与系统设置项
2011年11月3日
1、修正：极点作为默认输入法无法切换词库的问题
2、完善：状态栏的定位与显示
2011年10月28日
1、修正：恢复词库与配置时，新配置未起作用的问题
2、修正：恢复极点原有配置文件管理方式
3、完善：鼠标查询提示窗
4、添加：剪切板查询快捷键：ctrl+alt+/
2011年10月21日
1、二笔中参与编码的标点无法顶字上屏
2、切换皮肤时，被关闭的极点再打开时皮肤未换
3、尝试解决某些软件中复制无响应
2011年10月6日
1、wps2012下候选窗越界问题
2、编码中有万能键时可输入第5码问题
3、鼠标查询结果显示
4、用户词组不受“全码出词”选项限制
5、;abc/会上屏的问题
6、词库加载的一个逻辑错
2011年9月23日
1、完善：简入繁出状态下鼠标取词查询
2、修正：简入繁出快捷键失效的问题
3、修正：多个程序使用极点，其中一个关掉极点后其他程序不出中文的问题
2011年9月22日
1、完善：词库切换流程
2、修正：用安装包安装时freeime.bin等文件打开错的问题
3、完善：微调状态栏菜单，添加了快捷命令帮助
4、完善：快捷命令的处理流程
2011年9月14日
1、完善：状态栏的显示（通过skin.ini中[状态栏2]项来自定义此状态栏哪些按钮不再显示）
2、添加：skin.ini中添加“显示提示信息&#8221;决定是否显示状态栏鼠标提示
2011年8月11日
1、修正：切换状态栏时未自动定位的问题
2、添加：快捷命令“pp.”进入专家设置模式
2011年8月10日
1、完善：恢复了状态栏自动缩展功能
2、添加：快捷命令“vv.”，用于显示极点版本号
3、完善：大写状态下标点强制为半角
4、完善：完善状态栏切换功能
5、完善：微调状态栏和候选窗提示信息的显示
2011年7月28日
1、完善：恢复了全角英文字母输出功能
2、完善：隐藏修改窗选项仅在当前软件中起作用的问题
3、完善：切换到没有图片皮肤，程序非法的问题
4、完善：自定义鼠标查询字体大小[system]::sztipToolC 及sztipToolS
2011年7月9日
1、修正：鼠标在状态栏上乱跳的问题
2、修正：临时生僻字状态，校对模式误上屏的问题
2011年7月3日
1、修正：编码n一直翻页后出错的问题
2、添加：自定义大写金额中“元”（专家设置模式中，在[system]下加一行：RMB=[圆]）
3、添加：标点配对切换键（可到图形设置模式中设置，默认为ctrl+del）
2011年6月28日
1、修正：状态栏位于屏幕4角无法显示提示的问题
2、修正：某些情况下空格选项亦上屏校对项的问题
2011年6月27日
1、完善：鼠标悬停提示遮挡候选窗时，鼠标移出悬停窗提示自动消失
2、修正：上版状态栏无法拖动的问题
2011年6月23日
1、完善：鼠标查询汉语拼音显示不清的问题
2011年6月20日
1、完善：状态栏提示信息及候选窗鼠标查询显示
2、完善：将版本号微调为7.15
2011年6月15日
1、完善：美化鼠标查询结果窗
2、添加：鼠标查询拓展插件（默认查询“极点汉语词典.db”，如果要查其他字典，请到“专家设置模式”中[system]段下添加一行：TiptoolDB=字典名称）
2011年6月13日
1、修正：传统候选窗不显示边框的问题
2、修正：某些软件中候选窗被遮挡的问题
3、修正：方形候选窗下鼠标查询功能在尾字上不执行的问题
2011年6月3日
1、完善：状态栏自动定位时，切换状态栏模式时定位异常的问题
2、添加：候选窗顶层显示（默认打开，如若关闭到专家设置模式中添加：CandShowOnTop=0）
2011年5月25日
1、完善：隐藏状态栏后再显示时跑到屏幕左上角问题
2、优化：检索速度
2011年5月19日
1、完善：所有类型的候选窗均支持鼠标查询拼音与编码
2、完善：所有类型的候选窗均支持鼠标选词
3、完善：registry.exe 加入/ns参数，在PE类系统上加快执行速度
2011年5月16日
1、完善：极点有时自动转到英文状态的问题
2、完善：状态栏提示信息的显隐方式
3、完善：恢复状态栏自动定位选项
2011年5月6日
1、使用极点时应用软件异常退出的问题
2、完善系统设置，在设置界面上提供实时帮助信息
3、完善：PE系统下registry.exe执行失败的问题
2011年4月18日
1、长时间使用极点出错
2、自定义软键盘“/”键不能输出的问题
2011年4月3日
1、Ctrl+-仅能删第一候选项的问题
2、Shift作中英文切换键时，Shift+！打开软键盘的问题
2011年3月28日
1、打开极点置为英文不起作用
2、shift、ctrl可不分左右设为中、英文切换键（到专家设置模式中将CN_EN项设为shift或ctrl即可）
3、自动组词出错时给出提示
2010-04-28：极点五笔7.12版
本版主要增强程序稳定性与兼容性，优化速度，修正已知问题，并完善使用说明与设置界面的实时帮助。建议所有极点用户更新到此版。
（xbeta注：无论从实时帮助、帮助文档、设置向导这些用户细节，还是对云端、64位等新情况的迎对，还是标点符号自动匹配功能，都能看出极点五笔永续的进步。）
具体修正内容如下：
2010年4月17日
1、添加：系统设置界面添加实时帮助了
2010年4月16日
1、添加：图形设置界面：标点自动配对输出选项
2、完善：有时状态栏显示&#8221;大写字母&#8221;后,再按capslock,capslock熄灭后,状态栏仍为&#8221;大写字母&#8221;
2010年4月15日
1、添加：标点符号自动配对功能 [system]::SmartSymbol=1。标点配对输出后，第一个回车相当于右方向键
2010年4月13日
1、修正：某些系统下候选窗无法隐藏并显示于桌面左上角的问题
2、修正：组字过程中隐藏状态栏，之后候选窗不显示的问题
2010年4月12日
1、修正：自定义标点后symbol.txt文件被删除的bug
2、完善：_固定输出“——”，如果定义到其他键上，输出“—”
3、添加：状态栏无法自动定位时，可选状态栏定位位置
4、完善：状态栏无故跑到左上角的问题
5、添加：skin.ini::[状态栏]添加“边距x”和“边距y”两个选项——状态栏不能自动定位时距屏幕的边距
2010年4月11日
1、修正：某些系统+特定皮肤备份非法的问题
2010年4月9日
1、完善：状态栏与候选窗的拖动显示
2、修正：切换皮肤后，如果原候选窗不跟随，则新候选窗首次不能正常定位
3、修正：二笔下编码;不起作用的问题
4、修正：启用背景图、不用边框时，左上角出黑线的问题
5、修正：云端中启用极点，windows中极点不可用的问题
2010年4月8日
1、完善：候选窗的拖动处理及跟随
2、修正：极点设为默认输入法DeamonLite无响应问题
3、修正：某些情况下，64位与32位程序同时使用时，不能输入中文的问题
2009-08-07：极点五笔7.0 预览版 下载地址
从极点6.5发布到现在半年多了，各种原因对极点无法像之前那样投入。感谢一直以来大家对极点的关注与帮助。这个版本只是经过内测网友的测试，故无法保证其100%运行顺利。如果有什么问题欢迎留言反馈。
极点五笔输入法 7.0预览版修改记录
1、添加了对win7的支持
2、添加了对X64的支持
3、修正由于词库损坏造成非法或丢单字的问题
4、可以，但不建议设为默认输入法
5、只要是候选窗上的词可以任意调频
6、每次批量加词数量理论上没有限制
7、根据登录用户自动切换设置
9、完善候选窗设置：同一皮肤中各类型候选窗选项可单独设置
待完善部分：
1、X64下的反查只能查拼音与编码
2、打包到别的机器上只能使用默认设置
&#8230;&#8230;&#8230;..
极点五笔v6.6（开发中……）
极点五笔v6.6正在研发中，目前已基本实现：
&#8211; 任意调频——以前只能全码且编码相同才能调
&#8211; 多用户的支持——根据登录用户自动选择配置文件
&#8211; 批量加词——不再限制容量
&#8211; 任意月、日录入——“;月.日”格式，“.”键上屏
&#8211; 编辑用户码表功能完善
&#8211; 支持x64操作系统及软件（更多……）
2009-02-09，极点五笔6.5版
1、修正：某些设置下输入编码非法的问题
2、完善：候选窗的定位与显示
3、添加：字根拆分提示插件（学习版）
4、添加：输入速度统计功能
5、完善：一些细节问题
2008-10-31，极点五笔6.4正式版
本版为极点6.3及其SP1的完整版，同时修正了以下内容：
1、完善：五笔拼音模式下临时生僻字的检索算法
2、完善：简入繁出功能
3、完善：自动调频时，zz系列也参与调频的问题
4、添加：切换皮肤快捷键
5、添加：候选项后自动添加空格快捷键
6、完善：选中 回车键编码上屏时 时对快捷英文等键的处理
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2008-09-21 极点五笔 6.3 SP1
1、修正：启用自动造词，而索引文件freeime.dat内容有误时，输入某些单字非法的问题
2、完善：启用全屏模式隐藏输入框功能——待确认
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2008-09-20 极点五笔 6.3
1、修正已知问题，增强程序的稳定性与兼容性
2、优化检索算法，提高反应速度
3、以《现代汉语（第五版）》为标准，整理了极点汉语词典，共收单字：24,450个、词组48,253组（新旧词典不能同时使用，仅标准版内含）
4、添加了笔画辅助输入功能（标准版）
5、完善编码反查，既提示单字全码，也提示简码
6、完善拼音输入功能，实现五笔拼音混合输入且拼音对五笔盲打几乎无影响，全拼、简拼、混拼任君选择（标准版），让您真正体会：行云输入，流水感觉
7、增加网络同步接口，供有需要或有能力开发用户使用
8、修正与完善其他细节问题
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2008-07-08 之后
小更新：设置界面改动了一点,主要的是设为默认时,word等其它地方支持剪贴板(涂黑)查询了
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2008-07-08日 极点五笔汶川地震纪念版SP1
安装本版极点请注意：如装有旧版极点，请注销或重启系统后再安装。
本版修正了地震纪念版发布以来发现的绝大多数问题，建议所有极点用户，特别是使用极点6和VISTA的用户升级到此版。
注：
1、不建议将极点设为默认输入法，如将极点设为默认，剪切板查询、造词功能会失效；
2、非方形候选窗某些情况下定位会有问题
3、游戏兼容性未完全测试
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2008-06-12 极点五笔汶川地震纪念版
1、自动转换旧版本词库，以后升级极点不用担心词库不兼容了：）
2、可直接编辑用户词组
3、优化算法，提高速度！
4、完善对VISTA下非管理员的用户的支持
5、完善简入繁出，并提供大五码输出功能
6、完善联想功能，不标记联想词组也能联想
7、状态栏可自动透明，增加显/隐候选窗快捷键
8、重新规划了状态栏右键菜单
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2007-11-11，极点6.1正式版（Unicode版）
增加的功能列表
1、添加快捷码表及在线编辑功能
2、重码上屏校对模式，适宜快速盲打录入后整篇校对
3、编码打开软键盘
4、shift选重码
5、连击中英文切换键（默认是右shift)打开软键盘
完善的功能列表
1、简入繁出全面超 越极点5，五笔与拼音同时支持一简对繁的显示与输出
2、根据人民日报词频完善了联想功能
3、词典在非简体系统下亦可正常使用
4、安装程序支持各种非简体系统
5、在WOW等游戏下Shift键粘滞的问题
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
极点五笔 5.2版 982K （日期未知：2007-12-31？）
因开发极点6，此版未曾公开发行。它修正了5.1版某些bug，是最后一个ansi版本。
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
极点五笔6.0 RC版（日期未知：2006-10-23？）
说明：
1、本版暂不支持简入繁出功能；
2、本版无法直接使用旧版词库（切记，用之前极点的词库，极5或极6的都会非法！！！），请安装到全新目录；
3、本版为测试版，请勿用于关键工作场合
4、时间、精力关系，本版主要做兼容性测试，功能方面的要求正式版不会再添加了。
相较宝宝出生纪念版，本版基本完成了以下功能：
1、自动词组
2、万能键
3、词组联想
4、提示系统已有词组
5、智能隐藏词组功能
6、维护词库的相关功能
7、打字音效
8、系统配置与词库的备份与恢复
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2006-03-18，极点五笔5.1版；
注：最后一个公开发布、支持win95和Win98的版本，从极点6开始只支持Win2000及以上的版本的Windows。
1、在迷迷糊糊的帮助下完善了候选窗的跟随
2、解决了魔兽下启用词组联想会造成丢键的问题
3、优化极点的检索效能
4、彻底解决了guest用户无法使用极点的问题
5、完善了极点在使用中的安装与卸载
6、采用了wozy 4.3版为基础，集一剑、海峰和物理之大成的4精词库
7、更便利的系统设置，符号与设置向普通输入习惯靠拢
8、重新改写了皮肤架构，方便皮肤交流
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2005-12-25，极点五笔5.0正式版；
xbeta：感谢杜老师在极点5.0中更正了极点设置后VIM会崩溃的问题。
一、本次重要更新
1、第一个自带字典功能的输入法
2、第一个插件化的输入法
3、漂亮、实用的状态栏
4、命令直通车扩展了如下功能：
①$F输出本地文本功能；
②$P输出位置功能；（相应功能说明见极点5.0帮助）
③用编码：zzka、zzkb来打开相应软键盘功能；
④最小化桌面窗口：tray $xtray
⑤打开光驱：opencd $xopencd
⑥开关扬声器：mute $xmute
⑦极点目录变量：dirr $X[极点目录]%freewb%
5、增加打字音效功能。默认关闭，高级设置中设置，关闭时不占资源；
6、更漂亮、更实用的状态栏。极点对状态栏皮肤进行了进一步的扩展，具收缩、扩展两种状态，更漂亮、更实用，输入法的各种状态与常用功能一目了然。
7、进一步优化检索算法，既减少了资源占用，并同时提高的检索速度。
8、修正了此前版本中发现的各种问题，特别是启用扬声器报警非法等关键性错误，同时也完善了音箱报警功能，用户可以自定义空码与重码所用报警声音文件。
提示：极点5.0的状态条作了重大改进，原来4.5版的状态条已经不适用了。如果覆盖安装的，建议在“输入法设置→界面设置→状态条设置”中选择新版的IPurple.ini状态条。当然，选择4.4及以前的版本的简单状态条也行。
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
2005-10-01，极点五笔4.5SE（简体版）发布；
注：极点第二个成熟、稳定版本，也是极点的第一个成熟平台版本。
本版主要修正了一些细节问题，对设置做了一定的调整，并添加了“临时GBK”功能。
1、全面调整设置界面。对设置的功能选项力求简洁与便捷，使极点的新用户能够获得更好地易上手性。将一部分设置功能转移到高级设置中，为方便高级用户，改进了码表用户码表的格式，增加查找选项。
2、“临时GBK”。默认快捷键为“]”,此功能类似于极点的临时拼音功能。在GB2312下启动临时GBK后，检索范围为GBK单字，输出GBK单字上屏后自动切换回GB2312状态。
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
发布: 极点4.5
1、可以自定义极点的绝大部分快捷键
2、通过编码调用windows的一些常用功能：如浏览指定网址、打开我的电脑、我的文件夹或打开指定文件等。
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
发布: 极点五笔4.3正式版 (5月11日更新)
一、本次重要更新
本版主要修正了上个公测版的一些细节问题并根据潜龙勿用网友和Ahaman先生的建议添加了“命令直通车”功能。
1、命令直通车格式可以定义为“$X[说明]命令”，录入时仅显示“说明”部分。如码表中加入： wubi $X[五笔论坛]/bbs/，输入时候选窗显示为：[五笔论坛]
2、短文标签功能(不支持普通词组)。可以防止候选窗显示过长。如码表中加入： dwja [春晓]【春晓】$13$13$20$20$20$20$13春眠不觉晓，$13处处闻啼鸟；$13夜来风雨声，$13花落知多少。 　　输入时候选窗显示为：[春晓]
二、详细更新记录
5月9日 *修正：临拼时不检索单字的问题 *完善：命令直通车格式可以定义为“$X[说明]命令”，录入时仅显示“说明”部分
2005年5月5日22时36分更新： *完善：windows登录窗下禁用“命令直通车”功能 *完善：Windows接口命令仅定义在用户码表中有效 2005年5月1日更新 *完善$X功能，本版开始支持文件名和路径参数（^ 和#)。 如：①$Xcmd#d:tools 则在打开CMD窗口的同时并进入到d:tools目录中 ②$Xnotepad^c:test.txt 则用打开记事本c:test.txt文件
2005.4.30更新 *修正：命令功能支持文件路径中空格，用$20表示
2005.4.28更新 *自动词组最大长度20 *添加:支持用户词库中加入文件路径打开命令$x 和$X,x表示后面，X表示前台例如：abcd $xC:文件唐诗蜀道难.txt mydoc $Xc:document$20and$settingsxxxxMy$documents等
2003.4.25更新 *修正:部分快捷键设置没有禁止选项 2003.4.24更新 *修正:五笔拼音下拼音重码调频的问题 *修正:临拼下自动调频的问题
2003.4.23更新 *修正：词组中包括空格或回车时无法在线调频的问题 *修正：临拼可以选用Fx系列快捷键
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
发布: 极点4.2 2005-03-08
1、修正了公测版发现的一些细节问题,如：
①快捷英文下，如果录入的是快捷命令给出提示
②屏幕取词与查询的处理方式,不再执行清空剪切板的动作
③完善对状态栏显示代码段的处理
2、彻底解决win9x下无法使用系统设置的问题
3、完善输入法设置的在线帮助功能
4、添加了在线速度测试功能
5、添加了单字输出模式
6、“屏幕取词”：将屏幕上的内容复制到剪切板再按Ctrl+；
7、“屏幕查询”：将屏幕上的内容复制到剪切板再按Ctrl+?。如想复制查询结果按Ctrl+c
8、可以选择候选窗的字体及风格了
9、英文和大写字母状态下强制半角的选项等
10、词组最多可以包含512个汉字
11、完善静默安装及卸载等一些细节问题。
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
发布: 极点4 2004-08-26
今天极点两岁了！在过去的700多个日日夜夜里，极点得到了无数朋友的关心、帮助与支持。正是大家的帮助，也才使极点坚持并走了下来，也才有了今天极点4的诞生，在此感谢所有参与内测的朋友们！感谢你们对极点的支持与帮助！谢谢！也特别感谢LoveEB和npwjm等二笔朋友，极点4的平台特性等许多功能是在LoveEB的帮助下完成的，谢谢你们！
极点4虽然经过了长时间的内部测试和公开测试，但囿于我们的水平和软、硬件环境，它可能还会有这样或那样的问题，我们真心的欢迎您反馈您的使用意见与建议，使极点更加符合大家所需并为大家的工作带去一丝便利，这是我们最大的心愿！ 再次感谢所有一直帮助极点到深夜的朋友们！
——杜志民 2004年8月26日22时52分
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
发布: 极点3.5正式版 2003-12-31
注：极点第一个稳定、成熟版本。
下载请至极点主页：http://freewb.y365.com 发布的比较匆忙，附一下修改记录：
解决IE下第一个窗口被关闭后其他子窗口状态栏不跟随的问题。
暂屏蔽掉汉字候选窗顶层显示功能；12月30日
修正了退出IE查找框后，背景不加载及全半角标志不显示等问题；12月30日
将“使用旧式输入接口”改名为“游戏输入接口”并放到了freewb.ini中；12月29日
修正了切换到临时拼音状态后马上按BackSpace键会删已录入内容的问题；12月28日 .
修正了输出大写金额时，如果以“.”结尾数字被缩小10倍的问题；12月28日 .
修正了98下读取系统目录出错的问题；12月27日 .
完善了极点的出错处理机制,当极点安装目录不存在或有错时不再退出宿主程序 .重新改写了一下消息处理机制；2003-12-25
（完。文章最后更新于2015年8月18日）
-- http://xbeta.info　　( 6793ee6ca67cfacc9d4333d9ae43a11b)</content>
</doc><doc>
    <docid>101</docid>
    <url>http://www.portablesoft.org/emeditor-pro/</url>
    <title>EmEditor 16.1.3 简体中文便携版 - 强大文本编辑器</title>
    <content>EmEditor Professional 以运行轻巧、敏捷而又功能强大、丰富著称，作为简单好用的文本编辑器，EmEditor 支持多种配置，可自定义颜色、字体、工具栏、快捷键、行距等，支持文本列块选择、无限撤消/重做等，是替代记事本的最佳编辑器。
我最近一直在用 EmEditor，其便携性很适合影子系统，标签窗口也是极方便操作，2016/8/11 更新版本为 EmEditor 16.1.3 官方简体中文便携版，分别为 EmEditor 32 位和 64 位版。EmEditor 现已经添加了官方简体中文和繁体中文支持，无需额外汉化。
使用说明：解压后直接运行主程序 EmEditor.exe 即可，所有配置都保存在 ini 文件中，纯绿色便携，完全兼容 Windows 7/8 及 Portableapps.com 的便携平台，如果无法显示简体中文，可能需要重新配置。

记事本替代方面，曾经介绍过的 EditPlus 或 AptEdit 也都是不错的，不过我还是用着 EmEditor 最舒适了，还有 Notepad2 也是必须的。关于如何将 EmEditor 转变为便携软件，请看这里，或直接在 EmEditor.exe 目录下建立一个 eeUseIni.ini 文件，EmEditor 就会使用 ini 文件保存所有配置，达到绿色便携化运行。
EmEditor Professional is a fast, lightweight text editor designed to balance speed of operation with robust features.
New features in version 10 include a Compare function, which allows users to run a side by side comparison of two documents with Synchronized Scrolling, a Spell Check engine, Numbering, ASCII and Binary side by side viewing, and much more. EmEditor now fully supports Zen Coding.

EmEditor 16.1.3 更新日志：
修复了比较 CSV 文档或排序一个 CSV 文档时，EmEditor 会故障的 bug。修复了在 CSV 单元格模式下的增量搜索 bug。修复了其他 bug。EmEditor 会在显示另存为对话框之前自动保存未命名文档。如果在 CSV 单元格模式下，选取了多个单元格，当执行选择CSV列命令时，EmEditor 会选取多个列。修复了双击多个空格或 Tab 无法选择那些空格或 Tab 的 bug。修复了 IME 上内存泄漏的 bug。
EmEditor 相关文件下载
官方网站：zh-cn.emeditor.com
解压密码：www.portablesoft.org
压缩包MD5：F4D1A7E2430325056620A6FD9F8004FF
开始下载 EmEditor Portable 16.1.3 简体中文便携版 (32-bit, 32位版)
EmEditor_x86_16.1.3_PortableSoft.7z (2.41 MB)
@精品绿色便携软件 &#124; EmEditor 16.1.3 (32-bit) 下载页面 &#124; 更多版本下载
开始下载 EmEditor Portable 16.1.3 简体中文便携版 (64-bit, 64位版)
EmEditor_16.1.3_PortableSoft.7z (4.68 MB)
@精品绿色便携软件 &#124; EmEditor 16.1.3 (64-bit) 下载页面
特别说明：EmEditor 便携版没有集成任何注册码或其他注册信息，为「全功能试用版」，默认有 30 天的全功能试用期。试用期结束后，请考虑购买官方正版授权。如果还想继续试用的话，请给我发邮件至 admin@portablesoft.org 询问解决方案。


Related posts:
功能强大的文本编辑器：EditPlus汉化绿色便携版 
AptEdit绿色版：功能丰富的文本/HEX/HTML/程序编辑器 
通过映像劫持实现Notepad2替换记事本 
Notepad2-mod 4.2.25.980 - 轻量级文本编辑器、代替记事本的最佳选择 
简单设置，将EmEditor转变为纯绿色便携版 
二进制编辑器：Hex Editor II绿色免安装版 


</content>
</doc><doc>
    <docid>102</docid>
    <url>http://www.portablesoft.org/fotosketcher/</url>
    <title>强大图片素描化工具 - FotoSketcher 3.20 绿色免安装版</title>
    <content>FotoSketcher 是一款很简便且强大的图片素描化工具，处理速度很快，可以帮助你创建类似真实素描的艺术作品。
FotoSketcher 现在有二十多种自动素描方式，如铅笔素描效果、水墨效果、油漆效果、像素化、彩色圆圈、卡通、活力照片、老式照片等等。制作素描图时，FotoSketcher 可以实时预览，具体试一下就知道是什么效果的。
FotoSketcher 新版增加了很多功能，打开一张图片后会自动弹出绘制参数对话框 (Drawing parameters)，每种方式也都可以调整很多参数，如颜色强度、明亮度、纹理设置等，还可以添加文本，支持中文输入，也支持批量处理。

很不错的软件、软件本身即为单文件版、纯绿色，有什么不满意的就按下 F10 打开绘制参数对话框重新设置就行。2016/8/11 更新版本为 FotoSketcher 3.20，在中文系统中默认显示简体中文界面。
FotoSketcher 3.20 更新说明：
Better Windows 10 supportImproved memory management (Pencil Sketch 1 and Linear Halftoning)a new popup window previewing each effectVarious bug corrections

FotoSketcher is a 100% free program which can help you convert your digital photos into art, automatically. If you want to turn a portrait, the photograph of your house or a beautiful landscape into a painting, a sketch or a drawing then look no further, FotoSketcher will do the job in just a few seconds.
FotoSketcher Portable 相关文件下载
官方网站：www.fotosketcher.com
解压密码：www.portablesoft.org
压缩包MD5：DC2E3E6B60DCDBAF928C544ECAD84B7A
开始下载 FotoSketcher Portable 3.20 简体中文绿色便携版
FotoSketcher_3.20_PortableSoft.7z (8.07 MB)
@精品绿色便携软件 &#124; FotoSketcher 3.20 下载页面 &#124; 更多版本下载
开始下载 FotoSketcher Portable 3.00 简体中文绿色便携版
FotoSketcher_3.00_PortableSoft.7z (5.36 MB)
@精品绿色便携软件 &#124; FotoSketcher 3.00 下载页面

Related posts:
Morpheus Photo Morpher绿色版：图像渐变工具 
Photo Collage Studio绿色便携版：数码照片拼贴工具 
图片尺寸调整工具：FastStone Photo Resizer便携版 
图片去水印工具 - Inpaint 6.2 中文绿色便携版 
真正的数码暗房：LightZone绿色版 
专业数码照片处理软件：Zoner Photo Studio中文绿色版 


</content>
</doc><doc>
    <docid>103</docid>
    <url>http://www.portablesoft.org/win64ast/</url>
    <title>Win64AST 1.10 Beta6 - 支持64位Windows的ARK、内核级的高级系统工具</title>
    <content>Rootkit 通常是指加载到操作系统内核中的恶意软件，因为其代码运行在特权模式之下，极具危险性。有 Rootkit，就需要 Anti Rootkit，用到的就是 ARK 工具。
针对32位的 Windows XP 或 Windows 7 系统，已经有很多成熟的工具了，比如冰刃、早期的冰刃 (IceSword)、Wsyscheck、到后来的狙剑 (SnipeSword)、XueTr，还有最近很给力的 PowerTool 等，但是64位操作系统下的 ARK 工具发展相对缓慢，目前本站介绍过 IThurricane 发布的 PowerTool 64位版。
而 Tesla.Angela 开发的 Win64AST 是另一款、也可能是全球第一个专用于64位系统的内核级的高级系统工具，由于使用了特殊的内核技术，WIN64AST 能够从底层控制系统，有很大的操作权限，是一个强大的 Anti Rootkit 工具，能够查看并管理64位 Windows 系统的各种内核信息，可用于手工杀毒、辅助调试、内核研究等。

Win64AST 全称 Win64 Advanced System Tool，支持 Windows 7 x64、Windows 8 x64 和 Windows 2008 R2，目前实现的功能有：

进程/内存/线程/模块/句柄/窗口管理
内核模块查看
网络连接查看和禁止
查看/恢复SSDT和Shadow SSDT
扫描/恢复RING3和RING0的内联钩子
查看并删除消息钩子
查看/恢复重要驱动程序分发函数
查看/恢复内核对象例程钩子
枚举各种通告和回调
枚举I/O定时器
枚举DPC定时器
枚举MiniFilter/失效MiniFilter的回调函数
枚举/摘除过滤驱动
查看/备份/恢复/自动修复主引导记录(MBR)
进程行为监视(创建进程/创建线程/加载驱动/修改注册表/改动文件系统/连接网络/修改时间)
内核内存编辑
在驱动里枚举文件、强制新建/解锁/删除/破坏文件
在驱动里枚举注册表、强制删除/新建/重命名注册表键(KEY)和注册表值(VALUE)
禁止创建进程/禁止创建文件/禁止创建注册表键(KEY)和注册表值(VALUE)/禁止加载驱动/禁止联网/禁止读写磁盘敏感区域
校验文件签名
枚举/恢复中断描述符表钩子
枚举全局描述符表
显示特殊寄存器的值
检测进程的IAT钩子和EAT钩子
查看/备份/恢复/自动修复卷引导记录(VBR)
网络防火墙
枚举/删除SPI、BHO、IE右键菜单、WFP CALLOUT、NDIS FILTER
DLL/驱动加载器
枚举/删除自启动项、枚举/编辑文件关联
枚举/恢复内核回调表
PE文件查看器
证书拉黑工具

使用说明：2016/8/11 更新版本为 Win64AST 1.10 Beta6  测试版，下载后直接运行 Win64AST.exe 即可，注意 Win64AST 在 Windows 7 上需要安装 .NET Framework 4 方可运行，而 Windows 8 则不用安装 .NET Framework 4。
Tesla.Angela 说明了 WIN64AST 与 PowerTool x64 的不同之处：

PowerTool 的作者 ithurricane 大牛把 PowerTool 定位为「手动杀毒工具」，主要用于手动杀毒；而我把 Win64AST 定位为「高级系统工具」，里面有部分 ARK 功能，也有部分 RK 的功能（比如：隐藏进程、保护进程和强制修改进程内存，将来可能还会添加更多的功能），可用于辅助研究 Win64 内核，也可以干一些“邪恶”的事情，比如辅助游戏多开等，推荐两者一起使用。


Win64AST 1.10 Beta 6 更新日志：
支持WIN10-10586新增汇编器新增枚举NDIS FILTER新增枚举/删除用户名新增枚举/删除输入法新增转储内核内存（保存一片内核内存为文件）新增转储进程内存（输出进程里所有有效的内存块为文件）新增枚举/恢复HHIVE对象挂钩（隶属于OBJECT HOOK）新增“失效但不摘除定时器”功能新增扫描任意模块的代码段修改新增扫描任意模块的EAT/IAT修改增强了枚举网络连接（枚举前处理掉可能存在的HOOK）修复了几个枚举不全/数据错误/功能无效/导致蓝屏的bugUI微调（比如列表刷新后在底部状态栏显示有多少项、默认横纵比为1:0.618）
Win64AST 相关文件下载
官方网站：win64ast.m5home.com
解压密码：www.portablesoft.org
压缩包MD5：586DFE4D06A0A1914486869231DD8FB5
开始下载 Win64AST 1.10 Beta 6 简体中文绿色免费版 (测试版)
Win64AST_1.10Beta6_PortableSoft.7z (2.85 MB)
@精品绿色便携软件 &#124; Win64AST 1.10 Beta6 下载页面 &#124; 更多版本下载
特别提醒：Win64AST 极易被杀毒软件报毒，建议您关闭杀毒软件再使用本软件，如果发现运行不正常，请仔细看说明文件寻找解决方案。

Related posts:
PowerTool 64位版 v1.6 - 内核级的手动杀毒、进程管理工具 
PC Hunter 1.35 - XueTr 升级版、强大的系统信息查看与手工杀毒辅助软件 
LockHunter绿色免费版 - 解除文件锁定 
辅助杀毒小工具 - Hijack Hunter 1.8.4.1中文绿色版 
XueTr绿色便携版：强大的手工杀毒辅助工具 
NirLauncher 1.18.23 - 便携式 NirSoft 软件合集 


</content>
</doc><doc>
    <docid>104</docid>
    <url>http://www.portablesoft.org/snipaste/</url>
    <title>Snipaste 1.6 绿色便携版 - 简单但强大的截图+贴图工具</title>
    <content>在 V2EX 闲逛时发现了一个很有意思的截图软件：Snipaste，作者 levie 用了三年的业余时间开发了这一个很特别的截图 + 标注 + 贴图工具。我下载看了下，Snipaste 的截图功能已经很丰富了，基本常见的截图模式和操作都支持，使用的是类似 QQ 截图界面，但比 QQ 截图做的更好用，功能更强大些。
Snipaste 支持将剪贴板中的内容转为图片显示，包括剪贴板中的图像、纯文本、HTML 文本、颜色信息、图像文件等等，另外还可以高效地自动选取按钮、文字等界面元素。

Snipaste 目前还没有滚动截图，如果需要截滚动窗口，可以试试 FastStone Capture 或者 PicPick。但作者 levie 说 Snipaste 更重要的功能是贴图，所谓贴图就是将截取的任意数量图片贴到屏幕上显示，类似于桌面便签，可以当作临时笔记、临时记录之用，活用它，将能够大大提高你的生产力。每个贴图窗口都提供了很多功能操作，比如添加阴影、缩放、保存到文件等。

作者 levie 对 Snipaste 软件的介绍：
Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！ 下载并打开 Snipaste，按下 F1 来开始截图， 选择“复制到剪贴板”，再按 F2，截图就在桌面置顶显示了。就这么简单！
你还可以将剪贴板里的文字或者颜色信息转化为图片窗口。 你可以缩放、旋转这些贴图窗口，或者把它们变成半透明，甚至让鼠标能穿透它们！ 如果你是程序员、设计师，或者你大部分工作时间都是花在电脑上, 我相信你能体会到 Snipaste 给你带来的效率提升。
另外这里有很多 GIF 动图展示和作者的开发历程：https://www.v2ex.com/t/295433
Snipaste v1.6 2016.08.10 更新日志：
修复：自动探测窗口范围功能，对 Windows 标准样式窗口，识别范围大了一圈修复：自动探测窗口范围功能，对 QQ 窗口，识别范围大了一圈修复：从 Chrome 复制的带特定格式的 HTML 文本，贴出来的图片可能出错修复：屏幕 150% DPI 时，颜色按钮的大小不对修复：放大镜在贴图窗口上移动时有明显延迟改进：更新了部分图标（感谢 像素君）新增：（选项）取 Hex 颜色值时不复制 #新增：镂空箭头样式
Snipaste 相关文件下载
官方网站：zh.snipaste.com
解压密码：www.portablesoft.org
压缩包MD5：83C092753F086085E5605C55ECF90C45
使用说明：下载解压后直接运行 Snipaste.exe 即可，配置会保存到当前目录中的 config.ini 文件中，完全绿色便携。如果无法运行，则需要下载安装 VC 运行库。
开始下载 Snipaste 1.6 绿色便携版 (32位版+64位版+XP版)
Snipaste_1.6_PortableSoft.7z (10.33 MB)
@精品绿色便携软件 &#124; Snipaste 1.6 软件下载页面 &#124; Snipaste 用户手册
开始下载 Snipaste 1.5 绿色便携版  (32位版+64位版+XP版)
Snipaste_1.5_PortableSoft.7z (10.11 MB)
@精品绿色便携软件 &#124; Snipaste 1.5 下载页面

Related posts:
免费屏幕截图软件：Gadwin PrintScreen中文版 
FastStone Capture 8.4 汉化绿色便携版 - 极品屏幕截图工具 
屏幕捕捉软件：TNT Screen Capture绿色便携版 
免费全能截图软件 - PicPick 4.1.5 绿色便携版 
印象笔记·圈点 Evernote Skitch 2.3.0.10 - 优雅的图片标注工具 
TechSmith SnagIt Studio汉化绿色版：优秀的全能截图工具 


</content>
</doc><doc>
    <docid>105</docid>
    <url>http://www.portablesoft.org/notepad2-mod-portable/</url>
    <title>Notepad2-mod 4.2.25.980 - 轻量级文本编辑器、代替记事本的最佳选择</title>
    <content>Notepad2 是一个相当优秀的轻量级文本编辑器。Notepad2 是基于 Scintilla 开发，体积小巧、运行快速，与系统默认记事本具备相同资源消耗，但提供了大量实用功能，如代码高亮、编码转换、行号显示、多步 Ctrl+Z、增强的查找替换等等，是代替系统默认 Notepad 的极致选择。
Notepad2 是一款开源软件，XhmikosR 又在 Notepad2 基础上二次开发了更加实用强大的 Notepad2-mod，额外提供代码折叠、书签、自动完成、支持更多代码格式高亮等功能，更加地好用了。
由于 Notepad2-mod 支持 NSIS 脚本高亮，也是我目前使用的记事本替代工具，并通过映像劫持方式完美实现了 Notepad2-mod 替换系统记事本，如果 Notepad2-mod 能标签化打开多个文件就完美了。
使用说明：基于 semidio 汉化的 Notepad2-mod 简体中文版制作便携版，2016/8/9 更新版本 Notepad2-mod 4.2.25.980，有需要的可以下载试用，Notepad2_EN.exe 为英文原版，必要时重命名为 Notepad2.exe 后使用。

如果要替换记事本，则运行 !)替换记事本.bat 即可，会将 Notepad2-mod 无缝替换系统默认的记事本，!)还原记事本.bat 则恢复系统默认的记事本关联。由于是通过映像劫持替换的记事本，所以必须以管理员权限运行、并且关闭所有安全类软件，否则可能无法设置！
Notepad2 和 Notepad2-mod 的特色功能：

代码折叠和代码高亮：HTML、XML、PHP、ASP (JS、VBS)、CSS、JavaScript、VBScript、C/C++、C#、Resource Script、Makefiles、Java、Visual Basic、Pascal、Assembly、SQL、Perl、Python、Configuration Files、Apache Config Files、PowerShell、Batch Files、Diff  Files、AutoHotkey、AutoIt3、AviSynth、Bash、CMake、Inno Setup、LaTeX、Lua、NSIS、Ruby、Tcl scripts
拖曳式文本编辑功能
基础的正则表达式查找与替换
便捷的快捷键
矩形选择文本（Alt+鼠标左键）
括号配对、自动缩进、长行标记、文本缩放功能
支持多种编码，包括 Unicode、UTF-8、Unix、Mac 文本
支持添加书签
自动完成
增强的NFO字符画文件
标记打开的文件中所有相同的文本


Notepad2 is a light-weight, free and open source Notepad-like text editor with syntax highlighting for a few commonly used languages. Notepad2-mod is a Notepad2 fork, a fast and light-weight Notepad-like text editor with syntax highlighting.
Notepad2-mod 相关文件下载
官方网站：xhmikosr.github.io
解压密码：www.portablesoft.org
压缩包MD5：649C0895FBBBC03E2B456A7DDF939E04
开始下载 Notepad2-mod 4.2.25.980 汉化绿色便携版 (32位版+64位版)
Notepad2-mod_4.2.25.980_PortableSoft.7z (1.04 MB)
@精品绿色便携软件 &#124; Notepad2-mod 4.2.25.980 下载页面 &#124; 更多版本下载
开始下载 Notepad2-mod 4.2.25.954 汉化绿色便携版 (32位版+64位版)
Notepad2-mod_4.2.25.954_PortableSoft.7z (906 KB)
@精品绿色便携软件 &#124; Notepad2-mod 4.2.25.954 下载页面
开始下载 Notepad2 / Notepad2-Mod zhfi 修改版 (简体中文)
Notepad2-zhfi.7z (1.75 MB)
@精品绿色便携软件 &#124; 进入软件下载页面 &#124; 详细介绍

Related posts:
通过映像劫持实现Notepad2替换记事本 
功能强大的文本编辑器：EditPlus汉化绿色便携版 
AptEdit绿色版：功能丰富的文本/HEX/HTML/程序编辑器 
排版助手(Gidot Typesetter)绿色便携版 
二进制编辑器：Hex Editor II绿色免安装版 
EmEditor 16.1.3 简体中文便携版 - 强大文本编辑器 


</content>
</doc><doc>
    <docid>106</docid>
    <url>http://www.portablesoft.org/google-chrome/</url>
    <title>谷歌浏览器 (Google Chrome) 52.0.2743.116 绿色免安装版+便携版</title>
    <content>Google Chrome 是由 Google 开发的一款设计简单、运行高效、支持扩展的浏览器，它基于高速 WebKit/Blink 内核和高性能 JavaScript V8 引擎，在支持多标签浏览的基础上，提供顺畅的浏览体验，并且每个标签都在独立的沙箱内运行，安全性大大提高。
Chrome 便携版说明：
2016/8/8 基于 Google Chrome Stable 52.0.2743.116 制作便携版，直接运行 ChromePortable.exe，然后会生成快捷方式 ChromePortable.lnk，推荐使用此快捷方式启动程序；若之前使用过这里的 Chrome 便携版，则可以将最新的文件解压后覆盖到对应目录，会保留所有的配置，但请注意检查 PortableProfile 是否为空，防止配置文件被覆盖。
注意 Chrome 28 开始使用 Blink 作为浏览器内核，Blink 是开源引擎 WebKit 中 WebCore 元件的一个分支。

Chrome 绿色版说明：
若将 Google Chrome 作为绿色免安装版使用，则可以直接执行主程序 App\Google Chrome\chrome.exe，以默认配置运行 Google Chrome，配置保存在 C:&#92;Documents and Settings&#92;用户名&#92;Local Settings&#92;Application Data&#92;Google&#92;Chrome&#92;User Data 这样的目录下，备份和恢复配置的话请运行 !)保存配置.bat 或 !)恢复配置.bat，会保存到当前目录的 Profile 文件夹内。
ChromePortable.exe 作为 Chrome Loader 为 Chrome.exe 添加启动参数，并保存到 ChromePortable.ini 中，后供 ChromePortable.exe 读取调用，所以请保持 ChromePortable.exe 和 ChromePortable.ini 的完整性。

下面是 Google Chrome Portable 的使用须知：

便携版配置文件固定保存到 App\Google Chrome\PortableProfile 文件夹中；
如果要将 Chrome 便携版锁定到任务栏，请将快捷方式 ChromePortable.lnk 拖拽到任务栏即可；
移动软件目录或对 ChromePortable.ini 有任何修改的话，必须重新运行 ChromePortable.exe 以生成新的快捷方式；
特别提醒：升级便携版时，请务必注意备份好本机 ChromePortable.ini 文件中的设置，以免自定义参数丢失；
本便携版支持设置为默认浏览器 (有限支持、非完美支持)，方法是到 ChromePortable.ini 中设置 defaultbroswer=1，再次启动 ChromePortable.exe 就可以了，Vista/Windows 7/8 系统必须以「管理员权限」运行；
如不喜欢本站便携版，可以试用下 Google Chrome Portable by Portableapps.com。

ChromePortable.ini 参数说明：

可自定义配置/数据目录：到 ChromePortable.ini 文件中设置 --user-data-dir 的值；
可自定义缓存目录和缓存大小：到 ChromePortable.ini 文件中设置 --disk-cache-dir 和 --disk-cache-size 的值；
默认添加 --enable-easy-off-store-extension-install 参数，方便安装 Chrome Web Store 之外的第三方扩展应用及脚本程序；
可添加自定义启动参数：修改 custom-switches 的值，可添加除了 --user-data-dir、--disk-cache-dir、--disk-cache-size 之外的任意参数。


Google Chrome is a web browser developed by Google that uses the WebKit layout engine and application framework and combines a minimal design with sophisticated technology to make the web faster, safer, and easier.
Google Chrome 52.0.2743.116 更新日志：
This update includes 10 security fixes.
Google Chrome 相关文件下载
官方网站：www.google.com
解压密码：www.portablesoft.org
压缩包MD5：021D44F888B2352ADCC28B967E562F37
开始下载 Google Chrome 52.0.2743.116 绿色免安装版+便携版 (32位版)
GoogleChrome_x86_52.0.2743.116_PortableSoft.7z (40.34 MB)
@精品绿色便携软件 &#124; Google Chrome Portable 52.0.2743.116 (32-bit) 下载页面 &#124; 更多版本下载
开始下载 Google Chrome 52.0.2743.116 绿色免安装版+便携版 (64位版)
GoogleChrome_52.0.2743.116_PortableSoft.7z (46.92 MB)
@精品绿色便携软件 &#124; Google Chrome 52.0.2743.116 (64-bit) 下载页面
特别推荐：
枫树浏览器便携版 &#124; 360极速浏览器便携版 &#124; 猎豹安全浏览器便携版 &#124; 世界之窗浏览器 6 便携版

Related posts:
Opera Next 17.0.1241.28 便携版 - Opera Chromium 内核浏览器 
世界之窗浏览器 6.2.0.128 绿色便携版 - 精简优化版 Chrome 浏览器 
枫树浏览器 CoolNovo 2.0.9.20 绿色便携版 - 最好的 Chrome 浏览器 
360极速浏览器 7.5.3.300 绿色便携版 - 高效、稳定的双核浏览器 
猎豹浏览器 4.3 Build 5821 绿色便携版 - 智能双核安全浏览器 
眼不见心不烦 1.1.6.1 - 新浪微博非官方功能增强脚本，屏蔽版面模块与任意关键词 


</content>
</doc><doc>
    <docid>107</docid>
    <url>http://www.portablesoft.org/everything-portable/</url>
    <title>Everything 1.4.0.713 Beta 便携版 - 最快最好用的文件搜索工具，新增64位版</title>
    <content>Everything 大家应该比较熟悉了，这是目前速度最快的文件名搜索工具，可以极速搜索、瞬间定位文件，在输入搜索词时即时显示匹配结果，是每一个用户都需要安装的效率工具。
神器 Everything 最具优势的就是其超快的搜索速度，使用起来也极其简单，键入搜索词，所有匹配的文件或文件夹都会实时显示，再配合快捷键打开 Everything 搜索窗口，搜索文件就变成一件极其轻松、高效的事情了。
当然 Everything 也提供了高级搜索用法，如搜索操作符、通配符、正则表达式等等，灵活使用的话，就能实现各种检索需求，具体可以从帮助菜单中学习这些技巧，更多高级用法还可以参见「善用佳软」的专题文章「Everything: 速度最快的文件名搜索工具」。

使用说明：2016/8/4 更新版本为 Everything 1.4.0.713 Beta 测试版，解压后直接运行 Everything.exe 即可 (需要管理员权限)，第一次会有一个索引数据初始化过程，但它通过读取 NTFS USN 日志建立索引，所以索引速度也极快。
Everything 从 1.3.3.653 Beta 开始添加了 64 位版，这样在 64 位系统下就更加高效稳定了，要使用 64 位版，将 Everything_x64.exe 重命名为 Everything.exe 即可。

打开程序后，需要到菜单 Tools->Options->General->Language 中选择「简体中文」，切换为中文界面。由于工作原理的限制，Everything 目前只支持 NTFS 文件系统，如果需要快速搜索 FAT32 文件系统，则可以尝试 Quick Search 或淘奇桌面，而全文搜索的话，FileLocator 是目前最好的免索引全文搜索工具。
Everything 1.4.0.713 Beta 更新日志：
Fixed an issue with indexing deleted attributes in ReFS volumesFixed an issue with indexing very large ReFS volumesFixed an issue with indexing subst volumesFixed an issue with inline renaming and focus wrappingAdded option to remember search in bookmarksAdded option to remember view in bookmarksImproved unicode normalizationImproved open path commandImproved tooltips
Everything search engine Locate files and folders by name instantly: Small installation file, Clean and simple user interface, Quick file indexing, Quick searching, Minimal resource usage, Share files with others easily, Real-time updating。
Everything 相关文件下载
官方网站：www.voidtools.com
解压密码：www.portablesoft.org
压缩包MD5：02872AD8D814C07E6F7EF17003448A8C
开始下载 Everything 1.4.0.713 Beta 中文绿色便携版 (32位版+64位版、测试版)
Everything_1.4.0.713_PortableSoft.7z (1.20 MB)
@精品绿色便携软件 &#124; Everything 1.4.0.713 下载页面 &#124; 更多版本下载
开始下载 Everything 1.3.4.686 Stable 中文绿色便携版 (32位版+64位版、正式版)
Everything_1.3.4.686_PortableSoft.7z (995 KB)
@精品绿色便携软件 &#124; Everything 1.3.4.686 下载页面
开始下载 Everything 1.2.1.371 Stable 中文绿色便携版 (32位版、正式版)
Everything_1.2.1.371_PortableSoft.rar (390 KB)
@精品绿色便携软件 &#124; Everything 1.2.1.371 下载页面

Related posts:
Quick Search 1.1.0.189汉化绿色版：快速文件名搜索工具 
最好的免索引全文搜索工具 - FileLocator Pro 7.2.2038 中文绿色便携版 
淘奇桌面：极速文件搜索工具 
免费全能文件查看器：Open Freely绿色便携版 
[谣言粉碎机] 索引服务，Windows 7 性能杀手？ 


</content>
</doc><doc>
    <docid>108</docid>
    <url>http://www.portablesoft.org/mkvtoolnix/</url>
    <title>MKVToolNix 9.3.1 - MKV无损剪辑、分割、封装、合并工具</title>
    <content>MKV 是一种优秀的多媒体容器格式，它可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个 MKV 文件中，而 MKVToolNix 是一款免费开源的 MKV 编辑器和工具集，能够合成、编辑  Matroska MKV 文件。
MKVToolNix 包含了以下几个 MKV 专用处理工具：

mkvmerge：将多媒体文件封装、合并、混流为 MKV 文件；
mkvinfo：输出 MKV 文件组件和编码信息；
mkvextract：从 MKV 文件中提取视频、音频和字幕轨道；
mkvpropedit：直接修改现有 MKV 文件的属性而无需重混流；
mmg：mkvmerge GUI，并包含了章节编辑器和头部编辑器。


使用说明：2016/8/4 更新版本为 MKVToolNix 9.3.1，现在 MKVToolNix  有64位版本了，绿色便携版直接运行主程序 mkvtoolnix-gui.exe 即可，配置保存到 mkvtoolnix.ini 文件中，默认简体中文界面，软件不能放在中文目录，否则只能显示英文界面。
Matroska MKV 制作与合并

MKVToolNix 中的 Mkvmerge GUI 允许你导入多个视频、音频、字幕轨道，混流合并一个新的 MKV 文件，并可以设置导出视频的宽高比、显示比例、帧频等等。
Matroska MKV 分离与提取

MKVToolNix 中的 MKVExtractGUI 则可以从现有的 MKV 文件中提取其中的一个或多个视频、音频或者字幕信息，是专业的 MKV 分离工具。
Matroska MKV 剪辑与分割

MKVToolNix 是专用的 MKV 剪辑工具，提供了4种 MKV 切割模式，包括按尺寸、按时长、按特定时间码和按分段，都是无损剪辑、分割 MKV 过程，能够同步切割视频、音频和字幕轨道。比之前介绍的所有支持 MKV 分割的工具都要好用，包括 Boilsoft Video Splitter、SolveigMM AVI Trimmer 等。
MKVToolNix is a set of tools to create, alter and inspect Matroska files under Linux, other Unices and Windows. 
MKVToolNix 9.3.1 更新日志：
Fix invalid probe range percentage
MKVToolNix 相关文件下载
官方网站：www.bunkus.org
解压密码：www.portablesoft.org
压缩包MD5：1C36ADAC2A1480B12762B57BF9BD322A
开始下载 MKVToolNix 9.3.1 (Mkvmerge GUI+MKVExtractGUI) 中文绿色便携版 (32-bit, 32位版)
MKVToolnix_x86_9.3.1_PortableSoft.7z (11.02 MB)
@精品绿色便携软件 &#124; MKVToolNix 9.3.1 (32-bit) 下载页面 &#124; 更多版本下载
开始下载 MKVToolNix 9.3.1 (Mkvmerge GUI+MKVExtractGUI) 中文绿色便携版 (64-bit, 64位版)
MKVToolnix_9.3.1_PortableSoft.7z (11.37 MB)
@精品绿色便携软件 &#124; MKVToolNix 9.3.1 (64-bit) 下载页面

Related posts:
免费 AVI/MKV 编辑器 - SolveigMM AVI Trimmer 2.1.1307.29 中文绿色便携版 
idoo Video Editor 3.0.0 便携版 - 强大的多功能视频编辑器 
方便视频分割/合并工具 - SolveigMM Video Splitter 3.6.1309.3 绿色便携版 
支持超多格式的视频剪辑软件 - AVS Video ReMaker 4.1.3.149汉化绿色版 
强大视频分割软件 - Boilsoft Video Splitter 7.02.2绿色便携版 
视频合并、分割、剪切工具 - Xilisoft Video Editor 2.2.0.1023绿色便携版 


</content>
</doc><doc>
    <docid>109</docid>
    <url>http://www.portablesoft.org/axure-rp-pro/</url>
    <title>快速产品原型设计软件 - Axure RP Pro 8.0.0.3303 汉化绿色版 (正式版)</title>
    <content>Axure RP Pro 是一个产品经理必备的交互原型设计工具，能够高效率制作产品原型，快速绘制线框图、流程图、网站架构图、示意图、HTML 模版等。
Axure RP Pro 是专为 Rapid Prototype Design 而生，它可以辅助产品经理快速设计完整的产品原型，并结合批注、说明以及流程图、框架图等元素将产品完整地表述给各方面设计人员，如 UI、UE 等等，并在讨论中不断完善。
作为办公自动化辅助工具，Axure 更适合 Web Prototype 制作，Axure 8 在 Axure 7、Axure 6 基础上做了比较多的改进，旨在提高原型设计效率，包括重新组织界面功能、自适应视图、新增多个形状、样式、事件、动画效果支持等，具体可见这里的介绍。

使用说明：2016/4/15，Axure 8 由 Beta 升级为正式版。Axure 8 新增了钢笔工具、页面快照和更多动画效果支持等。2016/8/1 基于 Axure RP 8.0.0.3303 Stable 制作 Axure 8.0.0.3303 汉化绿色版。

使用前的准备：使用 Axure RP Pro 之前必须先安装 .NET Framework 4.0 组件；
安装说明：以管理员权限运行 !-AxureRP8Poratble.exe 完成初始化安装，以后直接执行主程序 AxureRP8.exe 即可，无需再次运行初始化安装；
特别提醒：*.rp 工程文件如果用 Axure 8 打开编辑过的话，则无法再用旧版本的 Axure 6/7 打开，请特别注意此兼容性问题；
关于汉化： 汉化作者为 Axure 中文社区 WebPPD 的 best919，汉化信息及补丁详见此贴。

 
Axure RP is the leading tool for rapidly creating wireframes, prototypes and specifications for applications and web sites. Quickly get the benefits of prototyping without a lot of hassle. It ives business and UX professionals diagramming, documentation, and interactive tools to quickly design and share interactive prototypes and specifications.
Axure 8 部分新功能与特性：

新增钢笔工具
新增页面快照功能
变换形状新增算法：联合、减去、相交、排除
支持通过交互动作来旋转图形了
可以对组件或图像进行放大与缩小
在面板切换状态时，可以有翻转的动画效果了，以前只有淡变和移入
内置了 Font Awesome 图标，可拖动大小和设置填充颜色
可以设置连接线为曲线
部件注释里可以设置字体颜色和项目符号
通过交互动作，设置组件的透明度变化
窗口滚动可以选择向上滚动还是向下滚动

Axure v8.0.0.3303 2016/6/30 更新日志：
Optimized Repeater heavy filesOptimized Group heavy filesOptimized SketchyOptimized ConnectorsOptimized Team Project updatesOptimized Grid and BackgroundOptimized Dots and DashesOptimized Adaptive View switchingOptimized selecting and adding WidgetsOptimized rich text rendering (minor)
Axure RP Pro 相关文件下载
官方网站：www.axure.com
解压密码：www.portablesoft.org
压缩包MD5：D5DBFAF74C99D8390D75A5B29CE3F381
开始下载 Axure RP Pro 8.0.0.3303 汉化绿色版 (Stable/正式版)
AxureRPPro_8.0.0.3303_PortableSoft.7z (30.10 MB)
@精品绿色便携软件 &#124; Axure RP Pro 8.0.0.3303 下载页面 &#124; 更多版本下载
试用说明：Axure 8 绿色版没有集成任何注册码或其他注册信息，为 Axure 8 企业版的试用版，默认有 31 天的全功能试用期。试用期结束后，请考虑购买官方正版授权。如果还想继续试用的话，请给我发邮件至 admin@portablesoft.org 询问解决方案。
开始下载 Axure RP Pro 7.x (7.0.0.3189) 汉化绿色版 (Stable/正式版)
AxureRPPro_7.0.0.3189_PortableSoft.7z (6.84 MB)
@精品绿色便携软件 &#124; Axure RP Pro 7.0.0.3189 Stable 下载页面
开始下载 Axure RP Pro 6.x (6.5.0.3055) 汉化绿色版 (Stable/正式版)
AxureRPPro_6.5.0.3055_PortableSoft.rar (6.09 MB)
@精品绿色便携软件 &#124; Axure RP Pro 6.5.0.3055 Stable 下载页面

Related posts:
Pacestar LanFlow绿色免安装版：网络拓扑图绘制工具 
Edraw Mind Map中文绿色免费版[增强版]：专业多功能绘图软件 
亿图图示专家 - Edraw Max 6.8中文绿色版 
Adobe Fireworks CS6 12.0.0.236 简体中文精简绿色版 
ProcessOn - 优秀的在线流程图绘制工具，实时协作绘图与共享 
Adobe Fireworks CS4英文/简体中文/繁体中文绿色特别版 


</content>
</doc><doc>
    <docid>110</docid>
    <url>http://www.portablesoft.org/qtranslate-portable/</url>
    <title>QTranslate 5.7.0.3 - 优秀的全语种多引擎实时翻译工具</title>
    <content>QTranslate 是一个轻量级的免费电子词典，通过集成各大在线翻译引擎实现便捷的实时翻译。QTranslate 帮助你更好地利用在线翻译工具，目前支持 Babylon、Definr、Google Search、Google Translate、ImTranslator、Microsoft Translator、Multitran、Promt、Reverso、SDL、Wikipedia、WordReference、Yandex、有道翻译等翻译引擎或信息服务。
启动 QTranslate 后，默认配置下，鼠标选中任意文本，连点两下 Ctrl 即可激活主窗口并翻译选中的文本，或者通过 Ctrl+Q 弹出小窗口直接显示翻译结果、Ctrl+W 则显示网络搜索结果。
启用即时翻译模式后，在任意程序中选择文字，则自动弹出 QTranslate 图标，点击图标即可查看翻译结果，QTranslate 会自动检测源文本语言格式。
使用说明：已经做成绿色便携版，直接运行 QTranslate.exe 即可，2016/7/30 更新版本为 QTranslate 5.7.0.3，自动显示简体中文界面。

个人非常喜欢 QTranslate，软件小巧精悍、速度流畅，能快速给出翻译结果，以前使用的灵格斯词霸还有有道词典感觉是越来越臃肿、运行效率越来越低了，不过最近的金山词霸 2012还不错。QTranslate 立足于在线翻译并做到极致操作体验，虽然使用时必须联网，但已适用于大部分情况了。
值得一提的是，QTranslate 还提供了国际字符软键盘，能够轻松输入各国语言，特别当你不方便或者懒得安装新的输入法时，这个小功能尤为有用。
QTranslate is a free translator for Windows. With this small utility, you simply select the text you want to translate and then press hot key (Ctrl+Q to show translation in the popup window or Double Ctrl click to show the translation in the main window). 

QTranslate 5.7.0.3 更新日志：
Fixed: Google Translate service doesn't work in China
QTranslate 相关文件下载
官方网站：quest-app.appspot.com
解压密码：www.portablesoft.org
压缩包MD5：F5045C4B63A62DD1A2E0D5B500972170
开始下载 QTranslate Portable 5.7.0.3 中文绿色便携版
QTranslate_5.7.0.3_PortableSoft.7z (389.62 KB)
@精品绿色便携软件 &#124; QTranslate 5.7.0.3 下载页面 &#124; 更多版本下载
开始下载 QTranslate Portable 5.6.0 中文绿色便携版
QTranslate_5.6.0_PortableSoft.7z (377 KB)
@精品绿色便携软件 &#124; QTranslate 5.6.0 下载页面

Related posts:
Lingoes 灵格斯词霸 2.9.1 绿色便携版 
金山词霸 2012 v4.2 - 完美支持 Chrome 和 PDF 取词 
高质量英文写作辅助工具：WhiteSmoke绿色便携版 


</content>
</doc><doc>
    <docid>111</docid>
    <url>http://www.geekfan.net/13985/</url>
    <title>亮瞎眼的特斯拉线圈</title>
    <content>

之前发过一篇用于产生电弧的马克思发生器， 那个玩意儿跟特斯拉线圈相比，就是小巫见大巫了。
尼古拉·特斯拉是一百多年前的一位发明家，他发明了交流电、无线电，制造过小型的地震，搞过巨型的人造闪电。总之他的传奇故事很多，据说是被奸商爱迪生打压以至于默默无闻，著名的电动汽车特斯拉就是为了纪念这个疯狂的科学家。
有传闻说特斯拉玩的闪电，可见范围达到几百英里，不知道真假。我等凡夫俗子，顶多利用特斯拉原理来产生个小型闪电就好了。
&nbsp;
Step 1： 准备和注意事项
我们的目标是做一个1000w的中型特斯拉线圈，放电距离超过120cm，特斯拉线圈的放电距离和功率成正比。
主要材料及大概成本：
1：高压变压器 1000W 输入220V 输出 10KV
2：大量无极电容 如用0.047uf 1000v~(1600v-)的cbb电容需要准备100只左右，有大容量的高压电容请自己换算
3：直径13厘米长1米的聚氯乙烯管(壁厚0.6-1厘米)，pvc管材也将就，厚0.8厘米的绝缘板材(不能是木头!最好塑料)大约2.5平米，厚0.5厘米的绝缘板材(非木!)大约1.5平米，这些都可在家庭装饰城(就是那些买涂料，板材，工具等的那种大市场里)买到
4：导线，多芯铜导线，1000v50A大约6米;10kv1A导线3米
5：耐压漆包线 内径0.5mm 900米长
6：直径0.8厘米的铜管(壁厚1mm以上)长8米，直径3厘米厚&gt;1mm长1米的铜管可在汽车配件或五金等地买到
7：电手钻，螺丝刀，手锯，钳子等工具，普通螺丝，塑料螺丝，环氧树脂胶，钢尺等
8：用于燃气热水器的排气管(金属制作，可弯曲，直径在10厘米以上)制作后期计算得到长度.
Step 2： 电路原理图

等等，你特么是在逗我吗？我们是在做一个极其高大上的“雷公电母”设备，它的原理图怎么可能这么简单。
所以感慨一下科学的伟大吧，小小一张图就可以让你拥有神一般的力量……
&nbsp;
Step 3： 装配示意图


当然，从原理图到真正的装备，还有很多路要走，这个就是装配的示意图。



Step 4： 一些相关的计算公式



1. 电弧长度： 电弧长度 L(单位：英寸); 变压器功率 P (单位 瓦特); L=1.7*sqrt(P)
2. 电容阵容量： 变压器输出电压(交流)E(单位 伏特); 变压器输出电流 I(单位 毫安); 电容器阵列最大容量C(单位 微法) ; 交流频率F(单位赫兹) C=(10^6)/(6.2832*(E/I)*F) [电容的大小涉及到与变压器功率的一个匹配问题，当电容过大时在交流上升到顶点时(即sqrt (2)*V时，电容电压过低无法击穿打火器的空气隙则打火器无法启动就无法工作，整个系统也就无从启动 ]
3. 电容阵的计算就是电容的简单串，并联，初中就学过，在此就不提了.例如当变压器功率为1000瓦时，输出电压为10000伏(交流)，那么电容匹配为0.0318uf，手头有电容规格为：0.047uf 1000~，1600-，再取保险一点到 耐压 1500v~则需要电容阵列安排如下：15个电容串联成一个基本链(BC);再10个这样的基本链并联而成(J)，共需要电容150个，若每支电容分压降为630v~(这样可以大幅度延长电容寿命)，则： 24–BC，16–J，共需384支电容.
4. 其他： 震荡频率：F = 1/(2*Pi*sqrt(L*C))
Step 5： 制作主线圈



在特斯拉线圈的设计中主线圈采用铜管绕制成蚊香状。铜管是用于汽车，供热，中央空调中的那种管壁较厚的承压铜管。直径8毫米大约绕制9-10匝，大约需要9米，最好选用光滑无锈无伤的。



Step 6： 主线圈支架
&nbsp;



这样盘成的主线圈可以适用于6英寸到8英寸的次极线圈(盘铜管很费时间，也满费劲，但是不要图快，要尽可能盘的圆滑.)，还需要5毫米厚的软塑料板(非脆性塑料)做主线圈支架，将其按等距离打眼(要打成9毫米的眼，要不穿不进去) 底座选用普通中密度板就可以了，这个底座还有用，将来底下要放其它东西.也尽可能加工好，接下来把铜管和塑料支架穿起来。



Step 7： 内圈接头
&nbsp;




内圈接头部分，将中密度底版在相应地方开孔引出一个接头。
再找一截铜管做为接地保险，注意，不能让它闭合！
Step 8： 电容阵列





在特斯拉线圈中，有一堆好的电容非常重要，因为所有电弧的能量都是由电容直接提供的。由于高压电容价格昂贵，所以现在普遍的做法是通过对普通无极性电容进行串联和并联来达到所需的耐压和容量。
需要准备的材料：
1.无极性电容，(聚乙烯，聚丙烯，CBB电容 等)一般常见高压电容规格主要有：1600v-0.047uf、1600v-0.068uf两种
2.电阻10兆欧(1000000ohm)
3.有机玻璃板
4.塑料螺丝
首先计算所需要的电容个数和排列方式，根据以前提到的变压器匹配计算得到电容量为0.0318uf/10kv，手头电容规格为1600v- 0.047uf， (此处注意：电容的耐压标示都是直流 ，而且电容器交流耐压与电容材质等多种因素有关，不能简单认为只要将直流耐压值除以1.414 就得到交流耐压值)，从寿命和安全性角度出发，建议将每电容分压值定为450v~ 则得到整个电容阵构成为：22串一链，共14链并联，一共308支电容电阻，电阻的用途是为了当停止使用时对电容中的残留电荷进行放电，使用方法就是每支电容都要并联一支10兆的电阻(1/4~1/2W )
安全提示：若没有放电电阻，则电容阵中储备的能量将可能存在很久而对人身造成伤害!
图中显示了一个电容链，它是蛇行排布的。注意!电容之间不要紧密接触!要留有一定空隙，层与层之间要用4mm厚的有机玻璃隔离，每层包含两个链，固定使用塑料螺丝(尼龙螺丝)， 每层都有各自的接口使之成为独立可使用的单元。
Step 9： 次极线圈的制作







特斯拉线圈中的次极线圈是整个特斯拉线圈中制作最耗时耗神的部分。需要如下材料：
1. 高质量漆包线，一定要买好的，尤其是目前我国的漆包线质量普遍低下，线的直径0.51mm ~ 0.57mm。
2. 聚氯乙烯管材，直径15厘米，最少2米，厚度自己感觉结实就好，一般能买到的大约在4-8mm厚。
3. 用木头制作一个绕线架（有绕线设备的土豪请无视）。用两个圆片穿在圆筒两边，再在圆片中间打眼，穿入中心轴，架到线架子里面就可以绕线了。一圈一圈的绕，大约绕900~1000匝就适合本系统了，整个绕线过程大约7-8小时。
中间休息时一定要把已绕好的部分固定好，免得前功尽弃。绕线时要注意不要使线打结，不要用两根线接起来使用。市面上够长度的漆包线不大好找，大约在500m，但是整卷的线似乎比较贵。有兴趣的朋友可以一起买一大卷分着用。



Step 10： 打火器
&nbsp;





制作打火需要以下材料：
1.200mm直径pvc管材，长400mm
2.90mm长，直径20mm铜管若干
3.双头螺丝 若干(是铜管数目）两倍&nbsp;
打火器其实相当于一个开关器，未打火时能量由变压器传递到电容阵，当电容阵充电完毕时两极电压达到击穿打火中的缝隙的电压时，打火器打火，此时电容阵与主线圈形成回路，完成L/C振荡进而将能量传递到次极线圈。制作步骤：
1.先将铜管打眼。
2.再在pvc管上打眼后，将铜管固定在pvc管内部 (每个铜管与铜管之间的缝隙大约控制在1mm)
3.组装好
为了根据需要调整放电缝隙，每相邻螺栓代表1mm的放电缝隙(螺栓即为接线柱)这样安装只要变换接线柱就可以很方便的根据你的设计电压进行调整了。
注意：打火器工作时将会产生很大的热量，而且往往集中在很小的面积上，所以散热设备必须很强大!一般采用小型立式风机（就那种吹婚礼拱门的），一般都在几百瓦，风量足。
只要注意在进风口加上简单的空气过滤装置防止大灰尘就可以了。
如果不加风机散热的话，特斯拉线圈工作几十秒后就可能导致打火器高温变形，加入风机后，一般可以把整个特斯拉线圈的工作时间延长至十几分钟。
另外，要经常在使用后对打火进行清理，去掉电渣和灰尘。




Step 11： 放电终端
&nbsp;






在这部分的制作比较简单和随意，我这里介绍一种比较成熟和简易的制作方法，也就是最常见的圈型放电终端。
主要材料：
1. 4寸直径的燃气热水器通风管，(就是那种全金属的可弯管，家里有燃气热水器的一看便知)
2. 7寸直径的平底金属盘(用来做派的)，其他类似金属物也可，关键1.平底 2.金属
3. 包裹金币巧克力的那种较厚的铝箔
首先将平底金属盘底对底用螺丝固定，接着将铝管盘成圈状，使其正好能卡在平底金属盘制作的骨架上，铝管的接口口处用铝箔封口，接线点定位在平底金属盘骨架中心，组装好成品。
至此特斯拉线圈的所有重要部分已经完成。
&nbsp;
Step 12： 一些补充说明
&nbsp;
关于特斯拉线圈的制作其实还有不少需要注意的事情，其中：
1：次极线圈的骨架既那个聚乙烯圆桶的饶线部分是有要求的，一般来说，饶线直径和饶线部分桶长比例在1：4左右
2：主线圈的底版可以用一些稍微便宜的材料制作，因为对它的要求不高，当然最好所有的塑料板材都能用雅克力板制作，这样有结实又漂亮
3：打火器的制作其实有很多方法，关键要注意的是a.放电部件要导热快 b.放电部件厚度要足够 c由于打火器更换频率最高，所以设计要以容易更换，价格便宜为主
4：关于高压电容，前些天见到微波炉内部有一种高压电容规格为 2100AC 1uF 且内部集成放电电阻的电容，看来如果使用这种电容也是一个不错的方案
5：关于主变压器，一般难以购买，可以去当地电子市场询问是否可以定做，如果没有，可以购买霓虹灯电源，规格为 15000V AC 50HZ 60mA 样子象个箱子，在国外特斯拉线圈爱好者中使用比较多，还有就是采购日本二手110VACin –6300vACout 变压器两个串联使用
Step 13： 亮瞎双眼的时候到了

世界各地有大量的特斯拉线圈爱好者，搞出很多炫酷的作品。
有的朋友可能又要说“然并卵”了，事实上，很多科技的突破，都是从一些莫名其妙的的发明演化而来。在自然界中，闪电拥有巨大的能量，据说地球每秒钟平均有45次闪电，如果能够抓住这些能量用来发电，那你就发财啦……
视频：

&nbsp;
亮瞎眼的特斯拉线圈，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>112</docid>
    <url>http://www.geekfan.net/13978/</url>
    <title>DIY修炼：舵机知识扫盲</title>
    <content>
DIYer: Tod E. Kurt
GEEK指数: ★★★☆☆
1 简介
舵机控制的机器人
● 我猜你肯定在机器人和电动玩具中见到过这个小东西，至少也听到过它转起来时那与众不同的“吱吱吱”的叫声。对，它就是遥控舵机，常用在机器人技术、电影效果制作和木偶控制当中，不过让人大跌眼镜的是，它竟是为控制玩具汽车和飞机才设计的。
● 舵机的旋转不像普通电机那样只是古板的转圈圈，它可以根据你的指令旋转到0至180度之间的任意角度然后精准的停下来。如果你想让某个东西按你的想法运动，舵机可是个不错的选择，它控制方便、最易实现，而且种类繁多，总能有一款适合你呦。
● 用不着太复杂的改动，舵机就可摇身一变成为一个高性能的、数字控制的、并且可调速的齿轮电机。在这篇文章中，我会介绍舵机使用的的一些基础知识以及怎样制作一个连续运转舵机。
&nbsp;

2 舵机的结构和原理



A.标准舵机图解
● 遥控舵机（或简称舵机）是个糅合了多项技术的科技结晶体，它由直流电机、减速齿轮组、传感器和控制电路组成，是一套自动控制装置，神马叫自动控制呢？所谓自动控制就是用一个闭环反馈控制回路不断校正输出的偏差，使系统的输出保持恒定。我们在生活中常见的恒温加热系统就是自动控制装置的一个范例，其利用温度传感器检测温度，将温度作为反馈量，利用加热元件提输出，当温度低于设定值时，加热器启动，温度达到设定值时，加热器关闭，这样不就使温度始终保持恒定了吗。

B.闭环反馈控制
● 对于舵机而言呢，位置检测器是它的输入传感器，舵机转动的位置一变，位置检测器的电阻值就会跟着变。通过控制电路读取该电阻值的大小，就能根据阻值适当调整电机的速度和方向，使电机向指定角度旋转。图A显示的是一个标准舵机的部件分解图。图B显示的是舵机闭环反馈控制的工作过程。
3   选择舵机

C.大扭力/微型/标准舵机
● 舵机的形状和大小多到让人眼花缭乱，但大致可以如图C所示分类。最右边身材不错的是常见的标准舵机，中间两个小不点是体积最小的微型舵机，左边的魁梧的那个是体积最大的大扭力舵机。它们都是同样的三线控制，因此你可以根据需求换个大个的或小个的。
● 除了大小和重量，舵机还有两个主要的性能指标：扭力和转速，这两个指标由齿轮组和电机所决定。扭力，通俗讲就是舵机有多大的劲儿。在5V的电压下，标准舵机的扭力是5.5千克/厘米（75盎司/英寸），转速很容易理解，就是指从一个位置转到另一个位置要多长时间。在5V电压下，舵机标准转度是0.2秒移动60度。总之，和我们人一样，舵机的个子越大，转的就越慢但也越有劲儿。
● 赶快想好你要做的东西，让我们开始动手吧。确定做什么之后，选择哪种大小的舵机（标准型、微型、绞盘型）就是小case了，你可以绅士般的从中选个最便宜的。在这个项目中，我选的就是微型系列的HexTronik公司生产的HXT500型舵机，额定数值是扭力0.8千克，转速0.10秒，只花不到4美元就搞定了。
4 舵机的支架和连接装置
&nbsp;

D.多种舵盘
● 想在你的项目中用上舵机，就要满足两个条件：一是需要个能把舵机固定到基座上的支架，二是得有个能将驱动轴和物体连在一起的连接装置。支架一般舵机上就有，而且带有拧螺丝用的安装孔。如果你仅仅是测试的话，用点儿热熔胶或者双面泡沫胶带就能轻松的固定住舵机。
● 怎样连接驱动轴呢，你会发现舵机都附带了一些有孔的小东西，这就是舵盘，它可以套在驱动轴，臂上打上了些小孔。你只要用连接棒或者线把物体连到孔上，就可以将舵机的旋转运动变成物体的直线运动了，当然了，选用不同的舵盘或固定孔就能产生不同的运动啦。
● 图示的是几种不同的舵盘。前面4个白色的是舵机附带的舵盘，右边四个是用激光切割机切割塑料得到的DIY舵盘。最右边的2个是舵盘和支架的组合，如果你想实现两个舵机的组合运动，把这个舵盘的支架固定到另一个舵机的支架上就OK了。

E.普通舵盘设计

F.其他舵盘
● 制作普通舵盘对于童鞋们来说是比较容易的，先用矢量作图软件画一个多边形，这个多边形的半径和顶点数都要和舵机驱动轴匹配，这样它就能连接到驱动轴上了，其他种类的也是这样画出来的。
5   如何控制舵机

G.3线接口
● 像图所示那样，舵机有一个三线的接口。黑色（或棕色）的线是接地线，红线接+5V电压，黄线（或是白色或橙色）接控制信号端。

H.控制信号
● 控制信号（如图H）是一种脉宽调制（PWM）信号，凡是微控制器能轻松的产生这种信号。在此文中，我用的是常用的Arduino开发环境下的微控制器。
● 脉冲的高电平持续1到2毫秒（ms），也就是1000到2000微秒(µs)。在1000µs时，舵机左满舵。在2000µs时，右满舵。不过你可以通过调整脉宽来实现更大或者更小范围内的运动。
● 控制脉冲的低电平持续20毫秒。每经过20毫秒（50次每秒），就要再次跳变为高电平，否则舵机就可能罢工，难以保持稳定。不过你要是想让它一瘸一拐的跳舞，倒可以采取这种方法。

这是一个完整的Arduino设计程序，在这个程序下，舵机始终在正中间位置，控制起来很容易

I.舵机连接Arduino实验板
● 红色和黑色的线分别接到Arduino开发板的5V电源脚和接地脚上。控制线接到Arduino开发板的数字输入/输出脚9脚上。
● 用Arduino控制舵机也有不太给力的地方，就是Arduino程序把绝大部分时间都浪费在等待延迟命令上，不过童鞋们暂时不要失望，Arduino中内置有舵机函数，你可以用它内置的计数器来同时控制两个舵机（分别在9脚和10脚），是不是又豁然开朗了，这样我们不就能把节省下的编程代码干别的事情了吗。

这是一个调用了舵机函数的程序
6 舵机应用：云台网络摄像头

J.舵机控制的云台网络摄像头
● 看了这么多内容了，是不是有点迫不及待练练手的冲动，那就先来个简单的，材料就是下面这些，两个舵机、一个Arduino板、一个用来装摄像头的可转动基座。先用热胶把第一个舵机的舵盘固定到摄像头的底部，然后把第二个舵机固定到基座上，同时把它的舵盘固定到第一个舵机的一侧，最后把舵盘套到各自舵机上，哇塞，一个云台网络摄像头就这样诞生了。
● 图中是一个纯手工打造的云台网络摄像机，它用的是OpenWrt Linux系统的华硕wi-fi路由器。
● 网络摄像头和Arduino控制板都是用USB集线器连接到路由器上的。

通过Arduino的USB口同时控制两个舵机的程序
● 大致的流程是这样滴，当串口上有两个字节到来时，程序开始工作，赋给第一个字节0-180的值，让它调节摇摆舵机（调左右），同样赋给第二个字节0-180的值，让它调节倾斜舵机（调上下）。
7 如何DIY连续旋转的舵机

K.舵机的内部“解剖”结构
● 任何舵机都能变成一个双向、可调速的降速齿轮电机。通常情况下，需要驱动芯片和其他一些零件才能控制电机的转速和方向，这些部件舵机中都会附带，所以要想得到一个用到机器人上的数控连续旋转舵机，最简单也最便宜的的方法就是自己动手改造一个，哈哈，考验动手能力的时候又来了。

L.拿掉金属挡板
● 需要改动的是部分的电路模块和机械模块，电路模块中，我们要找两个阻值相同的电阻来充当电位计，机械模块中，则要去掉防止电机过速的挡板。

M.卸下塑料挡板
● 下面我们就开始吧，首先，卸开舵机外壳，HTX500舵机的外壳由3个塑料部分扣在一起。你可以用个小一字改锥或是类似的片状工具把他撬开，然后从轴上取下齿轮组,(记得标记好各个小齿轮的位置哦)，再从下面小心的取出舵机的电路板。
● 舵机上有两个机械制动挡板，用尖嘴钳卸下驱动轴基座上的金属挡板（图L），用斜嘴钳卸下外壳顶部的塑料挡板（图M）。

N.焊上电阻

O.缠上胶带
● 用两个阻值相加约5 kΩ的电阻来替代5 kΩ的电位计，实际制作中，选一对2.2kΩ的电阻就能满足要求了。把电位计上的3根线焊下来，像图N那样焊到电阻上。再把这个重新组装成的家伙用绝缘胶带或是绝缘管缠好（图O），最后再和电路板一起重新塞进舵机外壳中，扣好外壳，一个改造好的舵机就呈现在我们面前了。
● 手工制作阶段到此就结束了，但是现在还能高兴的太早，因为只有找到基准点才能算是大功告成。在理想条件下，如果两个电阻完全相同，舵机就能精确的停到90度的位置上。不过呢，理想和现实总是会差那么一点点，因此舵机就没像理想中那样么精确。为了使舵机控制更精确，我们要找到一个基准点，方法是把上面编的程序灌进电路中，通过实验来看舵机究竟停在哪个角度，这个角度每个舵机都不相同，所以得出结果后要记录下来。
● 我们业余爱好者常用的舵机一般是用电位计来检测驱动轴转动到的角度，而用在工业机器人、电脑数控机床等大型系统中的舵机一般则要用旋转编码器来确定位置。光学旋转编码器的原理是这样的，把一个带有窄缝的圆盘固定在转轴上，然后用一个LED灯和一个光敏元件来记录光通过窄缝照到光敏器件上的次数来计算当前旋转到的位置。其实生活中这种技术也很常见，我们每天都要用的光电鼠标就是用的这个原理制作成的。
注：如果你不想撬开你心爱的舵机，Parallax公司（BASIC Stamp微处理器的制造商）有一款即用型，标准尺寸的连续转动舵机可供你使用。
8 连续旋转舵机的应用：5分钟的绘图机器人

P.安装好的绘图机器人*
● 想做个会画画的的机器人吗，那就去找两个连续旋转舵机来吧，我们这就开始。图O这个绘图机器人中包含了舵机两个， 9V电池，面包板， Arduino电路板，三福记号笔各一个，外加一对塑料轮子。
● 它的电路和云台摄像头一样，我们直接拿来用，而且它的部件都可以用热胶粘到一起。关于轮子的选择，更是简单，只要是直径在1到3英寸的圆东西都能用，比如塑料瓶盖之类的。为了减小摩擦，增大牵引力，我们在车轮上缠上塑料胶带。
● 这样组装阶段就完成了。接下来就是程序了，它的程序用一个包含基准点的变量来制动舵机，这个基准点我们上面已经通过实验测出（你的基准点可能不同）。程序的控制流程为，先让一个舵机朝一个方向运动一段时间，然后换成另一个舵机转动，这样就能得到一个螺线形的图画了。
● 代码在此：
#include
Servo servoL;
Servo servoR;
int servoLZero = 83; // experimentally found to stop L motor
int servoRZero = 91; // experimentally found to stop R motor
boolean turnleft = false;
void setup() {
servoL.attach(9);
servoR.attach(10);
servoL.write(servoLZero); // start out not moving
servoR.write(servoRZero); // start out not moving
}
void loop() {
turnleft = !turnleft;
if( turnleft ) {
servoL.write( servoLZero &#8211; 10 );
servoR.write( servoRZero );
delay(1000);
} else {
servoL.write( servoLZero );
servoR.write( servoRZero + 10 );
delay(4000); // turn more one way than the other
}
}

Q.运动中的绘图机器人
● 注意：永久记号笔画的痕迹不好清除，童鞋们千万小心哈，最好让绘图机器人在硬纸板或其他不透水的纸的画画，或者索性换成支水溶性的记号笔。
&nbsp;
&nbsp;




DIY修炼：舵机知识扫盲，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>113</docid>
    <url>http://www.geekfan.net/13971/</url>
    <title>【神级DIY】自制无线控制“甲壳虫”机器人</title>
    <content>【导读】拥有一个自己会跑会跳的机器人是许多人小时候的一个梦想，如今这个梦想你可以实现了！此次电子元件技术网带来大师级别的DIY，自己动手就能做的机器人，做一个送给家里的小朋友绝对自信心爆棚啊！
话不多说，直接上图。
Solidworks 出图纸和模拟图
机器人身体

机器人头部

机器人漂亮的大腿


&nbsp;
甲壳虫机器人3D模拟图
camworks 出刀路



甲壳虫”机器人3D 模拟图 

&nbsp;
加工及组装
在自己DIY的数控铣床上进行加工，用的6061 的进口铝板， 3mm厚度 


购买的经典型号舵机MG995，开始组装。 

“甲壳虫”机器人造型很漂亮吧！ 

舵机板和布线已经完成

&nbsp;
机器人安装完成
功率强劲的8000mah动力电池


机器人安好后摆个POSE

复位后的状态

机器人站起来了


机器人PS手柄和遥控装置

【神级DIY】自制无线控制“甲壳虫”机器人，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>114</docid>
    <url>http://www.geekfan.net/13956/</url>
    <title>DIY：制作曲面感光元件的针孔相机</title>
    <content>我们曾介绍不少自制针孔相机，而通常都是使用已经提供好的纸模来制作。而来自加拿大的摄影师 Matt Bechberger，则分享了一个非常完整的针孔相机制作指引，包括了数学上及物理学上的讲解，相机通过弯曲胶卷曝光的办法，令胶卷可以均匀曝光，极大地消除了画面的暗角！很好玩哦~。如果你也想自制一台如此认真的针孔相机，可以来参考参考！


基础概念

针孔相机其实是最原始的相机，光线在物体身上反射出来，然后透过相机上的小孔，聚焦于相机内的底片上，而任何可以遮挡着针孔的东西都可成为快门，手动控制曝光时间。就是这么简单。




数学计算

制作方面，首先你要制造出一个好的针孔，在互联网上都可以买得到，又或你能够自制一个。建议材料是一般的铝罐皮，越薄越好。然后使用小锤及针，轻轻地戳一个洞，在戳的时候最后在底先垫一块橡皮擦，以防止变形。完成后再用砂纸把铝片磨平，并且用显微镜或平板素描器之类 (如果有)，去检视针孔的圆度及质素。如果你选用一些硬质金属，则可能要特地使用电钻之类了。

然后你要找出针孔的直径，知道后就可以计算出所需焦距﹐也就是针孔与底片之间的距离。

算式如下︰焦距 = (针孔直径 / 0.03679)^2

例如 针孔0.3mm
焦距 = (0.3mm / 0.03679)^2 = 66.49mm

接下来要计算的就是「视角」(viewing angle)，即是光线进入的最大角度，这取决于针孔的直径与物料的厚度。




这个需要动用直角三角形的公式，要用上计数机。d 就是针孔直径，而 t 就是物料厚度，简化版公式如下︰

视角 = tan^-1( (d/2)/(t/2) ) x 2

例如︰
视角 = tan^-1( (0.3/2)/(0.0762/2) ) x 2 = 75.74 x 2 = 151.5 度

视角的重要性，在于让你判断光线能否恰当覆盖到底片，如果覆盖不足的话，就会出现黑角及黑边。例如上图般，底片的对角线不应长于成像圈的直径。而成像圈的直径算式如下︰
成像圈直径 (mm) = 2 x 焦距 x tan ((视角)/2)

例如︰
成像圈直径 (mm) = 2 x 66.49 x tan (151.5/2) = 523.61 mm

在这个例子里，成像圈非常大，所以配合弧面底片的话，就可以在 120 底片上拍出 17cm x 6cm 的超广角影像。





相机制作

完成了数学计算后，就到物理上的实践。弧面底片的就可以让整块底片都与针孔保持相等距离，从而得到均匀曝光。
相机材料方面没太大限制，最重要是能够阻止光线进入。

卷动底片方面，则要使用如下图的扁状金属条 + 结他旋钮的东西，两边各一个，以松开底片及收紧底片之用。



快门方面，丰俭由人，你可以像作者一样，自制一个以弹簧及快门线控制的快门。

在相机背后需要钻一个小孔，以确定底片的使用量，最好在相机内部涂上黑漆，以消除任何杂散光。&nbsp;







&nbsp;
曝光计算


接下来要计算的是光圈值，这个会影响你所需要的曝光时间。

算式如下︰光圈值 = 焦距 / 针孔直径

例如︰
光圈值 = 焦距 / 针孔直径　= 66.49mm / 0.3mm　= 221

这个世界恐怕没有甚么相机或测光表有 f/221，所以我们要做下一步计算。
根据「标准全级光圈值尺度」，每一级光圈值之间，光线量是减半，亦即是光圈的面积也是每级减半。数字如下︰1.4，2，2.8，5.6，8，11，16，22，32，44，64，88，128，176，256，352。但是超过 f/22 的测光表是不存在的，因此我们可以透过计算自行找出倍数。

不过放心，一般的针孔摄影不是精准的科学，所以也不需要精确的数学。在这情况下 f/221 大概接近 f/256，就当作 f/256 可以了。相比起 f/16 即是有 8 级的差异，也就是说 f/16 的光量是 f/256 的 2^8 倍，也就是 256 倍。

因此你可以透过测光表之类，以相同的 ISO 值但用 f/16 作测量，得快门值后再乘以 256 倍，就是所需的曝光时间了。例如我们测出要曝光 1 秒，那么在此针孔相机上则要曝光 256 秒。


倒易律失效 (Reciprocity Failure)


直至现时为止，所有东西都很直接很数学，但是在摄影上来说，还有一样东西称为「倒易律」。简单说就是在同一感光物料上，曝光时间与曝光量是成正比例上升的，曝光时间两倍，则曝光量也有两倍。但在实际拍摄上，当曝光时间超过一定秒数，就会出现「倒易律失效」，两者不再成正比例，如果想得到正确曝光，则需要额外曝光时间。


下图就是额外曝光简表，很有用，留着它︰


就用 256 秒曝光为例，因为倒易律失效，所以要用上 4 倍曝光时间，即是 1024 秒，由 4 分钟增至 17 分钟，差异当然很大，而且要在曝光环境良好稳定的情况下才是这样。不过放心，其实就算少几分钟也不会很差的，摄影师就曾试过仅用了应有曝光时间的 1/8 来拍摄，结果也不错。

最后提一提，由于针孔摄影往往需要很长曝光时间，所以使用脚架，或放置在稳定的平台上拍摄是很重要的。

&nbsp;

检验相机成果
接下来让我们看看曲面感光拍出来的效果吧~。















DIY：制作曲面感光元件的针孔相机，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>115</docid>
    <url>http://www.geekfan.net/13945/</url>
    <title>DIY：拆了收录机，做个机器人</title>
    <content>
我(原作者)是那种会留下所有损坏的电子设备的人，因为我有可能会在某天用到这些东西。我有一张坏了的CD，一个磁带盒和一个别人送我的收音机，它会随机地保持关机状态。事实证明，这不过是因为收音机的某个焊点坏了。把收音机拆开后我才意识到，由于我们已经有了手机，这些年我们已经很少用到它了。如果我再把它组装回来，也不过是放在架子上落灰。

我决定把它身上多余的东西拆掉，用剩下的关键部位组装出一种功能不变但外表新颖的东西。这样起码还能将它作为架子上的装饰品。如果你也喜欢利用废品做机器人，那么你可能会喜欢这样的尝试。这个机器人能够播放CD、磁带，能听收音机，还能通过音频输入线与你的手机相连。
第一步：工具准备

要说出具体需要的工具还真有点困难，以下是必备工具。
1、达美电磨
2、电钻
3、机械螺丝
4、刀具
5、锉刀
6、中心冲头
7、热熔枪
8、钳子
9、螺丝刀
10、卡尺
11、一台3D打印机在定制支架时非常有用，如果你没有的话，你可以用聚氯乙烯这种材料，使用时将其热熔即可。
拆解


要想得到拼接机器人，你必须先将东西都拆开。你可以看到图中的受害者：一台美国无线电公司产的立体声音响。拆开后，我惊讶地发现里面非常空。我把这些东西拆开后，将它们都拼接到了一起，幸运的是这些东西都还能正常工作。这是一个看上去很好玩的立体声音响。当然，这些还不够，如果要做好机器人，我还需要找一些能当支架的废品。
重新组合


要做一个能站立的机器人，必不可少的一部分是它的双脚。我将一张硬盘劈成了两半给它做脚，用大型激光打印机的一些零件给它做了双腿。我发现最难的地方在于，如何将两个不相干的东西结合到一起。我需要一种能支撑这些零件重量的东西，我可不希望我将它拿起来的时候它就散架了。
我的解决办法是将零件对齐，给它们钻孔并用螺丝将其连接起来。对于一些没法钻孔并用螺丝连接的地方，我会先测量尺寸，并用3D打印机定制一些支架。
接着干


另外一个挑战在于如何连接这些扬声器。我想将它们变成机器人的肩膀，但不知道该怎么讲它们连接起来。在切开塑料的时候，我发现收音机外壳上的网很适合做肩膀。由于它们会阻碍其它零件，因此我用3D打印机定制了一些支架，让它们能够上下翻折。
快好了


到目前为止，头是最有挑战性的一部分。我希望机器人的外表在具有复古风格的同时，还能让人在看到它的第一眼就知道它的功能与声音有关。我发现一盒旧磁带的大小与电脑散热片的大小差不多。散热片也可以用来做机器人的头，因为它大部分地方是空的，能够轻易地在里面接线从而给它焊电灯泡。酷酷的机器人怎么可以不亮呢？另外，感谢我的女朋友在此过程中伸出援手。
一些收尾工作


搜寻过废物箱之后，我找到一个废弃的相机电路和一圈花线，并将它们装饰到机器人的头上，给它增加复古感。卷线很容易，只要将它绕在螺栓或者螺丝起子上就行。
整个过程用时比我想象的要长。总共用了50个多小时，不过整个过程很有趣。我还会对这个机器人做一些改进，比如给它身上加一些灯和可移动零件，并给这些灯加上控制开关。我还想知道如何能将机器人的嘴变得能够显示音量大小，并让它根据所播放的声音眨眼。如果你知道，请跟我联系或者在评论中告知我。能变废为宝是一件很棒的事，我会做更多这类大小的机器人。
DIY：拆了收录机，做个机器人，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>116</docid>
    <url>http://www.geekfan.net/13941/</url>
    <title>极客DIY：轻松使用树莓派控制灯</title>
    <content>
最近笔者正在研究微控制器和基于物联网的设备安全。因此，我开始考虑建立一个小型家庭系统化系统，虽然目前还没完成，但我想先在文章中分享一下我如何使用树莓派2及一些其他电子元件来控制房间的灯光。当然，我在这里不会介绍树莓派的初始设置，因为你可以在网上发现各种各样的教程。
注意事项
在我们继续实验之前，我想有必要提醒一下关于实验中“电流”的危险性。一旦出现任何状况，最糟糕的情况就是死掉或者烧了你的房子。所以，请不要试图完成任何文中提到但是你不理解事情，或者你可以在制作的时候寻求一些有经验的电工的帮助。
好啦，让我们开始DIY吧！
实验准备
硬件需求
1、树莓派2（或者任何5V输出功率的型号，均可）
2、USB无线软件狗
3、8路继电器
4、一些Female-Female跳线（40 PCS FEMALE TO FEMALE JUMPER WIRES）
5、灯头电线
（以上硬件，某宝均有销售）
其他要求
1、了解基本Python语言或者其他任何语言（我会用到Python）
2、对Linux系统有基本了解
3、专心致志
流程要求
首先，用ssh链接到树莓派上，并安装“apache”和“php5”：

你会需要安装python的GPIO库来控制树莓派的GPIO插脚：

了解元件
现在，在我们继续制作之前，你需要了解一下我们将使用到的电子元件。
1、继电器
继电器是一种使用非常低的电压输入控制高压电的电气设备。由一个线圈缠绕的金属杆和两个小型金属节点构成的闭合电路。其中一个节点是固定的，其他的都是可移动的。无论何时，当电流通过线圈的时候，它会产生一个磁场，吸引可移动节点向静态节点运动，形成电路。通过给线圈供应小额电压，我们就能完成高压电路的轮回。同时，静态节点并非在物理上与线圈有联系，因此一旦有地方出错，微控制器驱动的线圈也很少出现故障。

试验中，我使用一个8路继电器，可以同时控制8个设备。你可以选择自己的继电器或者继电板，但是请确保你在继电器的额定电压之内处理，以避免任何事故的发生。
2、跳线
跳线就是我们链接树莓派GPIO插脚与继电器的简单连接电线。
3、树莓派2
我们使用树莓派2作为一个微控制器来操纵继电器。它有40个GPIO（通用输入/输出）插脚。你可以看到下面这些插脚的布局，我们将使用这些接口为继电器加电和控制开关。

连接电路
电路非常简单。我们将连接GPIO插脚到继电板上。首先连接继电器板上的“GND”与树莓派上的任意“GND”。然后链接继电器的“IND1”到GPIO PIN 17，我们会把GPIO PIN 17作为一个控制第一继电器的输出。最后，将继电器的“VCC”连接到树莓派的“5V”GPIO插脚。让我们简单直接设置一下：

现在我们到了最为棘手的部分，我们要将继电器连接到接通主电路供电的灯头上。但是，我想先给你介绍一个如何通过直流屏电源开启及关闭灯光的简单操作。
我们通常连接两根电线到灯泡上，来提供电流供给。其中一根电线是“中性”电线，另一根则是实际带着电流的“负极”电线，同样的这里也有一个控制整个电路的开关。因此，当开关（闭合）连接到流经灯泡的电流和负极电线时，电路便完整了。灯泡从而亮了起来。当开关（断开），破坏了电路和灯泡的电流，因此灯泡不亮。这里有一个小的电路图来解释具体情况：

当我们在试验中，我们需要“负极电线”通过我们的继电器来打破电路，从而使用继电器开关的控制流经的电流。因此，当继电器打开，在闭合电路中灯泡也应该亮起来，反之亦然。请参考一下完整的电路：

控制脚本
现在，终于到了软件的部分。我编写了一个简单的python脚本来控制继电器开关，使用了GPIO PIN 17和一个PHP代码可以在任何移动终端上面来运行python脚本。你可以从我的Github（和CSS）上找到这段代码。


注意：你将会需要添加“www-data”用户到sudoers文件。
注意+：PHP代码只是为了测试，我们不建议在公共环境中运行。
不久我将完成这个设置，希望回来更新一个新的帖子。请在那时之前，自己动手试一下这个控制灯，但是一定要注意安全。
视频展示：demo1 :

demo2:

&nbsp;
参考
· GPIO Diagram: http://data.designspark.info/uploads/images/53bc258dc6c0425cb44870b50ab30621
·https://www.youtube.com/watch?v=Z2B67hybdAA
·https://elementztechblog.wordpress.com/2014/09/09/controlling-relay-boards-using-raspberrypi/
·https://www.raspberrypi.org/forums/viewtopic.php?t=36225
·https://github.com/TheGreenToaster/web-pins/
极客DIY：轻松使用树莓派控制灯，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>117</docid>
    <url>http://www.geekfan.net/13924/</url>
    <title>自主机器人：你的私人WALL·E</title>
    <content>


DIYer:
Kris Magri


制作时间:
2-3周


制作难度:
★★★★☆


GEEK指数:
★★★★★



看最终效果视频

Makey是我编程实现的一个自主机器人（自主者，非遥控也），能够识别并规避障碍。她拥有全封闭的底盘并使用差速转向（原文为“tank steering”，坦克的驾驶方式），这种转向方式使用两台分开控制的电动机分别驱动两个主动轮（一机一轮）
控制信号来自其自身携带的Arduino微型控制器（在国内用单片机如PIC、AVR，或者Arm处理器都可以很好地替代），另外有一个舵机用于Makey头部的转动。Makey的头部装有一个超声波探头，她会持续的左右摇头，以得到不同方向上的距离信息，并进行存储和处理
通过对Arduino的编程，Makey可是实现诸如寻路的功能，仅需要少量硬件上的修改，Makey即可参加机器人界热门的Mini-Sumo（迷你相扑）比赛.
&nbsp;
 1 工具和材料
● （使用的工具与零部件列表这里没翻，毕竟相当一部分东西买原版都不太现实也没有必要&#8211;国内的家伙事儿差不多的也能土法上马，有兴趣的童鞋请参考原文）
● 想得到关于这个项目的图示、图纸、代码，请移步 资料下载
2   制作机身

● 机身由两片铝合金薄板制成，涉及的加工方法有切割、钻孔和折弯。你可以一次一片的加工，或者两片一起做以减少占用加工设备的机时。成品见2.5
● 猛击 资料下载 下载图纸并全尺寸打印。剪下底板（base）切割图，用双面胶将切割图均匀平整的贴在铝合金薄板上
● 注意：切割金属时务必佩戴防护眼镜
2.1 切割
&nbsp;



● 用带锯机把铝合金片切成图纸的形状，切割的边缘一定要在线外
● 提示：切割内角时，先切出一个大概的弧形曲线，然后从两个方向直线进刀以得到直角
2.2 打孔

● 用冲子和小锤子在图上有十字线的17处冲出定位孔，为下一步的钻孔做准备。另外要在图上长方形的孔的四个角上冲透

● 按照图上标十字线处的尺寸钻孔，要首先取下贴上去的图纸（不过别扔了），用钻头对准前面留下的冲痕开钻可以使钻孔更精确
● 把金属牢固的夹在废木头板上或者随便什么垫子上，这样可以得到更平滑的孔而不会导致薄金属板在钻孔处扭曲变形
● 为了掏成方形孔而钻圆形孔时，你可能需要调整钻孔的直径以使圆孔边缘与长方形的边相切
2.3 挖槽


● 用冲剪完成对长方形孔的加工，如果你愿意的话可以把前面揭下来的图再贴回去，以便容易知道长方形的边界在哪。最后把边缘磨平




 


● 用手工打磨工具去掉金属边缘的毛刺。给小孔磨边的方法为：把大钻头的尖端插进小孔，然后手工转几下


冲剪是长成这样滴：

&nbsp;
2.1-2.3都是跟合金板过不去的活儿，原作者的办法基本是土法上马，与美帝的高科技风格严重不符。柚子在大学折腾机器人那会儿去交大观摩，他们有加工中心，只要把CAD图画出来发过去，那边用等离子切割机就给“打印”出来了，钻啊、掏异形啊这种活儿根本不存在。更神奇的是切完的边不用磨，基本不扎手。另外我们用土法掏方形孔的时候是先钻大孔，把带锯拆开一头套进去然后慢慢锯，得到的孔要多丑有多丑，然后还得上铁砧拿小锤砸平
2.4   弯板







● 把底板的折弯图用双面胶贴到铝板的另一面，对准圆洞方洞的位置，别贴歪了

● 把铝片贴折弯图的一面向上塞进弯板机里，在所有标示折弯的部位折90度




 



● 每个长边上的两个突出部要先折，然后再折机身的边。（顺序反了就塞不进去了）

● 折弯后要缓慢释放，测量，确认每一处折弯都要是直角


2.5   制作顶板




● 重复2.1-2.4步骤，加工顶板（top），然后你就搞定了每个机器人都会喜欢的底盘
3 运动系统
3.1 安装电机

&nbsp;
● 用4-40 x 1螺丝穿过小孔，将驱动电机定位在底板上，电机的传动轴应该穿过大孔

● 使用螺母和垫片在电机的一端上紧，因为可以施展的空间尺寸很小，可能需要尖嘴钳子（夹住螺母）才能上紧


3.2   制作轮毂





● 用2英寸（外径，合50.8mm）的空心钻头（见过装空调的师傅在墙上钻大洞用的那种钻吧，很类似）在废木头板上钻出轮子（钻透木板之后木板上有个圆洞，钻头中间的洞里会剩下个圆片，这个圆片就是轮子），我用了18号板（貌似是一种规格），最终得到的轮子有3/4英寸（19.05mm）厚，直径1.8英寸（45.72mm）。钻轮子的时候要牢固的固定木板，并且缓慢进刀，防止卡住钻头
● 给2个木头轮子分别对心定位一个轮心（图中白色塑料的小轮子），并用小螺丝标记两个孔的位置，在此位置上用1英寸（原文如此，合25.4mm，不过疑为有误，从图上看孔绝对没那么大）的钻头钻透
● 给木头轮子喷漆，我喜欢红色光面防锈漆，这种东西非常薄，颜色很亮，覆盖性好并且容易清洁。注意，不要在安装孔里喷太多
&nbsp;

3.3   制作轮胎




● 用43号钻头在轮心上钻两个相对的孔，然后用4-40丝锥在每个孔里攻出螺纹



● 用两个4-40 x 1螺丝从木轮外侧把轮子和轮心固定在一起，不要太紧




● 给每个轮子装轮胎，轮胎外径比较大的一面朝外。最后把轮子装在驱动电机的传动轴上
3.1-3.3就是折腾那俩轮子，原作者极其不厚道，没说怎么对心，这个很重要，谁也不希望做完的机器人跑起来一跳一跳的。您还别问我咋对心，我也没经验，新手还是找现成的轮子对付一套比较安全。另外3.2-3.3中原作者留下一个逻辑错误，看出来的童鞋请举手


3.4   安装万向轮







● 使用螺丝、螺母以及垫片将万向滚珠安装在底板底部



4 电控系统
4.1 安装电源

● 按照第一步打印出来的隔板图样，从一块硬塑料上切出隔板（隔板是用来装线路板的，用塑料是为了绝缘），按说明打孔，尝试着塞进机器人的外壳并使之架在驱动电机之上，作必要的修整，令其充分贴合匹配
● 用两个4-40 x 2螺丝将Arduino控制线路板与硬塑料隔板固定在一起，螺丝应从隔板下方穿入，并在线路板上方拧螺母。线路板上的USB接口需要和机器人面板上预先留好的开口充分对齐



● 将电池夹具铆接在机器人外壳的左侧面板上，预制的铆钉头朝外，这样的话丑的一头就朝里啦
关于铆接，这里指的不是造泰坦尼克的那种把烧红了的钢制铆钉插进去挤兑一下的工艺，而是一种将铝合金预制铆钉的开放端在常温下挤压成型从而将两个或更多构件固定在一起的方法，最常见到的是各地马路边的刮大风能掉下来砸死人的铁皮广告牌子，它们就是用这种工艺把镀锌薄钢板固定在L字钢框架支撑结构上滴


4.2   控制板




● 按照制造商的教程，把原型板（ProtoShield）焊好教程在 这里
● 用带锯机把板子上的BlueSMiRF接头切下来，这个接头是用来连接蓝牙模块的，我们的机器人用不到那东西。是不是锯得很爽？
● 把面包板接在原型板上，原型板插在Arduino上，如果用的是Diecimila（Arduino主板的一个版本），那么将电源跳线设置在EXT位上


焊接原型板绝对不是个轻松的活儿，没基础的童鞋搞不定也不用纠结。面包板（breadboard）是这么个东西，其意义在于省了烧电烙铁的麻烦，不过问题是有时候元件捅进去会接触不良&#8230;
&nbsp;

&nbsp;


5 给WALL·E安上一双明亮的眼睛
5.1 WALL·E的脖子

● 咱这个项目用的是HS-55型舵机及与之配套的较短的一字舵角，用5&#8221;钻头对舵角最靠外的两个孔进行扩孔

Du-Bro Mini E/Z 连接头, #DUB845

微副翼系统 Du-Bro Micro Aileron System, #DUB850
● 将两个Du-Bro Mini E/Z连接头从正面穿过摇臂两端的孔，并在反面用黑色橡胶的部件固定
● 将控制杆（图中所示的细铁丝样东西）穿过Du-Bro Mini E/Z连接头，并用连接头附带的螺丝拧紧


5.2   WALL·E之眼





● 有挑战性的工作来咯！咱们需要把舵机和超声波探头接在一起。把从舵机上伸出来的控制杆分别穿过位于传感器电路板对角的定位孔（这个定位孔来自Du-Bro Mini E/Z连接头，连接头又插在板子上的螺丝眼里，然后另一端用那个黑橡胶部件固定）并向外折成90度角
● 控制杆应该从舵角开始竖直向上，并且给超声波探头留下足够插信号线的空间，传感器正面（有收发端，也就是像俩小眼睛的那一面）朝前，控制杆上还应该套上绝缘套（就是那个塑料管）以防止短路，绝缘套在Du-Bro套件里可以找到。确认安装无误后，将控制杆与传感器上的连接头拧紧。
Du-Bro是美国的一家生产模型配件的公司，很遗憾我没找到这些产品的国内版本。欢迎在国内见过这些配件的同学提供信息


5.3   给WALL·E安上一双明亮的眼睛





● 将舵机和超声波探头出来的线穿过机器人外壳顶部预先留下的长方形开孔
● 舵机也要插进那个顶部开孔，调整好位置后两边用螺丝与螺母将舵机与外壳固定好，剪去多余的控制杆(还是那个细铁丝)
● 把舵机摇臂与舵机上到一起，用小螺丝刀调整一下保证Makey的眼睛（传感器）朝前


6 连接并测试驱动电机
6.1 电机预处理


● 咱的地摊货电机上的连接头部件是很脆弱滴，所以连接部分一定要用心
● 从外壳里拆出电机和Arduino线路板
● 切2红2黑各12英寸（304.8mm，12寸炮是305mm的，比如筑波级的2*2主炮）电线，每条线的两端1英寸（25.4mm）剥去绝缘皮。先别焊接，用一个红黑线对在电机的末端（有电源接点的那一端）缠几圈，以防止拉断，然后让线对从电机顶端通过，用双面泡沫胶带将其固定在电机上。注意不要覆盖电机上的任何孔洞，同时要为电机的固定留足空间



 



● 将电容的两个引脚分别穿过电机接线头上的小孔，焊接（这里应该是把引脚穿过去的部分和同一根引脚的根部焊在一起，这样的话引脚和电机接线头就充分连通了。注意，千万别把俩引脚焊在一起！）这需要使用尖嘴钳的巧妙掰弯手法。然后把给电机供电的电线头与电容引脚，注意，不是电机接线头，焊在一起，焊牢稳一些。再然后剪掉多余的电容引脚。把电容和缠在电机末端的电线一起用黑胶布（也就是绝缘胶带）紧密的缠在电机上，并且用更多的泡沫胶带把这个鼓鼓囊囊的位置包起来（还是为了固定）
● 把漏在外面的电机供电线拧成双绞线，这样可以减低电路中的噪声（一个供电的低压直流线路里有点噪声怕什么？原作者的想法好奇怪）。给电机标出左和右



在电机上并联了一个电容，这样做有两个好处。
其一，在稳定的直流电路里，电容是开路，不会影响电机工作，但是给电机通电的那一瞬间，电容因为要充电，可以分担一部分电流，所以电容作为一个保护器件可以保护电机。
其二也是更重要的，这种直流电机的接线头是一个铜合金片，从电机的塑料外壳里伸出来（通常被和塑料铸在一起），鬼知道奸商们用了什么材料，反正这个东西非常脆，尖嘴钳上去经常能掰断，然后这个电机就没啥抢救的价值鸟，另外这个铜片不怎么粘焊锡，焊接不易。但是电容的引脚一般都是类似铝、锡一样的柔韧金属，想怎么扳都能成形，焊起来也容易得多，所以作者把电气连接的活儿都转到这个引脚上来做。
【连电机的小经验】铜接线片作连接之前最好用细砂纸小心的蹭几下，去掉氧化物。电容线脚穿过去之后轻轻拉紧，在穿孔附近用尖嘴钳用力捏一下，使线脚与铜片充分接触。另外电线最好挑独轴的，也就是绝缘皮里面只有一根金属的，那种绝缘皮里有一束极细铜丝的线焊起来会有想死的冲动
6.2   电机测试
&nbsp;



● 将短实心跳线分别焊接到电机供电线和电池接头线上，这些跳线可以让你把它们（电机和电池）插到面包板上，焊接之后用热缩胶带作焊点的绝缘（用绝缘胶布缠是一样的，除了丑一点和大一点）。将电机供电线穿过塑料隔板（4.1提到的那个）上的大窟窿（因为面包板和电机分别在隔板上下两侧）
● 按图示把电机驱动器插进面包板中间的一行孔里，使之和电机以及一个电池连通（注意，在面包板上，每一行的孔之间是连通的）。使用短跳线并保证这些线紧贴面包板，傻大黑粗的大电线是不配塞进机器人里的
● 从 Arduino官网 下载Arduino的软件并且安装之，再从 资料下载 处得到这个项目的5个测试程序。通过USB接口把你的Arduino和电脑连起来，如果你用的是Diecimila版本的话，把它的电源跳线接换到USB档上。
● 为了测试电机，运行名为01_Test_Motor_Rotation的程序，此时左边的电机应该先往前转再往后转，然后是右边的，先往前再往后。如果不是这样，检查一下你的接线。接下来运行02_Test_Motor_Speed，此时电机应该以低速启动，然后加速，最后反方向转，如果不是这样的话检查线脚D11和D3



7 连接并测试舵机和传感器
7.1 连接舵机

● 将电机和Arduino再装回机器人里面，找两个3针的单排直角插针（通常是将一个20针的单排插针折断得到）插在面包板上，把舵机线接在上面，具体接线规则为：黑线-GND（地线，电池负极），红线-+5V（电池正极），黄线-Arduino跳线D10
● 再来一个3针右转接头，这个是接超声波探头的，接线规则为黑线-GND（地线，电池负极），红线-+5V（电池正极），黄线-Arduino跳线D9
7.2 测试舵机和超声波探头
● 运行舵机对中程序03_Test_Servo_Center，松开舵机摇臂的螺丝并微调，舵机臂与超声传感器尽量指向正前，因为舵机轴齿轮的问题，这一步可能无法完全对中，没关系，我们稍后再调整
● 运行程序04_Test_Servo_Sweep，这个程序可以让超声波探头慢慢的摇头
● 再来测试超声波探头，运行05_Test_Sensor_Distance，点击Arduino软件的数据流监视器图标，你应该能看到不断跳出来的测距读数，而且如果你在传感器之前挥舞你的手，测距读数应该有变化。如果你得到的读数始终是0或者255厘米或者别的什么错误的读数，检查你的接线是否有误，并且千万确定你的传感器没接反 ：P
7.3 安装开关

● 终于可以接电源开关鸟！把Arduino最后一次拆出来，为了装开关，需要把还没用到的电池引线的红线焊在开关的一端并且把另一跟红线焊在开关的另一端。同样别忘了把电池的黑色引线和另一个根黑线焊在一起
● 把线从机器人侧面的方形孔穿好，开关需要打在“1”的档位上，把开关塞进方孔里固定好，这个调整可能会用到钳子
● 把从开关出来的红色线脚接到原型板的RAW线脚上（这个线脚还连着Arduino的Vin线脚），把从电池出来的黑色线接到原型板的GND线脚上，如果你用的是Diecimila版本的话，把它的电源跳线调回到EXT档上
8 系统测试

● 现在所有的电子设备工作都正常鸟，小心的把所有东西塞回机器人里，啥也别落下。装好电池，把机器人放好，别摔了。用来传程序的USB接口应该能从侧面的孔里露出来
● 重新载入并运行01_Test_Motor_Rotation，注意，所谓前是指机器人的USB接口和传感器指向的方向，如果你的机器人反着跑，检查在线脚AOut1, AOut2, BOut1, BOut2, AIn1, AIn2, BIn1, 和 BIn2处的接线，可能也会需要反转驱动电机的连接

 


● 重新运行其他的测试程序，确认接线正常，测试完成后把舵机和传感器的线塞进外壳里，扣上顶盖，拧上4个螺丝固定，收工！
&nbsp;
9 给你的WALL·E注入灵魂

● 有时候你的硬件做好了你就没啥事可干了，不过你的程序是写不完滴。这也是你展示创造力的好时机
● 在代码中你需要使用digitalWrite和analogWrite这俩函数来控制驱动电机，通过传递值给电机驱动器的各3个线脚。其中一个可以接收介于0到255之间的值，用于控制传给电机的电流大小，这个是用来控制速度的。另外2个线脚则使用布尔型变量，用于决定每个电机两端的电位高低，这个可以决定电机的方向（当然电机两端只能一端是高电位）
● 你可以编写类似void Forward()这样的函数实现简单的动作，比如后退（两个电机同时反转），Spin_Left（原地左转，右轮正转左轮反转），Arc_Left（画弧左转，右轮正转左轮不动）之类的。Arduino的编程环境使你的代码实验和加载都很方便
● 另外一个好玩的事情是规避障碍，只要运行这样一个循环：往前走，读取测距信息，如果障碍物太近则采取躲避动作比如后退并转弯，返回循环体头部
10 关于Mini-Sumo（迷你相扑）比赛
● 在 Mini-Sumo 比赛中，两个自主机器人会被放置在一个用白色漆成的圆形场地中
● 只要换上窄一些的轮子，比如GM家卖的 这种 ，Makey就可以满足大赛要求的尺寸和重量上限：底面10厘米见方、500克。你极有可能需要另外的朝下的传感器用来观察那个白色的环（场地边界），不过Arduino有足够的能力处理其他多出来的信号
11 DIYer签到处
虽然这个项目很困难，不过也不是完全不能做。如果哪位蛋疼的同学把它做出来了&#8230;应该会很愿意在这里秀出来让大家围观吧&#8230;
&nbsp;
制作视频：


















自主机器人：你的私人WALL·E，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>118</docid>
    <url>http://www.geekfan.net/13900/</url>
    <title>牛人自制加特林水枪，让你度过丧心病狂的夏天</title>
    <content>
（该项目来源于instractables，原文链接在这里，作者：projectsugru。该项目各步骤主要展示Sugru凝胶（或者是某特种粘土，本文统一译为Sugru凝胶）的应用，对加特林水枪的制作过程没有记录，但文后给出了各零件的图纸，相信DIY达人还是能搞定的。）
夏季的疯狂离不开水枪，我们要做一支史无前例的、帅到没边的加特林水枪，废话略，开始吧。
&nbsp;

Step 1： 制作活塞



本步骤器件清单
PVC管一段，特种粘接剂（两种颜色，名为Sugru，以下称Sugru凝胶），锯子、夹具、锤子、雕刻工具和一杯肥皂水。
步骤：
1、用夹具夹住PVC管，锯下需要的长度（我用了2.5cm长）；
2、将肥皂水涂在工作台面上（防止Sugru凝胶粘在台面上）；
3、打开两小包同色Sugru凝胶并混合，把Sugru凝胶填充进刚切下的管子里，要完全塞满；
4、放置24小时让Sugru凝胶固化；
5、Sugru凝胶凝固后，将这段管子纵向置于夹具中，把PVC管切开小口（注意不要切到里面的Sugru凝胶）；
6、用锤子敲击这段管子，直到把外面的PVC管敲破，得到一段圆柱形Sugru凝胶；
7、用雕刻工具加工圆柱凝胶两端，去掉部分材料，这有助于让活塞更湿软；
8、在这小段Sugru凝胶圆柱中部，沿周向雕刻环形凹槽；
9、打开第3包Sugru凝胶，滚成细长条并填充在上一步做成的凹槽上，注意让环状填充物的周长略大于Sugru凝胶圆柱，并放置24小时；
10、固化后，就得到一段活塞了，可以把它浸入肥皂水中。
&nbsp;
Step 2： 做Sugru凝胶注射器

&nbsp;


本步骤器件清单
Sugru凝胶一小包、壁纸刀、可弯曲的塑料管/软管、金属杆（或适合把Sugru凝胶推入管子的东西）、X2金属连接件、螺丝刀。
步骤：
1、用壁纸刀切下一段塑料管子（我们切了4cm长）；
2、打开一小包Sugru凝胶，用手指捏成条状（享受这种感觉吧）；
3、继续将Sugru凝胶滚成细长条；
4、用金属杆把Sugru凝胶推入塑料管子，从管子的两端推Sugru凝胶，确保Sugru凝胶塞满管子正中，两端留出1cm的空管子，静置24小时；
5、固化后，在Sugru凝胶中心钻通孔，孔径按你的需要确定即可；
6、在这段塑料管子外套上金属连接件。
Ok，Sugru凝胶注射装置就搞定了。
&nbsp;
Step 3： Sugru凝胶绝缘开关


本步骤器件清单
Sugru凝胶一小包，漆包线，电烙铁和焊丝。
步骤：
1、用蓝色交联剂将用到的漆包线固定在恰当位置。
2、预热电烙铁，把两条线焊在合适的位置，确保焊点牢固。
3、取少许Sugru凝胶涂在焊点上，抹平，塑形。
4、放置24小时固化。
&nbsp;
Step 4： 用Sugru凝胶连接和密封几段管子
&nbsp;



本步骤器件清单
Sugru凝胶一小包，各种需要的管子（粗管、细管、渐缩管）。
步骤
1、摊开并排好所需零件。
2、用渐缩管连接管子。
3、将Sugru凝胶涂于连接处，注意Sugru凝胶必须完全覆盖连接点并超出连接部分，这样才能提供足够的结构支撑。
4、抹平Sugru凝胶并放置24小时固化。
&nbsp;
Step 5： 定制Sugru凝胶手柄



本步骤器件清单
Sugru凝胶4-5小包，手柄。
步骤
1、打开一小包Sugru凝胶，润湿，让它软化。
2、从手柄底部开始涂抹Sugru凝胶（不够再开一包）。
3、继续一点一点地覆盖手柄，确保Sugru凝胶连成一片，完全覆盖了手柄表面。
4、手柄全部覆盖后，可以考虑用嵌入另一种材料的方法给手柄加纹理，我使用了背包带，你也来点创意吧，比如有人用海绵、牙刷，甚至橘子。
5、在Sugru凝胶固化前（从开包到开始固化，有30分钟时间），还可以用力抓握手柄，这样可以印出个性化的抓握痕迹。
&nbsp;
Step 6： 用Sugru凝胶做护边




本步骤器件清单
Sugru凝胶1小包（实际只需要半包就可以保护每根管子）。
步骤
1、打开一小包Sugru凝胶，润湿。
2、取一半，并滚成两个等大的小球。
3、在金属碟尖锐处敷上Sugru凝胶。
4、塑形、平滑Sugru凝胶，确保管子连接正常，放置6小时固化。
5、检查管子和槽孔的配合，注意，如果Sugru凝胶使用过多，可以用壁纸刀在固化前切一点下来，如果Sugru凝胶用得太少，因为Sugru凝胶的粘连性很好，所以只要再加一层就好。



Step 7： 用Sugru凝胶固定松动部件


Step 8： 激光切割件的Dxf和Pdf文件


这把水枪制作周期长（超过60小时的团队工作量，还有许多无法入眠的夜晚），我们没有记录下全部过程。
实际制作这个大杀器是件令人兴奋的事情，Dxf文件给出了该项目中各组件的激光切割模型，请在这里下载，Pdf文件仅供快速预览，可以在这里下载。
文件的比例是1：1，铝合金零件厚4mm，不锈钢零件厚3mm。
相信这些文件能给你更高的起点。


附件：

3mm stainless steel V2.DXF
3mm stainless steel V2.PDF
4mm aluminiumV2.dxf
4mm aluminiumV2.PDF
V2.ISO.PDF
V2PARTS.PDF
&nbsp;
视频   





牛人自制加特林水枪，让你度过丧心病狂的夏天，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>119</docid>
    <url>http://www.geekfan.net/13876/</url>
    <title>自制拉风电动滑板，回头率太高有点不习惯</title>
    <content>创意是参照了@动力老男孩的一篇文章，最初的想法是DIY一个可穿戴的动力轮，像鞋子一样穿在脚上，不用的时候可以自动折叠收在小腿和膝盖处，用的时候可以伸张成轮子电力驱动快速前进，有点像哪吒的风火轮，主要是受《变形金刚》和《钢铁侠》两部电影毒害太深。后来发现水平极其有限，买了很多零件设备却做不出个所以然，东西都搁置在一边大半年。有天在网上看到动力老男孩的视频是把活力板改装成动力滑板，觉得我所有的材料都有了，就是差一块活力板了，于是速上某宝买了一块。然后就是水到渠成了。
废话不多说，下面上图，有的细节就省掉了
铝合金活力板，6寸皮带轮，皮带，120W有刷电机，控制器，安装支架，万向轮4寸
电池，遥控车手柄，铝盒。这些材料都是网上淘的，如下图：

1，活力板直接卸掉原来的轮座。

2，前轮用4寸的万向轮代替，万向轮的安装孔距（75*45）与活力板（65*35）的不一致，需要自己重新开孔对位，有点麻烦，不过也就是几分钟的事情，开孔搞定。


3，后轮找不到合适的支架，直接买了铝合金自己开孔加工的，这个花了两三天时间，因为要同时考虑电机、后轮、皮带和齿轮的重合，肯定要在一条线上面了，不然跑着跑着皮带跑偏掉链子了。电机架是用50*50的角铝做的，后轮支架用的是40*80*40的槽铝与铝排用螺丝铆合，图纸如下。图纸设计好后加工就容易了，手钻定好位，直接开孔就好，把握好力度不要打偏了就行。
电机架

后轮结构


4，duang，后轮和电机的安装就搞定了

机械结构主要工程完工，下面搞控制器。
5，控制器、电池和保护板都是网上买的，根据要求设计尺寸，然后点焊成2并7串，钴酸锂电池29.4V，刚刚配24V的电机，加上均衡充保护板，与控制器一起安装在铝盒里面，然后外接了航空接头和充电口。具体步骤省略，九芯航空接头是为了方便控制手柄接入，引出控制器的速度控制，开关，电量显示，刹车一共9条线，有三条是GND可以共用，其实七芯就可以了。



6，为了降低成本，没有使用无线控制，本人对无线控制接收也是一无所知，所以使用传统的有线手柄。控制手柄纯手工打造了，将玩具枪里面的扳机改造了一下，在扳机上加上两颗钕铁硼磁石，在两颗磁铁活动范围中心位置固定霍尔元件。原理跟电动车手把是一样的，转把里有一个感应磁力线大小的线性霍尔元件，手柄里还有两块磁铁，扳机转动磁铁也跟着转动，霍尔感应到磁力信号 就给控制器发出信号，从而控制电机转速。刹车也是改动了扳机，扳机往前推的时候触碰到一个非自锁开关，就能刹车，松开后开关会复位。另外在玩具枪上加上一个拨动开关控制总电源。电量显示还没想好怎么接，先预留着。



7，续航里程8~12km，最大速度18km/h，总重6kg，比网上销售的400RMB左右的铅酸滑板车行程要远，毕竟是锂电池的，动力比起铅酸也有力一些，另外楼主75kg，里程跟使用者体重也有关系吧。总成本在400元左右，忽略某些零件的邮费成本，因为某些零件比邮费还便宜，有兴趣的朋友自己DIY一台吧。

开出去还是挺拉风的，回头率高了有点不习惯。不过要说明的是由于前轮的直径只有100mm,所以如果路不是很平整的话最好不使用，一个是会颠簸的厉害，另外如果前轮被阻了因为重心比较高很容易摔跤的。玩过滑板的都知道，所以最好在柏油路或者在水泥路面上使用，另外要求路上车少人少最好。
元件清单




序号
物料名称
规格
数量


1
面板
21*85
1


2
后轮
138*24皮带轮
1


3
槽铝
40*80*4*80
1


4
铝板
100*40*4
2


5
轴承
8*100mm
1


6
后轮皮带调节器
通用
1


7
后轮槽铝螺丝
M6*8内六角
4


8
后轮架螺丝
M5*10内六角
8


9
后轮架铆合螺母
M5
8


10
前轮
4寸PU轮
1


11
前轮架
75*45,130mm
1


12
前轮螺丝
M6*30内六角
4


13
垫圈
M6
4


14
前轮减震弹簧
D20*20
4


15
皮带
15*420
1


16
电机
100W 24V 5A
1


17
电机齿轮

1


18
电机螺丝
M5
2


19
电机架锁紧螺丝
M6*8内六角
4


20
电机架（角铝）
50*50*3
1


21
铝壳
106*100*60
1


22
铝壳螺丝
自带
8


23
铝壳固定螺丝
M6*8内六角
4


24
控制器
100W
1


25
电池
钴酸锂18650
14


26
保护板
2并7串
1


27
热缩管

若干


28
插簧
6mm
2


29
接线端子1
VH3.96-3P 手把
1


30
接线端子2
VH3.96-2P 刹车
1


31
接线端子3
VH3.96-2P 开关
1


32
接线端子4
VH3.96-2P 充电口
1


33
电子线

若干


34
充电接口
DC-2.5-2.1
1


35
充电器
24V 1.8A
1


37
九芯航空插头

1


38
九芯航空线

1


39
遥控车手柄

1


41
电压显示

1


42
开关

1


43
触动开关（刹车）

1


44
胶水

若干




&nbsp;
&nbsp;
视频：
自制拉风电动滑板，回头率太高有点不习惯，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>120</docid>
    <url>http://www.geekfan.net/13847/</url>
    <title>人人都能玩航拍 手把手教你装4轴</title>
    <content>
身处浩瀚的影像横流，作为一名影像编辑当然看惯了人体大妞、风光美景、人文纪实，面对雷同的构图和取景显然新潮的拍摄手法和技巧更能吸引我的眼球，而当某日看到乔岩老师剪辑的航拍作品，让我深深沦陷，从此欲罢不能。废话不多说，看视频才是要紧事。

视频来源：《旅游卫视》乔岩 我相信当看到这段视频你也会如我一样震撼，震撼于这段电影感十足的短片拍摄器材仅仅是一个多轴飞行器的。当然如果你看到此处觉得航拍是你想涉及和感兴趣的 领域那么尽情的往下看，如果并非兴趣所在请绕道，毕竟接下来的故事需要一定的学习能力、理解能力和动手能力。 既然多轴飞行器能拍出这么专业的视频，土豪们会毫不在乎的说那买一个不就完了，其实并非如此，6轴飞行器的成品机造价动辄数万元到数十万元不等，而操控也 是个技术活，玩航模的都知道不摔个几次，不坏个几台机器（炸机）想要操控自如谈何容易，所以你还会轻易的任数万元人民币在天上飘来飘去吗？
经过数日的研究购买了零件图并变成了整机图

经过数日的研究最终飞机可以飞了，而它的造价仅仅2000余元.
当然土豪有土豪的玩法，屌丝有屌丝的办法。作为苦逼的互联网编辑，靠工资买个近10万元的6轴飞行器我已经无力吐槽，献血卖肾也并不是明智之举，本来就 亏不是。既然不能一步到位，那我只能脚踏实地从几千元的组装4轴开始，搭载运动摄像机Gopro的拍摄效果虽说不比专业6轴细致震撼，却也能满足一般所 需。(任何四轴及航拍方面的问题可通过新浪微博 @子心昭然 进行交流）  四轴组装基本原理和零件选购 1、4轴飞行器原理和组成： 虽然看似神通广大的高科技产品，其实原理非常非常简单，而所需的零件在某宝上完全可以买到，只需要把他们有序的组装起来，并保障起正常运转。玩转航拍并不再是一个遥不可及的梦想，只要动手就变的容易实现.

我购买的组装四轴用的配件
4轴飞行器的基本配件由机架、电池、电机、电调、飞控、螺旋桨、遥控器、拍摄相机 （gopro、摄像头、微单等）组成，原理为遥控器发射遥控型号，遥控接 收器收到信号传输给飞控（飞行控制器，等同于电脑的主板），飞控将遥控信号转化传输给电调，电调调节不同电机的供电电流以控制螺旋桨的旋转速度从而完成前 后左右，高低上下的飞行动作，而电池负责供电，机架将所有的零件攥在一起,这样飞行器就能带拍摄机器完成在空中的各种拍摄需求。
2、如何选购机架：
搞清楚所需配件和基本原理，接下来的事情就变得目标明确且容易执行。第一步在某宝上购买好配件，原则上只要你够NB，所有需要的东西你都可以通过原始材料 做出来，我就目睹过很多牛人自己做机架、绕电机、烧录飞控板等等.考虑到时间成本和性价比，购买基础零件才是我最为理想的选择。

DJI F450机架，200元购入

机架2根红色2根白色方便区分机头

集成PCB电路板
至于4轴的机架说白了就是类似于宽高相等的十字架，理论上讲只要4个螺旋桨不打架就可以了，但考虑到螺旋桨之间因为旋转产生的乱流互相影响，建议还是不要 太近，否则影响效率。大疆F450是4轴常用机架，某宝上正品价格大概是200左右，山寨机架根据质量几十元到上百不等，好多模友说山寨太软、易摔坏，最 终我选择了DJI正品.
3、如何选购电机：
如果玩过遥控飞机、遥控汽车的人对于电机并不陌生，有无刷电机和有刷电机之分。电动航模飞机一般采用无刷电机做动力，无刷电机相对有刷电机寿命更长、性能更稳定。

朗宇无刷电机4个，单价109元
无刷电机型号标称没有一个统一标准，目前比较通用的一种是内径标识法，即标识电机外转子内 径，从一定程度上能够表明电机的线圈直径和匝数。经常看人说什么 2212电机，2018电机等等，其实就是电机的尺寸，不管什么牌子的电机，具体都要对应4位这类数字，其中前面2位是电机转子的直径，后面2位是电机转 子的高度。简单来说，前面2位越大、电机越肥，后面2位越大、电机越高。 又高又大的电机，功率就更大，适合做大四轴，通常2212电机是最常见的配置。国产电机品牌新西达、朗宇等是性价比较高的电机品牌，新手用足够了。

朗宇2216 880KV电机
一般电机会标识KV值，如“新西达2212 1400KV”，KV值是电机输入电压每提高1v,电机空载转速提高的量。1400KV即说明电机空载情况下，加1V电压，转速为每分钟1400转，2V 电压每分钟2800转，依此类推。同型号电机（比如都是2212）低KV值比高KV值的提供的扭力大，类似于汽车1档的速度虽然慢，但是爬坡更容易。但是 低KV值需要配大桨，很多机型都不适合，会造成严重的反扭现象。 4轴2212 980KV、2212 1400KV是常用配置，最终我买了4个朗宇2216 880KV的电机。
4、如何选购电调：
电调全称电子调速器，针对电机不同，可分为有刷电子调速器和无刷电子调速器。它根据控制信号 调节电动机的转速。简单来讲它的功能是将电池的直流电转化为三 项交流电，并按照接收机的指令调整供给电机的电压，实现电机转速可控。因为电机的电流很大，通常每个电机正常工作时，平均有3A左右的电流，如果没有电调 的存在，飞控板根本无法承受这样大的电流（另外也没驱动无刷电机的功能）。同时电调在四轴当中还充当了电压变化器的作用，将11.1v的电压变为低电压为 飞控板和遥控器供电。

天行者电调4个，单价58元

天行者40A电调
电调都会标上多少A，如20a，40a 这个数字就是电调能够提供的电流。大电流的电调可以兼容用在小电流的地方，小电流电调不能超标使用。常见新西达2212加1045浆最大电机电流有可能达 到了5a，为了保险起见，建议这样配置用20a 或 40a电调。常见的有好盈、中特威、新西达等品牌，我选购的是好盈40a.
5、如何选购电池和充电器：
由于同样的电池容量锂电最轻，起飞效率最高，所以电池一般使用锂聚合物电池，锂聚合物电池单 片电压为3.7V，两片或三片串联得到的电压即为上面说到的 7.4V或者11.1V。mah表示电池容量，如1000mah电池，即如果以1000ma放电，可持续放电1小时。如果以500mh放电，可以持续放电 2小时。

花牌聚合物动力电池，235元购入

花牌5100mAh 25C
在实际选购过程中电池后面有2S、3S、5C等字样，S代表锂电池的节数，锂电池1节标准电 压为3.7v，那么3S电池，就是代表有3个3.7v电池在里 面，电压为11.1v。C代表电池放电能力，这是普通锂电池和动力锂电池最重要区别，动力锂电池需要很大电流放电，这个放电能力就是C来表示。如 1000mah电池标准为5c，那么用5x1000mah，得出电池可以以5000mh的电流强度放电。这很重要，如果用低C的电池，大电流放电，电池会 迅速损坏，甚至自燃。与上面的C一样，多少C快充即快速充电的能力，如1000mah电池，2C快充，就代表可以用2000ma的电流来充电。千万不要图 快冒然用大电流，超过规定参数充电，电池很容易损坏。

科达B6平衡充，188元购入
至于怎么配电池这与选择的电机、螺旋桨，想要的飞行时间相关。容量越大，c越高，s越多，电池越重；基本原理是用大桨，因为整体搭配下来功率高，自身升力大，为了保证可玩时间，可选高容量，高c，3s以上电池。常用的四轴电池为20C、3S电池。

飞科达B6平衡充
有了电池，充电器自然必不可少，一般选用平衡充。如3s电池，内部是3个锂电池，因为制造工 艺原因，没办法保证每个电池完全一致，充电放电特性都有差异， 电池串联的情况下，就容易造成某些放电过度或充电过度，充电不饱满等，所以解决办法是分别对内部单节电池充电，而平衡充则很好的解决了这个问题。
6、电机与电调、电池间的匹配关系：
首先,你要选择适合你飞机的电机，再选择一个能满足你电机峰值功率的电调，最后选择一个能满 足电调峰值功率的电池即可!如电机达最大效率时,电流为 30A，那么你选择的电调起码要30A ,但是一般出去安全考虑,电调要选择大一点的! 如:35A -40A 。电池是根据你的飞机具体来确定用哪种规格，选好规格,那么就可以选择容量倍率了。
7、飞行控制板的选择：
飞行控制板简称飞控，如果没有飞控板，四轴飞行器就会因为安装、外界干扰、零件之间的不一致 型等原因形成飞行力量不平衡，后果就是左右、上下的胡乱翻滚， 根本无法飞行，飞控的作用就是通过飞控板上的陀螺仪，对四轴飞行状态进行快速调整，如发现右边力量大，向左倾斜，那么就减弱右边电流输出，电机变慢，升力 变小，达到平衡的状态。

STM32 MWC10四轴自稳飞控,188元购入
购买飞控的时候老板会问你买X模式还是+模式，简单来说X模式要难飞一点，但动作更灵活。+模式要好飞一点，动作灵活差一点，如果飞控板安装错误，会剧烈的晃动，根本无法飞。常见的有KK、FF、玉兔、MMC等品牌，我购买的是MWC10 四轴飞控.
8、如何选购螺旋桨：
同电机类似，桨也有如1045,7040等4位数字，前面2位代表桨的直径，也就是从桨的一 头到另一头的长度，单位是英寸。后面两位数是指几何螺距，螺距 原指螺纹上相邻两牙对应点之间的轴向距离，可以理解为螺丝转动一圈，前进的距离。而螺旋桨的螺距，是螺旋桨在固体介质内无摩擦旋转一周所前进的距离。简单 来说可以理解为螺旋桨桨叶的“倾斜度”，螺距标称越大，倾斜度越大。桨长度和螺距越大，所需要的电机或发动机级别就越大，桨的长度越大，某种程度上能够保 证飞机俯仰稳定性越高，螺距越大，飞行速度越快。

APC 1147 螺旋桨，单价12.5元

正反桨各一对
四轴飞行为了抵消螺旋桨的自旋，相隔的桨旋转方向是不一样的，所以需要正反桨。正反桨的风都向下吹。顺时针旋转的叫正浆、逆时针旋转的是反浆。安装的时候，一定记得无论正反桨，有字的一面是向上的。
9、电机与螺旋桨的搭配：
这是非常复杂的问题，建议常见的配置，但原理这里可以阐述一下。螺旋桨越大，升力就越大，但 对应需要更大的力量来驱动；螺旋桨转速越高，升力越大；电机的 kv越小，转动力量就越大；综上所述，大螺旋桨就需要用低kv电机，小螺旋桨就需要高kv电机（因为需要用转速来弥补升力不足），如果高kv带大桨，力量 不够，那么就很困难，实际还是低速运转，电机和电调很容易烧掉。如果低kv带小桨，完全没有问题，但升力不够，可能造成无法起飞。常用1000kv电机， 配10寸左右的桨。
10、如何选购遥控器：
遥控器从几百到数千不等，常见品牌有国产天地飞，日本futaba等，根据所需通道和预算购 买即可。通道就是遥控器控制的动作路数，比如遥控器只能控制四 轴上下飞，那么就是1个通道。但四轴在控制过程中需要控制的动作路数有：上下、左右、前后、旋转，所以最低得4通道遥控器。

天地飞7通道 WFT07 2.4G遥控器，493元购入

可以看出我买的是美国手，左边是油门

天7遥控器接收器
遥控器有日本手和美国手之分，油门的位置在右边是日本手、在左边是美国手，所谓遥控器油门， 在四轴飞行器当中控制供电电流大小，电流大，电动机转得快，飞 得高、力量大，反之同理。判断遥控器的油门很简单，遥控器2个摇杆当中，上下板动后不自动回到中间的那个就是油门摇杆。
开始组装4轴飞行器
当 你下定决心做这件事的时候其实最困难的部分已经解决了，明白了四轴组装的基本原理，其实发现并没有我们想象的复杂。在某宝上购买到所需配件接下来的工作就 是大胆心细的去组装了，当然还需要一些基本的工具及小附件，如螺丝刀、热熔枪、双面胶、硅胶线、热缩管、魔术扎带等，备好这些就可以开始组装了。

某宝上购买所需的配件和工具

把配件大概分类整理了一下

先把4个电机和机架杆装好，这个没有什么难度，唯一需要注意的是红色的轴是为了飞机在空中更容易辨别机头的方向，易于操控，注意不要和白色交叉固定在集成板。

装好电机的效果，注意先不要装螺旋桨。

复合PCB电路板，其作用是供电调、电源的连线可以更加方便、快捷、安全，将4个电调和电源输入线用电烙铁焊在板子上。放心大胆的操作，我在焊接这个板子之前无任何焊接经验，本次焊接效果非常好。

电烙铁套装，不会操作的可以百度一下相关的视频教程，一看就会。

焊接的时候正负极千万不能弄错，红色的线连接正极，黑色的线连接负极，线路板上有正负极标识，正极焊接红线，负极焊接黑线。电源输入线是我用T插头和硅胶 线自己做的，结果往PCB板上焊接的时候正负极搞错了，以至于我连接电池造成短路，电线瞬间发烫变软，还好及时察觉，重新焊接了路线。大家对于正负极的焊 接一定要非常仔细，千万不要搞错。
焊接了电调之后，可以把机架和线路板固定在一起了，注意较大的板子是底部

用附带的螺丝固定好底部的板子之后，接下来可以利用双面胶把飞控板粘在上面

用双面胶把飞控板粘在线路板上之后尽量多挤压几次，保障粘贴结实，这里需要主要的是电路输入的一头（即飞控板上箭头的指向的一方）朝着飞机机头的方向。

固定好之后就需要将电调、遥控接收器的线路连接到飞控板上，注意线路有正负极以及信号线之分，连接的时候需要一一对应，至于具体接法按照下图来接就行。

飞控板的线路连接规则按照上面这幅图（点击图片可看大图）来就行

遥控接收器的线路连接也是参照上图

连接好飞控板和遥控接收器的线路之后，就可以将机架上面的板子和机架用螺丝固定好

最后一步是安装螺旋桨，这一步需要注意的是螺旋桨是一正一反、一正一反的相邻安装，保证螺旋 桨有字的部分朝上，即螺旋桨旋转的时候气流向下，这样飞机才能 起飞。电机的转动方向还是前面飞控连接的线路图所示，相对的电机转向一致、相邻的电机转向相反，机头朝向的两个电机都是向内旋转，机尾朝向的两个电机都是 是向外旋转。至于电机和电调的线路接法，随意连接，调整其中的任意两根的线路连接保证电机的转向如上所说即可。完成之后把电池用魔术粘带绑定在飞机机架上 即可，电池输出连接线路输入。至此、一个能飞的四轴飞行器基本上完成，为了保证4个电机旋转速度一致，需要设置油门行程等，这个在电调说明书有详细说明， 非常简单，照说明操作即可。
制作一个减震起落架
四轴新手在操控的时候难免会缺乏经验，加之由于组装机器本身优劣问题并不能保证飞行和降落会非常平稳，为了减少对四轴飞行器的损伤制作一个简易的起落架非常必要。下图是我后来购买的所需材料，碳纤管、起落架、海绵减震套筒等。

起落架所需材料

组装好的起落架

用尼龙拉带将起落架和四轴飞行器固定在一起

一架四轴飞行器组装完成，接上电源就可以飞了

上天了，飞行效果很好 从查找资料，研究原理，购买配件到组装成机，我大概花费了半个月下班的时间，配件全部购于某 宝，成本大概在3000元以内，后来我又拿DJI精灵2做对 比，自己组装的四轴无论速度和力量明显优于精灵2，但是由于飞控和整机配件兼容性的问题，在定点悬停、失控返航方面远远不抵精灵2.希望此文能给诸多喜欢 航模、喜欢的航拍的人一个很好的思路，其实多轴飞行器最核心的还是控制算法的问题，即飞控板的调节控制能力。无论是之前网络热传的飞行器送快递也好，还是 央视报道的农民用飞行器喷洒农药也罢，相信我，四轴飞行器将会越来越多的被我们以各种方式运用到生活当中，当然航拍也会越来越便捷，越来越大众化。 最后给大家分享一个非常NB的视频，来自国外牛人的TED分享。

人人都能玩航拍 手把手教你装4轴，首发于极客范 - GeekFan.net。</content>
</doc><doc>
    <docid>121</docid>
    <url>http://www.phonekr.com/material-playground-flamingo/</url>
    <title>[Material Playground] Flamingo</title>
    <content>不知道你是否还记得第一届 Material Design Awards 的各位获奖者们? 这些应用在今天看来依然是非常优秀的应用, 如果还没用过的话请尽量试用一番. 今天要介绍的这款应用, 就是来自于第一届 Material Design Award 得主, Weather Timeline 的开发者 Sam Ruston 的一款新应用 —— Flamingo.
Material Playground
Flamingo 是一款第三方 Twitter 客户端. 市面上已经有一些不错的 Twitter 客户端了, 比如 Twidere, Falcon Pro, Carbon 等等, 而在这里特别推荐 Flamingo 的理由是什么呢?

Flamingo 的一大特色就是提供了多而不杂, 基于 Material Design 的主题定制功能. 这个主题定制可不是那种换个颜色意思意思的主题定制, 而是如上图一般, 可以改变整个应用的导航布局的主题定制. 用户可以自行选择顶级导航的数量, 位置, 是否固定, 图标 / 文字的呈现与否, 等等. 当然, 颜色的定制也是无比详尽, 让人不由得想起了另一款 Twitter 客户端 Tweedle.

作为一款 Twitter 客户端, Flamingo 提供了基本所有的基础功能, 还做了一些好玩的附加功能, 比如说在发推的时候可以直接从 Giphy 搜索 GIF 图片. 另外, Flamingo 还提供了长按预览图片和用户的操作. 实际使用时非常便利.

很多人都非常喜欢 Twitter 客户端在点下桃心时的动画, Sam 把这个动画也搬上了 Flamingo. 不仅桃心有动画, 转推时也有相同的动画, 让使用时的愉悦感再次增加不少.

查看用户个人资料时的详情页, 会根据用户的头像颜色改变主色调, 算是 palette library 比较常见的运用了. 设置里的选项在丰富的同时不杂乱, 大部分都可以让人一眼就明白是干什么用的. 比较可惜的是用户不能在更改配色 / 样式时实时预览, 这对于那些对部件名称不甚熟悉的用户而言并不友好. 不过考虑到会用到高级的定制功能的用户想必都不是对这些名词一无所知的人, 而真对此一无所知的用户也可以愉快地在默认主题里找到自己心仪的一款, 这个瑕疵就显得不是那么严重了.

Flamingo 提供了十二款不同的默认配色, 可以满足绝大多数用户的需求. 而如果你在 Flamingo 登录了多个 Twitter 账户, 你还可以选择为他们单独设置不同的主题.
Flamingo 当然也提供了更详尽的更改配色功能, 不过 Sam 在这方面做了一个明智的选择: 他将可供选择的颜色限定在了比较小的范围内, 而不是像很多其他提供主题定制的应用一样, 干脆丢一个 RGB/HSV 选择器给用户. 这么一来, 用户既不会在面对大量颜色选择时不知所措, 也免去了对由于用户审美不过关造成的可怕结果带来的担忧. 不过话虽如此, 用户还是可以在如此限定的选择范围内制造出一些瞎眼的组合. 不过至于这个话题, 那就不是本篇文章该讨论的范围了.

虽然如果你在平板上访问 Play Store 里 Flamingo 的介绍页, 会看到上面写着 Designed for Phones, 但是 —— 嘿, 这可是一款出自 Sam Ruston 之手的应用! 从 Hue 开始, 他就一直很注重平板适配, 所以你看, Flamingo 有着出色的平板适配.
Beta 版
Flamingo 尚在 Beta 开发中, 但是 Sam 并没有采用 Google Play 的 Beta 发布, 而是直接将其公开. 他承诺了会及时更新, 而且在 Twitter 上也非常积极地听取着大家的反馈. 但是由于这款应用尚在开发中, 所以运行起来并不是那么稳定. 大多数用户都或多或少地遇到了一些崩溃. 所以在 Sam 决定摘下 Flamingo 的 beta 帽子前, 并不建议将其作为唯一的 Twitter 客户端使用. 不过, 如果你是一个对设计精良的应用感兴趣的用户, 或是想要学习优秀 Material Design 设计的设计师, 那么这 $0.99 绝对会让你觉得物有所值.
Play Store 连接: Flamingo for Twitter ($0.99)

</content>
</doc><doc>
    <docid>122</docid>
    <url>http://www.phonekr.com/motion-growth-communications/</url>
    <title>Material Design 更新: 动效, 增长与用户教育</title>
    <content>今天, Material Design 迎来了毫无预兆的一个大更新, 突然地完善了 (本应在两年前就有的) 动效设计讲解与加入了面向中小团队与个人开发者的初体验设计指导.
Motion
Material Motion &#8211; Google Design

&nbsp;
动效设计这个部分经过了一番彻底的改头换面, 增加了不少详细的说明 (看到上面这张图相信不少已经试过制作 Material Design 风格动效的设计师们应该会露出会心的苦笑吧, 现在终于可以不用自己去费精力摸索其中的规律了), 包括动效持续的长度, 加速度的使用, material 的移动, 创建与消除, 等等, 几乎涵盖了 Material Design 动效的全部细节, 还指出了一些常见的错误 (这点非常重要, 有很多设计师 / 开发者凭着来源不明的经验模仿 Material Design 动效, 做出来的东西千奇百怪, 令人不悦, 完全丧失了 Material Design 动效的初衷), 值得对动效感兴趣的开发者和设计师仔细阅读.

&nbsp;
更新里还包含了对于图标动效和载入动画的一些有趣的建议, 千万不要错过.
Growth &amp; communications
Introduction &#8211; Growth &amp; Communication &#8211; Google Design

用户教育的部分, 一直以来都为 Android Design/Material Design 所忽视 (虽然 ADiA 有一期专门的节目介绍), 但这次是 Google 第一次为用户教育模块写下详细的介绍. 对于中小团队和个人开发者而言, 初体验设计对于应用的生死存亡而言至关重要, 这次 Google 终于给出了一份指导文档, 还是很有意义的.


初体验设计的模块中, 包括了非常常用而至关重要的空界面设计, 内容定制模块, 功能介绍等等, 都附有详细的设计图.
 

当然, 你也可以按照自己的思考来进行定制, 不过至少 Google 终于给出了一个参考标准.
另外, 这个模块强烈建议配合 Google Primer 服用, 效果倍增.
初体验设计的模块中, 包括了非常常用而至关重要的空界面设计, 内容定制模块, 功能介绍等等, 都附有详细的设计图.
</content>
</doc><doc>
    <docid>123</docid>
    <url>http://www.phonekr.com/material-bottom-navigation/</url>
    <title>Bottom Navigation —— 如果要用, 请认真用</title>
    <content>在 π 日, Google 对 Material Design 进行了大家期盼已久 (说句实话, 这里的 ｢期盼已久｣ 换作 ｢又惧又期待｣ 会比较合适吧) 的更新, 加入了对 bottom navigation 的明确规范.


Navigation Patterns
Component &#8211; Bottom Navigation


&nbsp;
如果你的应用：

有 3-5 个顶级导航；
需要频繁在顶级导航项之间切换；
希望顶级导航项能够吸引用户的注意力；
只针对手机；

那么， 便可以考虑使用 bottom navigation.
Material Design 的 bottom navigation 与 iOS HIG 规范的 tab bar 理所当然地有共同之处:

就算进入子级界面, bottom navigation 依然显现;
在顶级界面中, 点击 bottom navigation 当前激活的项目会回到当前列表的顶端.

但是在使用时, 不要直接照搬 iOS tab bar, 毕竟两者还有很多区别:

往上卷动时隐藏, 往下卷动时显现;
当前激活的项目文字会变大 (未激活 12sp, 激活 14sp);
触摸会产生 ripple 反馈;
Bottom navigation 可以有不同的颜色;
可以选用只有激活项带有文字标签, 未激活项仅显示图标的样式;
避免在平板以及大屏设备上使用, 建议转换为 drawer;
切换不同顶级导航项时, 内容区采用淡入淡出的动画;
切换顶级导航项的时候, 重置当前导航项的状态 (不保留状态 / 历史);
避免与顶部 tabs (对应 iOS 上的 segmented control) 同时出现.

不管你是不是打算在应用里采用 bottom navigation, 都应该看一看这些规范. 同时, 强烈建议在考虑采用 bottom navigation 之前, 先想想你的应用到底适不适合 bottom navigation.
最后是个人感想: 虽然 Google 不断强调 Material Design 是 ｢一套活的规范, 不是板上钉钉｣, 但是就这样推翻坚持多年的传统多少令人无法接受 — 当然, 实际上令人无法接受的是 Google 先违反, 然后再修改规范的这种行为.
有句话我想大家都很熟悉: ｢存在即合理.｣ 这里姑且不讨论这句话的对错, 在 UI/UX 的讨论上, 某种范式的出现必然是为了解决某种具体的问题.
故, 放下心中的成见, 有的时候, 做有些事情, bottom navigation 是更为合适的解决方案. 当然, 如果它对你而言并不是更为合适的解决方案, 那就更无需为此操心了.
同样的， bottom navigation 也不是万灵药， 它有很多不擅长或者不如 tabs/drawer 的地方， 具体可以参看： 如何看待新版 Google Photos 的 bottom tab bar？ &#8211; NovaDNG 的回答.

</content>
</doc><doc>
    <docid>124</docid>
    <url>http://www.phonekr.com/so-happy-birthday-material/</url>
    <title>So… Happy Birthday, Material!</title>
    <content>(标题请配合 Matías Duarte 在 Material Now 演讲开头中的致辞服用)

(这篇文章, 其实很大程度上是写给我自己看的)
是的, 在去年的今天, Google I/O 2014 上, Matías Duarte 穿着他那一身标志性的花衬衫, 为大家开启了通往 Material 世界的大门.

&nbsp;
想起自己第一次看到 Material Design 的时候, 心里其实是充满了厌恶的. 没错, 那个让我对 Material Design 产生厌恶的应用就是 Google I/O 2014. 到现在为止, 我都还觉得那是我见过最糟糕的 ｢Material Design 应用｣ 之一 (同样糟糕的还有那时刚刚改版的 Hangouts 和 Google+).
同样让我觉得不能接受的还有, Google 从官方色版中, 完全抹去了我最喜爱的 Holo Blue (#33B5E5) 的痕迹.
但随着 Material Design 发布, 它也在快速的发展和完善. 等到 Material Design 正式出现在 Android 上 (Android 5.0 正式发布) 的时候, 已经过了将近半年. 那个时候的 Material Design 已然向大家展现出无限的可能性.
在 Material Design 宣布进入正式版不久之后, 我也开始履行诺言, 着手制作 Material Design Toolkit for Nexus 4. 可以说, 这段制作过程的开始是很不开心的. 可以说, 当时我非常想要 ｢毁约｣. 几乎是骂骂咧咧地, 我一边翻看规范, 一边在 Ps 里画图 — 那时的 Material Design 尚有很多不完善之处. 但是随着制作的进行, 当我为了制作 Toolkit 翻阅第十遍 (以上) Material Design, 逐渐完善我对它的理解的时候, 我渐渐发现, 自己变得不那么讨厌 Material Design 了.
是的, 随着规范自身的完善, 以及我对规范了解的深入, 我开始逐渐领略 Material Design 的美妙. 随之发生的变化就是, 我开始放下 Android Design 了. 又过了不久, 同四年前一样, 我开始宣传起了 Material Design. (同时, 我也渐渐开始改变起以往黑白灰的穿衣风格)
和我不同, 有无数设计师从最开始就对 Material Design 充满热忱. 在 Material Design 发布伊始, 他们就对其给予盛赞, 并且, 他们中的很多人, 都对推动 Material Design 发展做出了贡献. 同时, 也有无数开发者制作出了各种 Material Design 相关的库, 供更多开发者们方便的调用&#8230; 可以说, 一切都是那么的欣欣向荣.
然而 Material Design 依然很年轻. 一方面, Google 依然在致力完善它; 另一方面, 很多开发者, 设计师和用户对 Material Design 的理解仅仅停留在 ｢Drawer 导航 + FAB + 半透明通知栏｣ 上.
而在国内, Material Design 的发展更是堪称步履维艰. 原本我以为, 相比起 Android Design 直到生命末期才出现一份基本可看的中文译本, Material Design 在发布第二天便有了中文译本, 这是一个很好的开端; 没想到, 国内对 Material Design 的热情, 似乎也就只是一阵风一般. 之前如雨后春笋般发表的 Material Design 中文译本, 更新至今的恐怕一只手能数的过来.
我想, 或许, 我们如今所处的状况, 和四年前并没什么区别. 先前在 Android Design 时代积累下来的那一点儿成果, 某种意义上算是前功尽弃. 而在 Android Design 时代就冥顽不灵的那几个最大的阻碍, 如今, 依然, 是最大的阻碍. 他们自身已经是阻碍, 而他们的存在更是产生了恶劣的影响, 加剧了推广 Material Design 的困难.
而我, 当然不能因此退缩. 为 Material Design 庆祝生日, 某种程度上, 也是在庆祝自己的一段新旅程的开始, 为自己加油打气.

所以, 在今年的 I/O 大会上, 当 Matías Duarte 大声说出, ｢Happy birthday, material!｣ 的时候, 骄傲, 激动与心酸一同涌上心头, 让我几乎快要哭出声来.
希望, 在接下来的日子里, Google 能继续完善 Material Design — 不单是设计规范的方面, 同样还有 Android 开发的方面.
在这个重要的日子, 我要大张旗鼓地为 Material Design 庆祝生日. Happy birthday, material!
</content>
</doc><doc>
    <docid>125</docid>
    <url>http://www.phonekr.com/bilibili-for-android-redesign/</url>
    <title>Material Design in Action — 哔哩哔哩动画 Android 客户端</title>
    <content>前言
哔哩哔哩动画是中国大陆的一家弹幕视频网站，在中国二次元用户中颇受欢迎。
哔哩哔哩动画之前推出过采用 Android Design 的 Android 客户端，虽然有使用了部分过时控件（例如 Scrollable Tabs）之类的问题，但整体素质依旧较高，受到 Android 用户的广泛好评。而在 6 月初的 3.9 及 4.0 更新后，哔哩哔哩抛弃了过去的 Android Design 转而使用了 iOS 风格的设计，如图所示：
左为 v3.3.0，右为v4.0.0
此次更新在用户中的争议颇大，部分用户反对此次改版，认为新版哔哩哔哩动画客户端失去了原有的 Android 风格，令人失望。
个人认为哔哩哔哩的情况比较特殊：原来进行过 Redesign 的应用有一开始就是 iOS 风格的，也有采用 Android Design 风格，但并不完美的。对哔哩哔哩这种原来是 Android Design 风格，但后期转换为 iOS 风格的 App 进行 Redesign 是一件很有挑战性的事情。于是在对新版进行了一段时间的体验之后，我开始利用新版的特性和部分交互逻辑对哔哩哔哩动画进行基于 Material Design 的 Redesign 尝试。
在微博上发布了几张预告效果图之后，我意外地收到了认证资料为“bilibili副总裁”的微博用户 @光头哥光头哥 的私信。因为在私信里这位微博用户对一些问题进行了询问，加上设计师在知乎上对于这次设计风格改变的解释，我认为哔哩哔哩本身是想采用 Material Design 的，然而对于 Material Design 本身并不是十分了解，因此才会采用 iOS 的设计风格。
我个人对哔哩哔哩的态度感到很欣慰，希望能在以后拿出更好的设计。
我也希望我的这篇文章能够起到一些帮助。
对底部 Tab Bar 说 No
在文章开始之前，我想先回答之前 @光头哥光头哥 在私信中提出的一个问题：为什么安卓用户对底部 toolsbar 这么介意？
首先要纠正一个用词错误：用于切换不同页面的 Bar 叫 Tab Bar，而不是 Tools Bar.这点在 Apple 官方的 iOS 7 UI Transition Guide 中也有提到。
Apple 官方对于 iOS Tab Bar 的解释
那么纠正完用词错误，接下来就要回答这个问题了：为何 Android 上最好不要出现底部 Tab Bar 呢？
首先，Android 提供了更多样的交互方式，例如 Drawer，Floating Action Button 等。活用这些交互方式可以灵活地将用户引导至其他视图上。
其次，即使要使用 Tab Bar ，Google 官方也已经提供了解决方案——各式各样的顶部 Tab Bars.而且，顶部 Tab Bar 均可以滑动切换，这样就无需担心单手操作性了。
Tabs!
另外对于虚拟键用户来说，使用底部 Tab Bar 也会带来“双底栏”的问题，影响美观性。
（并不是针对HTC）
所以，在 Android 上使用底部 Tab Bar 是一种毫无必要的行为，不仅不会对单手操作带来任何便利，反而会造成更多的麻烦。
Google 很早就谈到了这一点：Pure Android 页面中列出了很多“不该做”的事情，其中之一就是“不要使用底部 Tab Bars”。

之前 @光头哥光头哥 和我提到过，因为哔哩哔哩的内容架构极其丰富，于是想把内容的分类筛选在页眉留给用户。即使是这样，采用双 Tab Bars 也没有多大必要，可以参考第一点，使用其他方式实现原来底部 Tab Bar 的功能，我会在下面提到我是如何去实现这一点的。
1.首页
对首页的改进是整个 Redesign 中最重要的一环之一，毕竟这次设计争议最大的就是采用底部 Tab Bar 的设计。
我对首页的改进有：
去掉底部 Tab Bar，保留顶部 Tab Bar
加入标准 App Bar，颜色取自 v3.3.0 的 Action Bar
个人信息放入 Drawer
“关注”、“发现”和“游戏”整合入“发现” Floating Action Button
下载、消息（目前似乎客户端未加入消息系统）等按钮单独作为 Action 放置于 App Bar 上
首页项目和 Banner 采用 Cards 设计
如上文所述，我使用了将选项分散的思路，将原先底部 Tab Bar 的选项分散到其他模块。下文我会一一讲解。
当用户向上滚动首页列表的时候，App Bar 将会自动隐藏，只留下 Tab Bar 。一个小细节：我试着使用了类似 Google Play Store 的滚动 Cards 布局展示“番剧更新”项，在最右侧露出 Card 的一端来提醒用户这一排可以进行滚动。
同时我保留了 Tab Bar 的下拉菜单的设计，点击最右边的箭头就可以调出菜单，能直接点击进入 Tab 项，也能对 Tab 项进行重排。2.个人信息
之前的 v3.3.0 及更早的版本将个人信息放在最左边的 Tab ，而最新的 v4.0.0 将个人信息放在“我的” Tab。个人认为这个区域完全可以用 Drawer 替代。
这里的修改不多，主要是以下几点：
个人信息区域加入头图，硬币改为和网页版一致的“B”图标
去掉“离线任务选项”，相应的项目已移动至 App Bar
“设置”“帮助与反馈”放置在单独区域
之前的各个版本，各个平台的客户端均未加入头图项，所以我在做这个设计的时候也思考了一下要不要加入头图，后面对比了几个版本的解决方案，还是决定加入头图。
3.“发现” FAB
v4.0.0 加入了“关注”、“发现”和“游戏”三个 Tab 项目。按道理来说，一个放在 App Bar 上的搜索即可解决问题，但是考虑到“游戏”等项目的特殊属性需要足够的曝光度等，最终决定将这三项合并为一个 “发现” Floating Action Button.如图所示，“发现” FAB 处于屏幕右下方，若用户点击，FAB 中的其他项目会自动展开：
为了让“游戏”“排行”等项在日常使用时能拥有更高的曝光率，我将常用的“搜索”等项放入了此 FAB 。
4.播放页面
第一步

首先当然是采用了“正常”的 App Bar——原来播放界面的 App Bar 高度并不标准。其次在这个界面我使用了不同的配色方案——以标志性的粉色作为底色，字体和图标以白色呈现。同时将“点击播放”按钮去掉，变成点击封面图即可播放，封面图也进行了适当地放大。最后将原先在视频信息下的 Tab 转移到上面，所以一共做的改动有：
更换为正常高高度的 App Bar
将 Tab Bar 提上，与 App Bar 整合
使用与首页不同的配色方案
去掉“点击播放”按钮，和封面图整合
下载、收藏和分享等项集合至 App Bar
添加“评论” FAB
第二步
做完第一步之后我发现，似乎把那些选项都放在 App Bar 上并不是很好的选择。于是我试图对着 FAB 下手，做成了类似首页“发现”的扩展 FAB，如图所示：于是这一步的改进就是：
下载、收藏和分享等项集合至一个 FAB，点击展开
第三步
然而在思考了一会之后，又觉得放一个 FAB 在这似乎有些多余。在 v3.3.0 中，这些选项放置在 Split Action Bar 上，然而 Material Design 中已经去掉了 SAB 。
于是我试图使用 Quick Return 模式来放置这些选项，结果个人还是很满意的：

最后对原来居中的视频标题重新调节成偏上，最终成品如下：最后一步做的调整有：
改用 Quick Return 模式在底端放置选项
将视频标题由居中修改为偏上
5.引导页面
每个 App 在进行设计和交互大改的时候都应该对用户进行引导和提示。微信在 5.2 上启用 Android Design 时就吃了这个亏，直接升级的用户并不知道这个版本会对设计大改，结果改完就崩溃了——这个新界面到底该怎么用？？？
所以如果哔哩哔哩需要启用 Material Design 设计，一定要做一个引导流程让用户知悉新版的变化。
首先是首次启动的引导页，通过强调“新版”来提示用户。之后是一个提示界面，用圈点的形式提示用户原来的功能都去了哪里。同时对于 Drawer 给予适当提示，让用户知道调出 Drawer 除了点击汉堡包图标还能向右滑动调出。以上只是随便制作的，非常粗糙的引导页。相信哔哩哔哩的设计师们能想出更好的主意。
后记
制作这次的 Redesign 是一次充满挑战的历程，我希望这次的 Redesign 能给予各位一些启发。
哔哩哔哩官方已经放话了，正在研究 Material Design。那么就让我们期待一个更好的哔哩哔哩客户端吧~
( ゜- ゜)つロ 乾杯~
彩蛋：好想看Nova做的啊啊啊啊！
</content>
</doc><doc>
    <docid>126</docid>
    <url>http://www.phonekr.com/you_didnt_see_immersive_mode/</url>
    <title>你说你看到了沉浸模式，你可能只是见到鬼了</title>
    <content>
我都不敢相信，现在 2015 年快过一半了，还有不少所谓 Android 爱好者分不清“沉浸模式”和“透明栏”之间的区别。
那好，我们来好好捋一捋“沉浸模式”究竟是个什么玩意。
什么是沉浸模式？
从 Android 4.4 开始，Android 为 &#8220;setSystemUiVisibility()&#8221; 提供了一个新的标记 &#8220;SYSTEM_UI_FLAG_IMMERSIVE&#8221;，就是我们所谈的 &#8220;Immersive Mode&#8221;，也就是沉浸模式，全称为 &#8220;Immersive Full-Screen Mode&#8221; 。

Google 提供这个新模式的初衷，是为了让应用能够实现真正完整的全屏模式体验。
之前 Android 靠两个标记实现全屏模式，一个是 &#8220;SYSTEM_UI_FLAG_FULLSCREEN&#8221;，另一个是 &#8220;SYSTEM_UI_FLAG_HIDE_NAVIGATION&#8221;（仅适用于使用导航栏的设备，即虚拟按键） 。
这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。
而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。
那么 Google 面对这样的问题自然也不会坐视不管。还记得 iOS 是怎么处理用户在全屏应用下调出通知中心/控制中心操作的么？对，用户做一个向内滑动的手势，一个小箭头就会出现，在不影响当前应用全屏的情况下引导用户操作。

Google 借鉴了 iOS 的逻辑，4.4 之后加入的这个 Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏。

这个新加入的特性理所当然地受到了广泛好评：从此 Android 终于可以在全屏应用下不影响用户的正常操作了，难怪 Android Developers 页面中会这么描述 Immersive Full-Screen Mode：
&#8230;lets your app go truly &#8220;full screen.&#8221;
当然，讲了这么多有关“沉浸模式”的介绍，目的并不是要告诉你“沉浸模式”有多么多么好，而是为了告诉你，目前你们所说的“支持沉浸模式”“沉浸状态栏”等等，和真正的“沉浸模式”，即 Immersive Full-Screen Mode 是一点关系都没有的。
接下来我要告诉你们，你们口中的“沉浸”究竟是个什么东西。
“沉浸状态栏”究竟是什么？
Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。
这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式。

说到这里大家应该都明白了——没错，这就是你们口中经常提到的“沉浸模式”“沉浸状态栏”。记住了，他们的学名是&#8221;Translucent Bars&#8221;，透明栏，包括了状态栏（Translucent status bar）和导航栏（Translucent navigation bar）。
在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色。
不同的状态栏风格
不同的导航栏风格，可以注意到加入了全透明（Transparent）背景
有关更多 Material Design 中关于系统栏的描述可以参考这里
总结
如果你认真看到了这里，那么你应该明白了一个重要的事情：此“沉浸”非彼“沉浸”。
真正的沉浸模式，指的是一种全屏模式，而你一般在开发者/爱好者/用户那里听到的“沉浸模式”绝大部分情况下指的是“半透明栏”或者是 Android 5.0 之后加入的“全透明/变色栏”。至于所谓“沉浸式状态栏/导航栏”之类的描述，则完全是无稽之谈。
关于国人对于“半透明栏”和“沉浸模式”之间的误解是怎么产生的，我并不清楚，或许是当时某个科技网站的小编理解错误，翻译新闻时将两个东西扯在了一起；也或许是某个开发者在介绍透明栏时误以为“沉浸模式”是恰当的翻译，但总之，错并不是问题，知错不改才是问题。
如果你能理解这一点，请再也不要弄混这两个完全不一样的东西了。
</content>
</doc><doc>
    <docid>127</docid>
    <url>http://www.phonekr.com/chromebook-pixel-ls-2015-gallery/</url>
    <title>发几张 Chromebook Pixel LS 2015 的图片</title>
    <content>





 
 
截图:

  

(本文在 Chromebook 上撰写)

</content>
</doc><doc>
    <docid>128</docid>
    <url>http://www.phonekr.com/unveil-white-nexus-4/</url>
    <title>揭开白色 Nexus 4 的面纱</title>
    <content>一直以来, 我心目中最美的 Nexus 手机一直是 Nexus 4. 直到今天, 我还在使用它作为设计稿预览机, 并为它制作 Photoshop UI Kit. 不幸 (或者说是有幸?) 的事情是我的第一台 Nexus 4 在陪伴我两年之后电池开始鼓包, 音量下也已经完全失灵. 现在二手 Nexus 4 的价格已经算是白菜价了, 我便毫不犹豫地订购了一台白色 Nexus 4.
接下来就是开箱了.

&nbsp;
Nexus 4 的外包装. 和 Nexus 7 的盒子风格一致, 一看就是姐弟 (你懂的).

左右两侧一样的 Nexus 4. 下面是 LG 的 Logo.

感觉和 Nexus 7 的盒子后面一模一样的宣传文字, 只是把 7 替换成 4 而已…

盒子底部贴着各种信息的条形码. 然后由于是 LG 代工所以 Made in Korea (咱 Nexus 7 就是霸气的 Made in Taiwan…)

分离内外盒. 内盒很低调, 在相同的位置有一个 Nexus 的 Logo.

中规中矩的摆放方式… (你还指望看到什么?!) 感觉好大, 比 Vision 大了两圈… 这就是 4.7″ 的威力么? O0O

整个盒子手感非常好, 不像之前 Windows 8 的盒子那样松松垮垮的.

盒子的内容物: 手机本体, 快速指南, 保修卡, 充电器, 数据线和 SIM 卡槽针. 什么, 你说没有耳机? 那当然啦, 这么便宜的价格你指望有耳机? 自己买去~

来一张 Bling Bling (虽然图中完全没有 Bling&#8230;) 的后盖.

对比下大小. 手边就这些设备. 从左至右… 不用我多说吧? ^v^

除去保护膜, 新手机看起来就是漂亮… 和另外一些采用了 OGS 技术的手机不一样, Nexus 4 在这样的角度下还是很容易就能看出屏幕和机身的边界的.

去掉保护膜之后的背面. 这个像素颗粒闪烁的效果很难用相机(或者说是我的相机太破了)表现出来.

可爱的 LED 指示灯. 继承自 Galaxy Nexus.


开机. 屏幕非常精细. 嘛, 别去点大图, 这个精细度我觉得已经很够了… 之前撕掉 Vision 的保护膜的时候也觉得 Vision 的屏幕很精细, 结果和 Nexus 4 一比还是弱了…
&nbsp;
稍微谈谈上手的感受吧. Nexus 4 的边缘很圆润, 虽然我喜欢直角, 但是圆润的边缘明显的好处就是握在手上的时候感觉非常好. 4.7″ 的屏幕对我这种从 3.7″ 一下飞跃上来的人来讲到底还是太大了, 手感不对(手感很”好”但是不”对”), 很容易按错小的按键. 好在 Android 4.2 的输入法对于输入的精确度并不是很高, 触宝也是. 想要单手持握且不改变握姿就触摸到屏幕左上角确实很有难度.
震动反馈感觉很好. 我以前一直觉得 HTC 那种非常刚劲的反馈是我最爱的(相反的是三星那软绵绵犹豫不决的反馈), Nexus 4 的震动反馈虽然没有那么刚劲但也算是毫不迟疑, 没有绵软的感觉, 可以说挺舒服的. 后背是玻璃所以不会像 Vision 那样大冷天的冻手&#8230;

最后再来 BlingBling 一回
唉? 你还想看更多的内容? 唉呀唉呀这只不过是篇赶时间写的开箱文, 不要想太多啦~ 其他的内容, 我会在晚些的正式评测里写的, 包你满意~
</content>
</doc><doc>
    <docid>129</docid>
    <url>http://www.phonekr.com/yuan-ti-ku-redesign/</url>
    <title>Material Design in Action — 猿题库</title>
    <content>猿题库是一款免费的手机做题软件，在中学学生中拥有一定的人气。
猿题库很早之前就发布了 Android 版本的客户端，但猿题库的联合创始人，郭常圳先生，并不认同 Android Design （或者现在的 Material Design），而且认为应用程序的设计规范，应当由开发商来决定。
然而当我试用猿题库的时候发现，这个应用对其进行 Material Design 的适配，其实并不困难。因此就有了对其进行重新设计的念头。
由于郭先生对 Android / Material Design 以及对跨平台应用遵守规范的误解，我会在展示作品之前，先简单说一说我心目中的跨平台应用应该是如何设计的。
跨平台应用应该怎么做？
现今，绝大部分的移动互联网应用，都会选择开发双平台（iOS 和 Android）或多平台的跨平台客户端。
iOS 的情况比较简单，因为绝大多数公司都会遵循 iOS 的设计规范，很少出现把别的平台的设计风格“搬”到 iOS 上的情况。然而 Android 就要复杂得多了。
Android 在 4.0 之前是没有一个统一标准的规范的，默认控件也比较丑陋，于是开发商们就“怎么方便怎么来”，基本上都把 iOS 风格的控件和交互直接照搬到 Android 上。
情况在 4.0 之后有了改观，Google 为 Android 打造了更加美观的 Holo Theme ，并且提出了 Android Design 规范，从此 Android 应用的设计风格开始进入了新的时代。
然而现在的 Android 应用并没有呈现出“大一统”的状态，而是一个“分水岭”的状态。一边是大部分国外的公司和开发者的应用，经过几个 Android 版本的迭代之后，绝大部分已经遵循了 Android Design，同时有些应用已经开始遵循 Material Design 以期在最新的 Android 5.0 Lollipop 中拥有更好的表现；另一边是大部分国内公司和开发者的应用，纵使 Android Design 已经推出了多年，他们仍然视而不见，继续使用 iOS 的那一套设计风格。
这其中也有一些例外，微信在 5.2 版本中做了一个不太好的尝试，开始试图让微信遵循 Android Design 规范。但这次尝试十分短暂，在受到了用户的批评后，他们马上在 5.4 版本里换回了 iOS 风格。
因此，有人提出，用户不需要跨平台应用针对不同平台做不同的设计。这个观点是对的吗？个人认为，不对。
虽然使用 iOS 风格的设计在 Android 上“又不是不能用”，但如果你想为自己的应用从观感，使用体验等各个层次来一个全面的提升，还是应该试着去遵守平台的规范。
更不用说 Material Design 在 Android 5.0 上提供了非同寻常的使用体验，极具个性的动画效果，能为应用带来优秀的视觉享受。

微博官方客户端（iOS 风格）和 Blacklight 微博客户端（Material Design 风格）在 Android 5.0 上运行效果的对比
所以，用户需要，有必要，有权利在不同的平台上用上遵循规范设计，体验更好的应用。
我看跨平台应用——“求同 存异”
前面提到了，微信曾经在 5.2 版本里短暂地尝试了一下 Android Design ，结果在 5.4 中，又被用户“骂回去”了。
微信这么做对吗？当然不对。新事物总是需要学习的，微信应该做的是在下一个版本当中对 5.3 的风格继续改进，而不是当缩头乌龟。
微信 5.2 的设计为什么会被用户骂？很简单，UI 大改，用户自然需要学习，而之前的 iOS 版本设计风格的 UI 和新的 Android Design UI 之间，几乎毫无瓜葛，用户一时摸不着头脑，于是就开始骂娘了。
这是 Android Design 的错吗？当然不是！事实上，微信在 iOS 和 Android 上的设计，都只能算是非常一般而已。在 5.2 版本上的所谓 Android Design 风格还十分简陋，都有很大的提升空间。
最主要的是，微信在不同平台上的设计，割裂感太大了。

What the f&#8230;?
如上图所示，iOS 版本和 Android 版本（5.3）的微信，简直可以说是两个应用。如果用户从 iOS 版本切换到 Android 上，肯定会产生不适应感，而这是优秀的跨平台应用不应该做的。
在我看来，优秀的跨平台应用必然共有一个特征——求同存异。
以下是一些优秀的跨平台应用（图片来自 NovaDNG）：




&nbsp;
从上面的应用展示中，大家可以看出这些应用让用户能明确体验到应用在不同平台间的差别，又不至于产生不适应感，学习成本也较小。同时，在界面设计上都遵循了相应的平台规范。
这，就是“求同存异”的内涵。用户在使用这些应用的时候，没有那种硬生生的割裂感，只需要很短的时间就能适应在新平台上的操作。
所以，所谓“分裂”其实只是因为应用自己做得不够好，而不是平台规范的错。同样，如果应用做得足够好，用户也不需要太久时间就能适应新的平台设计。
Talk is cheap,show me the&#8230;
OK.
其实在我试用猿题库的时候就发现了一个事实——这款应用看上去一副 iOS 样，其实交互上已经很接近 Android Design 了，最典型的就是那个 Drawer 。
所以我觉得猿题库是款很可惜的 App ，明明只要付出一点点努力，就可以在 Android 平台上变得更好&#8230;
于是我自己动手制作了一套猿题库重新设计的效果图，仅供参考。这只是一种尝试，我相信，肯定还会有其他比我更好的实现方法，关键是肯不肯做。
1.登录画面

状态栏和导航栏都进行了 Translucent 化，为的是更有冲击力的第一观感（好像听上去和 Nova 差不多&#8230;）。稍微更改了一下 Logo 和按钮的布局，原来的按钮样式被换成了 Boarderless Button.
这里偷个懒，直接放上新用户的引导界面，省去登录界面了。
2.引导界面


&#8230;到了这里，大家应该明白我前面“可惜”的意味了吧？我只是做了很小的改动（换成标准的 App Bar 和控件，列表改成标准的两栏布局，去掉了那个箭头，仅此而已），整个界面就已经很 &#8220;Materialized&#8221; 了&#8230;所以我这里改动不多。接下来就是主界面了。
3.主界面

原版上方的概览画面面简直就是硬伤，排版在我看来非常混乱。所以在这次重设计中，我试着用卡片的方式承载这部分内容，同时把内容尽量规整地向中间靠拢。至于底部的 List ，我更新了样式，原来的&#8221;+&#8221;图标改成了现在的&#8221;Expand More&#8221;图标，写题的图标也做了小许改进。

Drawer 在原版就已经出现了，于是我只对 Drawer 样式做了修改，使其更贴近 Material Design 的 Drawer 样式。

原来右上方的“更多”按钮被我更换成了“More”，新页面展示也变成了 Drop Down Menu.
4.写题界面

这个界面可以说改动也很大。首先是 App Bar 上的 Actions 都去了他们该去的位置（计时器的字体也做了修改，并且加粗处理）。至于底部的 Drawer （暂时找不出更好的方式描述这个模块），我把原来的拖动区域整合到了 Drawer 里，以使整个界面看上去更加简洁。选题界面的标题，内容和按钮位置也进行了微调。

练习报告界面。还是之前在主界面那里的问题。排版混乱。于是我按照之前主界面的思路，重新排了版，将原来底部的按钮换成了 Flat buttons.
写在最后
相信大家都发现了，我重制的界面其实不多，一部分原因是我懒（，另一部分原因是，这个应用需要做的绝大部分都是控件的修改和细节上的优化，因此不需要大幅度地推翻重建，只需要完成一两个模块做为演示，我相信就能带来一定的启发。
除此之外，猿题库还有一些问题需要改进，例如去掉 Splash Screen 等等。但不可否认的是，这款应用对中学生来说，帮助是很大的。希望开发团队能够认真考虑一下，拿出一个更好的 Android 版本。
写在最后的最后
这是我第一次对 Android 应用做较为系统的界面重制，在这里要再再再再次感谢 NovaDNG ，没有他的影响，我现在也不会往 Designer 的方向发展。
祝大家在 2015 年一切顺利~
</content>
</doc><doc>
    <docid>130</docid>
    <url>http://www.phonekr.com/android-share-in-mainland-china/</url>
    <title>被 ｢阉割｣ 的分享与应用间的墙</title>
    <content>经常使用国内应用的读者应该不会对这个题目感到陌生 —— 很多国内大公司的应用都自己 ｢实现｣ 了一套 ｢独特｣ 的分享方式, 里面只有自己家的应用, 想分享给其他应用要么得费点儿心思找入口,  要么根本就不允许.
在我看来引起这种行为有四个原因: 流量内引构建闭环, 第三方玩家破坏规则, 国内用户习惯, 继承自 iOS 上的恶习.
首先是构建闭环. 这点很好理解, 假设我是腾讯新闻的 PM, 我当然希望用户在我的客户端看完新闻之后, 分享给朋友圈, 腾讯微博, QQ&#8230; 这样, 用户的分享行为就会带来其他腾讯应用的流量. 同理网易新闻等一些大厂旗下的应用也很容易朝着这条路走去, build walls not bridges. 题主例子中网易新闻客户端就把自家的易信放在了分享的最前面, 很明显是有引导流量的用意.
其次是第三方玩家破坏规则. 因为开放的分享接口, 所以你可以经常看到很多应用的分享按钮会带出长长的一串应用列表, 很多用户不一定会用到的应用也会出现, 这对用户会产生一定的心理压力. 更糟糕的是, 由于列表是默认按照拼音顺序排列的, 所以某些没节操没下限的国内应用在命名的时候玩往名字前面加空格或者奇怪的符号, 在后面加 &#8220;(推荐设为默认)&#8221; 这样的小手段来&#8221;引导&#8221;用户, 这不是什么好现象.
第三点和第二点比较难以分开, 国内的社交网络基本由几大巨头垄断, 而国内用户一般使用的社交网络也就被限制在比较大的那几个上, 像微博微信人人, 只要把这些覆盖到, 基本上就可以满足绝大多数用户的分享需求了, 同时也省得用户每次面对一大串应用名字不知所措, 何乐而不为?
最后是继承自 iOS 的恶习. 我们知道 iOS 一直没有一个完善的应用间通讯机制, 跨应用分享内容需要靠开发者自己搭建通道来实现 (说实话当我第一次看到 Reeder 的分享列表的时候还是震惊了), 所以 iOS 上往往只有几个分享选项. 而有些厂家则直接在 Android 上全盘照搬了这一点, 让 Android 应用也显示和 iOS 版本一样的分享选项, 理由五花八门, 常见的有&#8221;提供一致的跨平台体验&#8221;云云, 这里就不赘述了.
就我看来, 我最推荐的分享方式是像 Pocket 和 Timely 一样的:

希望国内这些公司还是早日抛弃成见, 不要再往 Android 里添加高墙了.
&nbsp;
</content>
</doc><doc>
    <docid>131</docid>
    <url>http://www.phonekr.com/do-not-get-tricked-by-data/</url>
    <title>｢数据? 那是什么? 能吃么? 好吃么?｣</title>
    <content>在近一年前, 腾讯终于扭扭捏捏地把微信改成了靠近 Android Design 的样子. 虽然外表有那么点儿 Android Design 的味道, 但设计却十分糟烂, 被无数用户吐槽. 结果到了八月, 微信又把 UI 改回了 iOS 风格.
我 100% 不认为腾讯因为 5.2 被用户唾骂而放弃 Android Design 是什么明智的决定, 与其因为碰了一次钉子就认为 &#8220;Android Design 不符合用户的使用习惯&#8221;, 不如好好研究 Android Design, 在遵循规范的前提下把微信做得更好.
很多人拿后台数据说话, 我就解释一下数据好了. 数据不是真理, 数据也可以被轻易的操作. 就拿这次微信来做例子:
对比对象一方是使用了很久 (从 Android 2.X 时代起微信就一直是 iOS 风格 UI), 成熟 (就算是在 iOS 上微信的 UI 也很难说是优秀, 所以这里用成熟) 且用户习惯 (如前述, 微信老用户都习惯了这套) 的 iOS-Like UI;
另一方是新推送的 (新年前才推送更新), 设计糟烂 (和 Android Design 貌合神离, 只是套了个皮, 完全没能体现对 Android Design 理解且存在大量违背 Android Design 设计之处) 且没有任何引导(一个全新设计拿到用户手中居然没有给任何的事先说明和引导教程) 的 Android Deisgn;
对比的结果可以说是显而易见的.
若 Android Design 一方同样是使用了很久, 设计经过深思熟虑且尽可能完全符合 Android Design (在这里姑且不谈超越) 且做出了合适的引导与教程, 你觉得数据会是什么样子的呢?
另外, 关于 &#8220;用户不知道也不会在意 Android Design&#8221; 这样的论点: 用户完全没必要知道什么规范, 用户当然也喜欢用脚投票, 而这并不妨碍开发方在这个规范的框架中做出优秀趁手的产品. 在微信这个事件上, &#8220;用户用脚投票选择 iOS UI&#8221; 这个现象只能说明 &#8220;微信的 Android Design 做得很烂&#8220;, 而不能说明 &#8220;Android Design 不适合微信&#8221;.
产品经理也当然没必要满嘴 Android Design 或者 Action Overflow, 但是如果他们不知道如何用好 Android Design 或者 Action Overflow, 就是他们的失职.
</content>
</doc><doc>
    <docid>132</docid>
    <url>http://www.phonekr.com/overview-is-the-new-recents/</url>
    <title>Overview, Android 中新的 Recents 界面</title>
    <content>在 Android 5.0 中, 原先的 ｢最近任务｣(Recents) 界面被 ｢概览｣(Overview) 界面替换了.

在实际上手 5.0 之前, 我也一度对这个界面的实际效果产生怀疑, 但是实际上手之后发现自己多虑了.
首先, 新的多任务界面在 Nexus 4 上可以最多显示清楚五个应用 (第五个应用的标题会被略遮住一些, 第六个往后会露出一条缝, 只能看出颜色), 在 4.X 上最多能显示四个. 另外, 卡片的 App Bar 可以跟随应用改变颜色 (比如 Gmail 卡就是红色的 Bar, Keep 就是黄色, Messenger 就是蓝色, 等等), 也增加了应用的识别度. 而 4.X Recents 界面里的缩略图识别度其实很低, 的大部分时候还是要靠图标和标题 —— 而实际上在 5.0 中, 标题和图标的大小并没有缩小.
而在 4.X 上, 还有一个很严重的问题就是多任务界面与其他屏幕的转换非常诡异. 如果你仔细观察过 Android 4.X 从某个应用进入 Recents 的动画, 你会发现这个动画是不能接应的 (在屏幕缩小的过程中, 内容会扭曲, 然后变成 Recents 里面的小块, 有兴趣的同学可以自己把动画持续时间调成 X10 看看). 而在 5.0 中, 进出 Overview 界面的动画非常平顺 (不会发生扭曲, 而是直接缩放 + 展开), 同时也符合系统自己的隐喻 (5.0 中, 打开应用的动画不再是放大, 而是一张卡片从屏幕底部飞入, 从主屏进入 Overview 界面也是一堆卡片从屏幕底部飞入), 也就是说, 在 4.X 里, Recents 是一个专门的层级, 位于桌面与应用之间, 而在 5.0 中, 桌面与 Overview 合为一体 (Google 甚至把 Google Search Box 也放进了 Overview 界面), 是系统层级方面的调整. 如果这时再配上 4.X 的 Recents, 就打乱了这层级关系.
而且, 如果你在 5.0 的 Overview 界面稍作停留, 每张卡片的右上角都会出现一个小 X, 这样便可以让那些 (到现在都) 还不知道划去卡片可以关闭应用的用户关闭应用. 这个操作其实和 Chrome 是保持一致的. 同时在 5.0 中, Document UI 允许一个应用同时显示多个界面在 Overview 中 (如 Chrome 的多个标签页), 在卡片下他们会靠得更近以区分于其他应用, 而如果是 4.X 的 Recents 的话则不能体现出这一点.
还有一个很有意思的地方就是, 如果在 4.X 上, 当有超过 3 个应用被打开时, 多任务界面中想点击最上面的那个应用几乎是不可能的, 而在 5.0 中, 卡片的存在使得整个多任务列表可以被拉到屏幕 2/3 高度, 最上面的一张卡片可以触及的范围甚至达到了屏幕的下半部分, 可以直接单手触到, 非常便利. 而楼上其他同学也提到了, 要滑动同样数量应用的距离, 5.0 上是比 4.X 上要短的.
而如果你仔细观察开头给出的图片, 你会发现一些细节. 首先, 新的 Chrome 和 Chrome Beta 都支持通过读取网页的某个 HTML 标签来改变 Overview 界面里 App Bar 的颜色. 这对于增加网页/Web App 的辨识度而言产生了极大的帮助.
其次, 如果你细心的话, 会注意到知乎 Alpha 和 Google Wallet 在 Overview 里显示的图标和他们的应用图标不一样. 这就是 Overview 的一个新特性, 我们可以自定义显示在 Overview 里的图标. 我去掉了此处知乎图标的底座, 这样能够让知乎在 Overview 里看起来更和谐.
第三是没有在上图中体现的一个新特性. 只要我们愿意, 我们可以让知乎在 Overview 中显示不同的 Title —— 比如说, 当你在阅读答案时, 进入 Overview 界面, 知乎显示的标题就是 ｢回答｣, 如果你在某个人的个人主页, 那么在 Overview 里知乎的标题就是这个人的名字. 也就是说, 当 3.0 版 (或者以后其他版本) 里知乎支持多帐号之后, 你就可以在 Overview 里看到你的两个账号分别以两张卡片呈现, 知乎图标变成你的头像, 知乎后面是你的帐号名字~
这些新特性如果好好使用的话, 对于提升一个应用的易用性也好辨识度也好, 都是有极大意义的.
</content>
</doc><doc>
    <docid>133</docid>
    <url>http://www.phonekr.com/material-thickness/</url>
    <title>｢质感｣ 的 ｢厚度｣</title>
    <content>如果你有看过 Material Design, 那也许会对这个描述有印象:
Material has varying x &amp; y dimensions (measured in dps) and a uniform thickness (1dp). Materialnever has a thickness of 0.
那么, 这个 idp thickness 到底是什么意思呢?
这里的 1dp thick 并不是一个实际的数字, 它有两个含义: Material 有固定的厚度, Material 的厚度是一个网格中允许存在的最小值.
什么意思呢?
在 Holo (或者说 Android Design) 时代, Google 就已经强调了阴影和高光的使用, 但是, Holo 中的阴影和高光并不完全是高度变化的产物, 相当一部分的阴影和高光是由控件本身的厚度产生的 (比如 Action Bar 下方的阴影).

而 Material Design 里, 厚度这个属性被去除了. 也就是说, 同样是 Action Bar 和 App Bar 产生的投影, 在 Android Design 中, 投影是因为 Action Bar 有厚度 (厚度是多少我们不知道), 而在 Material Design 中, App Bar 的投影却是由于 App Bar 的高度高于下面的内容而产生的. 同样的, 其他的 Material 元素也和 App Bar 一样会产生投影, 而这些投影并不是由厚度产生的, 而是由高度差产生的. Google 规定了 Material 固有的厚度, 也就是问题描述中的 1dp thick.
Material 有固定的厚度, 然后呢? 实际上, Material 的厚度应该是一个虚数. 你可以把它想象成一张无限薄却不透明的材料. 但是 Google 显然不可能用这种暧昧的描述. 而在 Material Design 中, 基本不存在 &#8220;0.5dp&#8221; 这样的数值, Material Design 的网格也是以 8dp 为单位存在, Google 同样不能采用 &#8220;0.1dp thick&#8221; 这样的表述. 但是 Material 必须有厚度. 这个时候, 拿一个最小整数单位来提示 &#8220;这个东西有厚度&#8221;, 就只能选择 1dp 了.
</content>
</doc><doc>
    <docid>134</docid>
    <url>http://www.phonekr.com/material-design-on-ios/</url>
    <title>对于 Google 在 iOS 上采用 Material Design 这种事情, 我还是挺欢迎的</title>
    <content>自从 Material Design 发布之后, Google 就陆陆续续在 iOS 上把几个重要的自家应用的风格改成了 Material Design. 而在此之前, Google 的几个 iOS 应用基本上都是遵循苹果的 Human Interface Guideline 来制作的.



完全 Material Design 的 Inbox

Google 当初在订制 Material Design Guideline 的时候, 就已经把跨 iOS 平台纳入目标了. 对比 Android Design 你会发现 Material Design 在很多地方都靠近了 iOS HIG (当然, ｢违背｣ 的地方也非常多). 如果在 iOS 上运行一个 Android Design 风格的应用, 会让用户觉得非常诡异, 就像在 Android 原生系统上运行一个 iOS 风格的应用一样. 而制作精良 (在我看来 Google News &amp; Weather 就是随便应付的感觉) 的 Material Design 应用运行在 iOS 上, 给人造成的不适感却会小很多.
写到上面这句话的时候我不由得想跑个题, 说说 ｢搬运设计风格｣ 这事儿. 为什么我对于 Google 把 Material Design 搬运到 iOS 上持宽容态度, 而对国内这些把 iOS 风格搬运到 Android 上的公司就恨不得除之而后快? 从文字描述上看起来很接近的两件事其实在本质上截然相反. 对于在 iOS 上 ｢不遵循规范｣ 设计的宽容很大一部分原因是优秀的 iOS 应用即使没有完全遵循 HIG 也不会差得太远, 或者说完全从另一个平台搬运 UI —— 当然也不是完全没有应用搬运其他平台的 UI, 但是即使完全搬运其他平台 UI, 能够被接受的几乎都在 iOS 上做得甚至比被搬运平台的应用更优秀 (之前 @冬虫夏草卡洛斯 说过: 最优秀的 Metro App 都在 iOS 上.说的就是这个事儿, 恐怕不久之后大家会发现, 最优秀的 Material Design 应用都在 iOS 上也说不定呢 XD). 而很多被容忍/接受的 ｢违规行为｣ 都是正向的 ｢超越规范｣, 而不是 ｢突破下限｣. 反观 Android 上那些被人嫌弃的应用, 它们最大的问题真的只是 ｢把 iOS 风格搬运到 Android 上｣ 么?
话虽如此, 现在这几个 Google 应用大多都没有用上 iOS 系统级滑动返回, 而是用的左上角返回或者上下拉返回这些非标准的操作, 对于 iOS 用户来说其实挺不友好的. 而 News &amp; Weather 给人以很强的粗制滥造感, 以及充满 Google 风格的各式各样的小问题, 那又是另外一说了.
做得好, 自然大家喜欢, 做得不好, 大家自然就骂了.
</content>
</doc><doc>
    <docid>135</docid>
    <url>http://www.phonekr.com/best-of-2014/</url>
    <title>NovaDNG 2014 年度应用</title>
    <content>又到了一年一度写年终总结的时候了&#8230; 这一年因为参加了工作的缘故, 锋客这边文章的更新频率大幅下降了, 所以这几天我会搬运一些知乎上的回答过来.
然后就是这篇文章的正题, Best of 2014!按照时间排序~

发布于一月份的 Vivino 是一款酒友应用, 能够识别酒标, 在线评酒和为你发现身边的酒庄/酒吧

发布于二月份的 Muzei 是一款动态壁纸, 在每天推送一张世界名画做壁纸之余又添加了模糊效果不至影响主屏使用, 藉由开放 API 的便利又有着数百款插件可供选择

同样发布于二月份的 Type Machine 是一款系统应用, 能够像时光机一般拯救因为意外丢失的文字

发布于三月份的 Link Bubble 是一款浏览器, 能够最大限度地利用等待载入的时间
(没有图)
同样发布于三月份的 Pixl Preview 是一款设计工具, 它能让设计师直接在 Android 手机上预览 Photoshop 上的设计稿

发布于四月份的 Google Camera 是一款相机, 能够拍摄球形全景与后期模糊照片, 界面极端简洁
 
同样发布于四月份的 Scene 和 CloudMagic 分别是一款操作新颖的图片浏览器与一款集成了非常多有趣功能的邮件客户端

发布于七月份的 Journey 是一款设计精良的日记应用, 在遵循了 Material Design 的同时提供了 Markdown 支持, 并且有 Web 端与 Chrome App

同样发布于七月份的 Unclouded 是一款设计精美的云盘管理器, 可以方便地查看与管理复数账号的 Google Drive, Dropbox, Box 与 OneDrive.

发布于八月份的 Weather Timeline 是一款天气应用, 精致的动画与有趣的 ｢天气时光机｣ 功能带来了很多惊喜

发布于十二月的 Action Launcher 3 是一款桌面应用, 接近原生 Google Now Launcher 的外观与趁手的 Cover, Shutter 快捷操作让桌面的效率倍增
以上就是 NovaDNG 的 2014 年 Android App 精选集~
</content>
</doc><doc>
    <docid>136</docid>
    <url>http://www.phonekr.com/android-ui-design-kit-5-0-nexus-4/</url>
    <title>Android UI 设计工具 (Photoshop, Android 5.0, Nexus 4)</title>
    <content>Material Design UI Toolkit for Nexus 4 版本 0.1 发布.
大概在十个月前, 我踏着 +Taylor Ling 走过的道路, 将他制作的 Android UI Design Kit 4.4 移植给 Nexus 4 使用. 一晃将近一年过去, Android 5.0 发布, Nexus 6 开始流行. 显然有很多人认为 Nexus 4 已经是落后的, 被遗忘的设备了.
但是 Nexus 4 作为我最喜欢的 Nexus 设备, 我显然希望 Nexus 4 在手中能够继续焕发活力, 更何况 Google 也依然在给 Nexus 4 推送最新的 Android. 于是早些时候我许下了诺言, 答应不论如何一定会把这套工具更新到 Android 5.0.
等到 Material Design 终于发布正式版的时候, 就到了我兑现这个诺言的时候了. 十个月前我还可以直接从 Taylor 的 Nexus 5 Toolkit 里搬运控件到 Nexus 4 上, 但是 Taylor 还没有做 5.0 的 Toolkit. 所以这个版本里所有的控件都是我自己画的.
于是就有了这么一套设计工具, 给和我一样怀旧的人.
 

 
 
作为 0.1 版本自然是完成度很低, 目前只做了白色主题, 还缺失了很多在 Material Design 文档中尚未明确的控件. 有兴趣的同学就下载来用用吧. 欢迎补全.
下载地址: 度盘, Google Drive
</content>
</doc><doc>
    <docid>137</docid>
    <url>http://www.phonekr.com/android-tablet-is-doomed/</url>
    <title>Google 大概是真的打算放弃 Android 平板了</title>
    <content>本来这篇文章的目的是打算好好黑一下 Nexus 9 的, 毕竟手上这台 Nexus 9 的黑点实在是太多了. 但是没想到 HTC 大概已经听到了众 Nexus 9 用户的不满, 塌陷的音量键, 松软的后盖这两个制造工艺问题在新出货的 Nexus 9 上已经得到了解决, 可以取暖的功能随着 Android 5.0.1 也已经取消了, 所以黑点的话恐怕真的没多少了.
但是正当我准备和公园的朋友们说 ｢Nexus 9 貌似没什么东西可写 (hēi) 了｣ 的时候, 更新版的 Play Store 让我不得不重新考虑这个问题.
多分栏布局哪儿去了?
当年 Android 3.0 发布的时候, Google 就已经为 Android 平板设计了一套非常合理便捷的布局 —— Multi-pane Layouts. 可以看到, 多分栏布局在平板上非常便利, 既能合理利用屏幕空间展示更多内容, 也方便进行操作. 可以说, 多分栏布局显著地提升了 Android 平板的使用效率.
但是, 从 Android 4.1 起, Google 开始逐渐移除 Android 上的多分栏布局. 首先是取消了 Tablet UI, 接着是设置里的多分栏布局消失了. 然后, 就发生在不久之前的是, 在 Hangouts 2.3 版本中, Google 去掉了 Hangouts 的多分栏支持. 这也使得 Hangouts 在平板上几乎失去了可用性, 布局排版就是简单的手机版放大, 一塌糊涂.

而早期版本的 Hangouts 上, 多分栏布局既能显示出对话列表, 又能让对话双方的文字不至于离得太远以便阅读.

而就在几天前, Play Store 更新之后, 多分栏布局也被取消了.
再看看不久前更新的 Play Store:

空荡荡的卡片占满了整个页面. 在更新以前, 这个界面下是采用了多分栏布局的. 左侧栏是应用列表 —— 实话说应用列表使用左边部分面积已经完全足够了. 在右边是应用的大图和快速操作, 可以直接启动, 更新或卸载应用, 甚至还可以取消订阅应用内的内容. 更重要的是, 右边栏的内容几乎是无需加载的, 而点击进入应用详情时难免需要加载一段时间. 无论是操作效率也好, 对空间的利用也好, 多分栏布局都是远远高于传统单栏布局的.

(这是很早很早之前的 Play 市场)
Google 似乎根本不在意应用在平板上表现如何
除上面所述那些取消了多分栏的应用之外, Play Games, Inbox 等另一批 Google 应用在诞生的第一天起对平板支持就异常糟糕. 在新推出的 Inbox for Android 上, 压根儿看不出一点点为平板优化过的影子, 糟糕的可读性令 Inbox 在平板上几乎不能用. (所幸, Gmail 还保留着多分栏布局).

你能想象在一块十寸大屏上使用 Play Music 却没法以全屏大小查看一张专辑封面的完整大图么? 是的, Google 就是不让你这么做. 相比之下, 反而是在大改版之前的 Play Music 对平板更友好.

尽管在 Material Design 里承诺得相当美好, 但是至少目前部分 Material 化的 Play Music 让我觉得非常不尽如人意.

Walkman 至少允许你查看完整专辑封面, 以不是太小的图. (实际上 Walkman 这样的布局也可以称之为多分栏布局)
还有奇葩的 Google+:

完全不能体现出平板屏幕大的优势, 白白浪费了屏幕空间, 操作也相当不便.
还有很多我没有截图也懒得截图的画面, 从各种各样的角度暴露出十寸平板上 Google 应用设计的不上心. 除了 Nexus 9 之外, 我还同时在使用一台索尼 Xperia Z2 Tablet. 而索尼自己的平板应用却都有不错的平板优化 (至少不会给人以粗制滥造的感觉). 两边一对比, 更是彰显了 Google 对平板的不重视.
内容消费设备? 生产力设备?
除了上面提到的应用之外, 有个很有趣的现象: Play Movies &amp; TV, Play Books 和 Play Newsstand 这三个以内容为主导的 Play 应用却一直保持着优秀的平板适配. Chrome 也还保持着多分栏布局 (在设置页中). Google Drive 以及旗下的三个 Drive 应用也有为平板优化操作. 再加上 Nexus 9 的官方附件里有 Keyboard Folio, 我想 Google 对 Nexus 9 的定位应该就显得很明确了: 内容消费 + 生产力设备. 和内容消费以及生产力无关的应用都玩儿蛋去, 凑合能用就行了; 和内容消费及生产力密切相关的应用就能得到特别优待, 有还算不错的平板布局.
还有个比较搞笑的事情是, 最近微软在测试的 Office for Android Tablet 尚不支持 Android 5.0, 所以 Nexus 9 也只能望洋兴叹.
Google 内部的碎片化
 
在 Nexus 9 上, 我看到了非常优秀的平板布局范例 —— Google Calendar, Maps 及 Gmail; 还算凑合的平板布局 —— News &amp; Weather, Keep 及 YouTube; 还有遭烂得令人无法忍受的平板布局 —— Hangouts, Inbox 及 Google+ Photos. 真的很难相信这些应用都是由同一家公司, 遵循着同一套规范做出来的.
团队越大, 部门越多, 要统一规划就越困难, 这个道理大家都懂. 但是 Nexus 9 上呈现出来的这一派乱象, 很明显地超出了我们理解和容忍的范围 —— 一个新发布的应用做得很烂, 那索性不用, 但是一个原先很棒的老应用更新之后变得乱七八糟, 这就让人完全无法忍受了.
Google 发布 Material Design 也不是一天两天的事情了, 但是现在很多 Google 还没能完全符合这套规范 —— Hangouts 直到这两天的更新才把界面上的一些元素 Material 化, Device Manager, Translate 等一系列应用现在还是 Holo 风格, Google+ Photos, Drive 系列应用的 Material Design 不伦不类&#8230; 一切的一切都让我觉得, Material Design 只是一个看起来很美的幻影.
连 Google 都不知道应该如何正确的使用, 如何用好 Material Design, 我们拿什么去要求第三方开发者/设计师遵循着套规范呢? 同样的, 连 Google 第一方应用的平板适配都如此不伦不类, Google 拿什么去要求第三方开发者为 Android 平板进行适配呢?
也许最后, Android 平板会沦为寨版的天下 (更遑论现在很多 Android 寨版性价比还不如 WinTel 寨版), Android 不得不龟缩到手机 + Phablet 阵地固守, 将平板市场拱手让给 iOS (原本就是这个市场绝对的王者) 与新秀 WinTel 平板进行刀刀见血的厮杀.
乌鸦老师问: Android 平板还有未来吗? 这个问题的答案, 我不知道.
</content>
</doc><doc>
    <docid>138</docid>
    <url>http://www.phonekr.com/navigation-drawer-where-does-it-belong/</url>
    <title>导航抽屉到底归属于哪个层级?</title>
    <content>这篇文章译自 +Juhani Lehtimäki 的博文 Navigation Drawer &#8211; Where Does it Belong in the View Hierarchy? 英文能力过关的同学可以直接去看原文~
事情本来是没那么复杂的&#8230;

Android Design | Navigation Drawer
但是一切都变了. 我们常说 &#8220;先破而后立&#8221;, 当导航抽屉成为 Google 设计规范的一部分时, Google 明确告诉我们该这么做, 而且提供了可以让开发者直接调用的工具.
难道说 Google 在一开始的时候犯了个错误? 也许第一眼看上去这样做是对的, 但是从规范上看来确实是有些问题的.
所以现在规范改变了. Google 调整了这些东西. 在新的 Material Design 规范中, Navigation Drawer (现在被叫做 Side Nav, 侧边导航栏) 一跃来到了所有东西的顶端.

&nbsp;
Material Design | Layout
我们现在又一次来到了变革的潮流中. Google 正在不断的改变自己与应用的设计, 与此同时很多变数也随着这些改变来到. 虽然我个人是很希望看到 Google 能统一他们使用侧边导航栏的方式并且对开发者们传递一个明确的信息&#8230;

也许你会问, &#8220;但是层级又有什么关系呢? 反正他们都 &#8216;能用&#8217; 不是么?&#8221;
我认为这很重要, 事关重大. 这关系到用户是如何认知他们正在操控的物件. 如果抽屉式主要的导航方式, 那么它就是最不能出错的.
层级关系能让用户明白现在他正在操作的东西归属于应用的哪个部分.

上图展现了早先版本中抽屉所处的层级, 而新的 Photos 应用也遵循了这样的层级. 在我看来这么做有两个地方有很大问题:

首先, 抽屉在这个位置暗示了 Action Bar 在我导航到其他入口的时候不会有变化&#8230; 但是它却变了.
其次, 当抽屉展开时, Action Bar 上的按钮还是有效的, 但是它们的效果对象却是被遮住了一半 (在手机上被遮住更多) 的那些项目.

令人困惑, 不是吗?
&nbsp;

最新版的 Google Hangouts 则采用了与 Tab 平齐的抽屉. 这给了用户 &#8220;当我从抽屉中导航到别处时, Tab 不会受到影响&#8221; 的暗示, 问题是, Tab 还是会受到影响的. 这种结构明显是错误的.
&nbsp;

最新版的 Newsstand 中抽屉的表现是最接近 Material Design 规范中提到的 Google 应用了, 我认为这样的实现是很棒的, 而且是正确的. 当我从抽屉中导航的时候, 所有的内容都会改变, 包括 Action Bar. 这与现实的对应是最紧密的.

把 Drawer 设置为最高层级也可以很有效地避免发生上图这种视觉错误 (当 Action Bar 在滑动时隐藏了的时候).
好吧, 一切都在不断的变化, 而 Google 看起来也还没拿准主意. 我还是希望 Google 能早日找回一致性, 这样我们开发者和设计师才能跟进. 在那之前, 我们还是谨慎为妙.
当然, 改变熟悉的事物绝不是一件容易的事情. 我在 Google+ 上发起了一个投票希望看看大家的意见. 从结果看来改变是要花些时间的&#8230;

</content>
</doc><doc>
    <docid>139</docid>
    <url>http://www.phonekr.com/ux-is-king/</url>
    <title>用户体验为王 —— Android 设计师 Taylor Ling 访谈</title>
    <content>
这篇文章译自 Squirrel Park 的文章 User Experience is King, 作者是 +NINO RAPIN, 由于我已经很久没翻译过文章了, 英文能力过关的同学可以直接去看原文~ 对了, Taylor 也是我的朋友~
Taylor Ling 是一位不懈倡导优质 UI 与 UX 设计的设计师. 在 Android 界他以自己那专注于另应用变得清晰与易用的 &#8220;(re)design&#8221; 活动而闻名. 同样的, 他也经常被邀请参加世界各地的大会并作出宣讲.
Taylor 的博客 androiduiux.com 可以说是 Android 界最富饶的设计资源聚集地和灵感发源地. 而在 Google+ 上, 他也经常分享一些关于设计的洞见与实战, 以及各种关于 UI, UX 的资源. 当然, 最近他分享得更多的是关于新的 Material Design.
我们与 Taylor 聊了很多, 比如用户体验设计, Android Design 的未来, 如何在你的领域中做到最好以及数字设计师的责任, 以下文段中粗体代表原文作者, 正文是 Taylor 的回复.
&nbsp;
在几个星期之前您被 Google 正式授予 Google 专业开发者 (GDE) 的称号, 恭喜~ 对于您来说, GDE 的角色和职责是怎样的呢? 
这和我一直以来在做的事情没什么区别: 分享一些小技巧, 与社区里的成员们互动, 帮助大家解决设计上的问题. 我经常与想要接触 Android Design 或想要为 Android 做设计的设计师们交谈, 我努力让大家意识到设计师是如何帮助开发者解决一些超出他们能力范围的设计问题的. 所以称为 GDE 其实没什么差别, 至少是对我来说.
对我来说, 成为 GDE 之后最大的目标便是努力弥合开发者与设计师之间的鸿沟.
填平这道鸿沟是个非常艰巨的任务, 因为大部分时间设计师虽然能做出很漂亮的设计稿, 但是开发者却完全不明白应该如何实现出这些东西. 主要的问题就是开发者们弄不清楚为什么我们设计师要做这样的设计. 故此作为一个 GDE, 我们可以插入到设计师与开发者之间, 对设计师说: &#8220;嘿, 除了做出那些花里胡哨的设计之外, 你需要让开发者弄清楚为什么要把东西做成你想象的这样, 为什么这对用户交互来说是非常重要的, 为什么这个图标是有意义的. 你不能随便用另一个图标去表示这个操作, 因为&#8230; &#8221; 如此这般, 等等.
我经常看到很多从有着不同设计背景的人转到移动设计这一领域来, 他们有的曾是工业设计师, 平面设计师或者出版设计师. 当然, 我的意思是, 移动设计领域正在不断成长. 但是在很多情况下, 他们之前的经历给他们的移动应用设计带来了一系列问题. 他们并不知道移动设计的基础, 也不清楚开发者们是如何把他们的设计转变成一行行代码的. 而且更致命的是, 他们中的很多人对于移动应用的设计规范没有任何概念. 所以我们一直试图在博客文章中, 在大会宣讲中, 以及其他很多地方传播这样的理念: 请做出些开发者能够理解的并使用的设计来. 我经常听到开发者说: &#8220;设计师给我发了一份设计稿, 但是他却从来不会干切图这码子事儿, 所以我不得不亲自动手切不同分辨率下用到的素材.&#8221; 所以我们不断努力分享自己的知识, 经验以及遇到的问题, 希望能够帮开发者们分忧.
三年前我们的目标还是创建一个社区. 现在我们已经有了一个, 虽然没大到那种程度, 但是已经初具规模了. 我们可以从社区里学到很多东西. 于是 GDE 就作为了更加正式的信息获取途径, 通过这些信息来缩小开发者与设计师之间的鸿沟.
设计师与开发者不应该处于敌对立场, 而应该是占有 —— 他们密不可分. 只有他们紧密的合作, 才有可能创造出最好的东西.
您一直倾注心血于 UI 与 UX 设计上. 最近, UX 这个词变得愈加火热, 反而迷失了它真正含义, 所有人都想称为 UX 设计师, 仅仅因为它很酷很潮. 于是, 作为一个在 UX 领域浸淫多年的前辈, 您是如何定义 UX 的呢? 
唔, 这个问题真是一如既往的难应付啊. 大家对于这个问题应该都有不同的答案. 很多人都认同用户体验是个很重要的东西, 但是它又是无形的, 难以捕捉. 这不是我们可以看到的东西, 它存在于完成的产品中.
当一个应用的用户体验很糟糕的时候我们会知道这东西的用户体验很糟糕, 但是通常情况下我们很难意识到好的用户体验.
没错. 当我们谈论用户体验的时候, 通常都是拿差劲的用户体验开涮的. 但很少有人会记住好的那些用户体验, 因为在优秀用户体验这样的前提下, 用户们都满意的达成了他们的目的. 如果用户体验很差劲的话, 你会一辈子记恨并且到处宣扬 &#8220;妈呀这东西太 &lt;beep ——&gt; 难用了!&#8221;
当然, 从定义的角度来说, 用户体验就是用户的体验. 但是如果你要说 UX 设计的精髓到底是什么, 我会说: 它意味着将一种态度贯穿于整个产品甚至公司中. 做到与用户感同身受, 了解用户的体验等于明确了你的产品能达到多高的境界. 虽然这并不意味着你的产品会仅仅因为用户的喜爱而获得成功, 但这至少是成功的第一步.
UX 是一套理念, 一种态度, 而它与产品的每个部分都是相同的: 交互, 界面, 样品. 产品的每一个部分都在优秀的用户体验中扮演着重要的角色.
我有一个朋友是一名 UX 意见领袖, 他走遍了整个国家 (译注: 马来西亚) 来宣传 UX 的重要性. 他甚至去求职网站寻找所有和 UX 设计相关的工作, 然后他接受了各种面试 —— 出于研究的目的. 他想要知道这些公司到底请不清楚他们想要招聘到什么人. 也许在西方国家的情况会好一些, 但是在这个国家 (译注: 马来西亚), 他发现 95% 以上的公司都找错了人. 这些公司在寻找一匹独角兽: 一个既能码代码, 又能做设计, 又能干其他杂七杂八事情的人. 这个有趣的小实验也告诉我们, 推进 UX 这件大业还需要很多的努力. 如果你想让你的产品有良好的用户体验, 可不是随便雇一个人就能自动让你的产品变好并且让用户爱上这么简单的.
您是怎么意识到自己想要从事 UI 与 UX 设计的呢? 您的职业道路是如何诞生的? 
很多人都对我的生物工程学背景感到吃惊. 我很爱生物工程学. 生物工程是个解剖学与工程学交叉的可爱学科, 但是在我们国家却很难找到实验室以外和它相关的工作. 而我又不想一直耗在实验室里. 这太无聊了. 于是我开始寻思自己还能做什么. 我一直以来就对设计很感兴趣, 在上大学之前我就很喜欢画画, 而且还得了一些小奖. 设计和艺术大概是流动于我的血管中的. 我热爱艺术.
我的第一份工作是功能分析师, 这个工作的性质是帮助产品经理将他们的需求翻译成更低级别的需求集合, 以便于开发者们能知道该干什么. 但是, 当然的, 团队里是没有设计师的. 所以我必须自己做设计, 设定布局, 做所有的事情. 当时我还没有意识到有一天我可以靠干这个赚钱.
直到三年前我开始看博客. 我发现了 Juhani Lehtimäki 的博客 (译著: Juhani 的博客已经很久没更新了&#8230;), 他在博客里谈了很多和 Android Design 的东西. 我想, &#8220;哟, 有好多人都在谈论移动界面设计啊, 有意思~&#8221; 那个时候我对于移动界面设计也没什么清晰的概念, 因为 Juhani 也是一个开发者, 而我又没什么技术背景, 所以我也不是很确定这在这方面有没有我可以做的事情.
那个时候我拿到了我的第一台 Android 手机, Sony Ericsson Xperia X8 (NovaDNG: 索尼大法好!) 它的屏幕非常小. 我很认真的研究了它, 并且被这么个小小的东西上能做到那么多我先前想都没想过的事情惊到了. 那时候仍然是 Gingerbread 的时代, 有那么一些应用是经过设计的, 但是应用之间基本没有什么一致性. 在那个时间, 第二代 iPhone 发布了, 我问了自己一个问题: 为什么高质量的应用通常只会在 iPhone 上出现? iPhone 很贵. 我不觉得我必须要花很贵的价格在设备上才能买到高质量的数字体验. 为什么我不能在 Android 上得到优秀的数字体验呢?
于是我花了更多的功夫琢磨 Android, 然后从本地运营商那里买到了一台 Nexus S —— 那个时候已经进入了 Ice Cream Sandwich 的时代了. 为此我万分激动并且做了我人生中的一个 Photoshop Android UI Design Kit. 在那之后, 我便决定开一个关于 Android Design 的博客. 时间是 2012 年六月 —— 我写了一篇关于侧边抽屉和导航的文章. 那就是我写下的第一篇博客. 那是一个新的起点.
一开始的时候, 我只是打算和大家分享一些东西.
您得到了回复么? 
有啊. 大家的回复很积极, 于是我便意识到, &#8220;对呀, 这就是我一直以来想要做的事情!&#8221; 于是我便买了 androiduiux.com 这个域名, 很 Android 吧哈哈~ 这个域名也无时无刻不在提醒我, 专注于纯粹的 Android 上.
于是不断有反馈出现, 人们积极的讨论, 我很高兴. 对我来说其中有两个人尤其重要: Juhani 和 Roman Nurik. 他们给予我灵感, 让我明白了如果有什么观点或者意见, 不要畏于分享它们. 于是我便开始更深地钻研和设计相关的东西. 在开博一年后, 人们开始找上门问我能不能帮他们做重设计. 我从来没有计划过这些东西, 但是一眨眼的功夫我就变成了一个自由设计师.
但是 Juhani Lehtimäki 和 Roman Nurik 两位都离您千里之遥, 对么? 我的意思是, 你们只在网上有联系, 但是在吉隆坡有一位帮助与引导您的导师存在么? 
是啊, 网络的力量是强大的~ 关于导师 —— 不存在这么个人. 我是自学的. 我的 Photoshop 技能基本是自创的, 通过试错, 和一些简单的教程. 没人教我怎么用 Photoshop. 我一向认为我能一个人做到这些事情, 而我确实能够做到, 尽管可能会花上稍多的时间, 但自己学来的技能确实能起到更长的效果. 你会学到如何习得新技能. 当我还没电脑的时候, 我会从杂志中学习我需要的技能. 我的第一台电脑是一台英特尔 CPU 的 Windows 95 电脑, 从那时起我就明白了电脑的强大.
其实我对自己也是有点儿小骄傲的啦, 因为, 你也知道, 这并不容易呢.
当然, 很多地方都有设计课, 或者关于人机交互的课, 但是他们总是要花上四年 —— 而有时候, 当你和那些授课教师谈话的话死后, 你会想, &#8220;开什么玩笑, 我们社区比你厉害多了!&#8221; 因为他们的知识都是理论化而成熟的, 而我, 则更多是在实践中学习, 从真实的反馈中学习. 这样一来我能在使用电子产品的时候产生实感. 而你会一辈子记住从实践中学到的东西.
另外一个对我产生绝大影响的就是阅读 The Design of Everyday Things. 这本书彻底改变了我的思考方式. 它让我意识到一件我们很少理解的事: 当我们不能操作一台机器或者设备的时候, 错的是设计师, 而不是我们.
但是我依然坚信如果你有着足够的热情, 并且想要做好一件事情, 就一定能自己做到. 这也是我从开始之初就明白, 而且一直坚持到现在的信念.
谈完了过去, 让我们谈谈现在和将来. Google 刚刚在今年的 I/O 大会上介绍了新的 Material Design 规约. 你觉得这只是个潮流, 还是它就是 Android 的未来? Android Design 将何去何从? 
有一件事情是 Material Design 很明显地改变了的, 那就是平台一致性. 但我确实对此抱有疑问, 毕竟举个例子, iPad 的体验比起 iPhone 而言是很独特的. 所以我的疑问是, 用户真的希望所有设备上的体验都统一呢, 还是体验一些独特之处呢? 不过我还是决定乘风起航, 赶上 Material Design 的浪潮, 因为 Material Design 实在是太棒了, 是经过深思熟虑的.
对我来说, 毫无疑问它就是未来. 但是它给我一种就像两年前 Holo 刚刚被介绍的时候一样的感觉. 在早期, 每个人都只是机械地模仿规约里提到的东西. 这导致了很多应用缺乏变化与创新. 如果你有关心现在圈子里正在发生的事情, 你会看到很多人在依照 Material Deisgn 重设计 Instagram 或者 Facebook. 但是他们中没有一个是独特的, 或者从中展现了变化. 他们仅仅是把颜色和内容换掉, 然后把便称之为重设计. 虽然这并不是什么坏事, 毕竟这样能让更多人意识到 Material Design 的优美指出, 但是我依然觉得几个月后我们恐怕会看到大量长得和 Google 应用一模一样的应用出现. 人们依然在探索中, 他们还没有掌握明确的思路. 我们会看到一大波圆形头像和 Floating Action Button 到处乱飘. 这很正常, 但是我们必须再一次跳出这个框架.

我认为用户依然需要独特的桌面, 平板和手机体验. 我明白 Google 想要达成一致而且我也赞成这个理念 —— 总体而言. 但是我不能赞成必须为此牺牲独特性.
总的来说 Material Design 的出场是惊艳的. 我觉得很开心, 因为你可以感受到这是专为数字世界而创造的.
Material Design 将一些现实生活中的东西带回了数字世界, 这让用户在与数字产品交互时不需要思考太多, 而这通常是长期体验中特别重要的一环.
这也描绘了拟物与拟真的概念区别: 它并不是简单的把现实中的东西挪到数字世界, 而是一种传递与变化. 
我认为纸墨概念的选择对于很多人来说也许会造成困惑. 因为它们在现实世界中都有一些显著的特性: 纸可以折叠, 墨是液体并且可以流动, 等等. 所以开发者们和设计师们开始问这样的问题: &#8220;如果它是纸, 那为什么我不能折叠它?&#8221; 如果你没有认真读过规范的话确实是会为此感到困惑, 但是他们终将意识到, 数字世界有它独特的约束. Material Design 正是这些将人文带入数字世界中, 故此我喜欢它.
iOS 的界面是冰冷的. Material Design 专注于那些用户真正会察觉到的东西并且以更少的处理让用户们意识到它们.
这些事非常有人情味儿. 我想起了当我在伦敦的时候, 我去了一趟不列颠博物馆, 观赏了一场关于古埃及的展览. 这场展览令我震惊. 4000 年以前, 他们就已经有了详尽的网格系统, 图形设计, 与奇妙的用色, 简直令人疯狂.
作为一个设计师, 您的工作是具有高度创造性的. 您的点子都是从哪儿来的呢? 
哈哈哈, 能召唤点子的仪式是不存在的. 实际上, 我试图从周围的一切获取点子 —— 大自然, 人, 风光. 当然还有人与人之间的交流. 有意思的是, 我喜欢观察窃听 —— 咳咳, 或者说观察人类比较妥当吧. 我不仅经常在人多的地方转悠, 我也喜欢听人们在谈论些什么, 他们被什么打动了, 他们为什么而担忧&#8230; 我喜欢聆听这些对话. 似乎这些行为让我将用户牢牢至于设计中心.
我知道您对字体有着很浓厚的兴趣. 您怎么看这次 Roboto 的改版? 
挺好的呀~ 当我看到它的时候就觉得很熟悉, 也许是因为 Roboto 是由结合了一些广为人知的字体而设计的吧. 而且它的跨平台通用性非常高. 我发现一些细微的改变产生了巨大的影响, 改善了易读性. 它看起来焕然一新, 但又仍然是你熟悉的那个 Roboto. 现在它终于给人以家的感觉了.

&nbsp;
是呀, 我也很喜欢新的 Roboto. 唯一让我感到有些无奈的是他们在 2.0 版本里去掉了 K 和 R 的原本很有特色的弯曲字臂. 不过也罢. 对了, 您有打算重印那套 T-恤么/? 
没有. 过去的就让它过去吧.
您有买什么可穿戴设备吗? 比如智能手表或者 Google Glass? 您为这些可穿戴设备做设计么? 您怎么看这些东西? 
当然我有的~ 在我拥有一副 Google Glass 以前我就开始为 Google Glass 做设计了, 我遵循着设计规范设计了两个 Glass 应用. 当 Google Glass 发布的时候, 就有客户上门问我能不能把他们的应用为 Glass 做适配, 或者或者说在 Glass 上玩出点儿花样来. 最后我得出的结论就是, 字体排版太重要了, 这些可穿戴设备都充满文字.
我自己有一块从今年 I/O 大会上带回来的 LG G Watch, 不过目前为止我都没有为它设计过任何东西. 显而易见的是, 很多人已经开始跑偏了. 他们想要把一台手机放进智能手表里. 他们把键盘这种及其需要繁琐操作的东西放进了智能手表里, 而这显然 Google 不建议的.
有一件事情倒是很确定, 我认为那些可穿戴式设备有着改变我们对设计看法的潜力.
Taylor Ling 的日常是什么样的? 
(笑) 我就是个普通的正常人啦. 起床以后我先看看新闻以免错过什么在我睡觉时发生的大事. 我用 Feedly 和 Google Newsstand, 当然也会去 Twtter 和 Google+ 这样的社交网络了来获取最新信息. 当我到公司之后我会检查我的任务清单, 然后与团队做交流. 接下来就是每日例行的研究, 各种玩应用, 在 Photoshop 里画设计图, 等等. 就像个普通的应用开发者那样.
等我回家之后, 我就开始做一些自由设计师的活计. 当然这些活儿看起来好像和在公司的时候没什么差别就是了&#8230; 我每天都过得相当充实, 我相信有付出就会有收获.
平时您都用什么工具进行工作呢? 
老实说, 只有 Photoshop. Photoshop 对我而言是一个无比强大的工具. 你不仅能轻松的做出小样, 也可以做出完成度更高的设计稿, 甚至还能做简单的动画. 噢对了我也用 Sketch, 不过很少. 目前为止还没什么工具能胜过 Photoshop.
尤其是在 Material Design 时代, 我们更多的关注反馈, 动画以及各种会移动的东西, 藉此增强用户体验, 所以对于设计师来说熟知如何画出能够开发者所期待看到的的图是非常重要的. 有的时候我也会用 PowerPoint 和 Keynote 来做设计.
我喜欢您的 Android Design 挑战. 是什麽促使您举办这样的挑战的? 
这已经是我第二次举办这样的活动了, 不过我的目的是一样的: 传播 Android Design, 给人们带来启发, 向他们展示 &#8220;原来应用可以设计成这样啊&#8221;. 我博客的副标题就是 &#8220;开发者与设计师的灵感源泉&#8221;. 这就是我的目标. 很多时候, 如果你给人们一些激励, 他们就会开始做一些他们从未想过的事情.
作为一个设计师, 你会希望因自己的作品而出名. 所以我早就预料到这次活动会引起大家的注意. 我和社区里的朋友们 —— 比如 Juhani 和 Günther Beyer —— 聊了这种活动的可行性. 他们也为这活动出了很多力.

我对今年的参赛作品很满意. 比起第一年的时候, 这轮活动获得了更多的投稿, 当然质量也更高了. 这个活动正在变得越来越成熟, 更多的人开始做令人惊叹的设计, 这是喜闻乐见的.
我为第一轮比赛出了钱, 当然对我来说是值得的, 毕竟设计师们在自己的设计上花了很多心血. 不过在第二轮比赛里我从一些人那里获得了赞助.
而为什么我要这么做呢? 我觉得我是一个喜欢群居的人, 我相信当你付出更多, 别人就会回报更多. 而我也确实从社区里得到了很多, 所以我也尽量为他们做更多的事情.
您的家人和朋友支持您么? 他们理解您么? 
我双亲还不是很清楚我到底在做些什么, 尽管我试过和他们解释&#8230; 但尽管他们不知道我在做什么, 他们非常支持我. 有意思的是他们无法相信我去了伦敦和突尼斯做设计宣讲. 当然我也并不指望他们相信就是了~ :-)
您幸福么? 您对未来有什么打算? 
幸福? 哈哈当然咯. 简直不能更幸福了~ 我的意思是, 我正在做我喜欢的事儿, 而且因此交了很多我觉得不太可能遇到的朋友, 也得到了多得无法想象的东西. 我当然会继续我现在的努力 —— 成为优秀设计的布道者, 推广正确的东西. 我会走得更远, 做得更多.
您有什么忠告能给那些想要追随您的足迹的人呢? 
锻炼你的眼睛. 适当地吹毛求疵, 对自己做的事情抱有热忱. 如果你热衷于生活与工作, 一切都会顺利的.
</content>
</doc><doc>
    <docid>140</docid>
    <url>http://www.phonekr.com/mx-4-and-mtk/</url>
    <title>MX 4 与联发科</title>
    <content>这是一篇来自不愿意透露姓名的网友的投稿
在 MX 4 昨日下午正式亮相之前，关于它配置的猜测已经在魅族论坛、微博和媒体上漫天飞舞。其中最受关注的话题之一就是它使用什么样的 CPU？是不是联发科的 MT 6595？
不知道有多少人和我一样带着这个疑问走进魅族发布会场或者开始观看现场直播。到了第 11 分钟，我以为答案要揭晓了。因为魅族总裁白永祥开始介绍处理器：“我们采用了目前最先进的智能八核处理器，可以给你飞一样的体验。”（插图来自魅族 MX 4 发布会）
如此先进的处理器，哪个厂出品的？可是，除了描述它智能八核的强大之外，魅族总裁并未明确说出这款处理的型号，幻灯片上也没有标注。答案依然闷在葫芦里。我记得：在魅族去年 MX 3 发布会的同样环节里，MX 3 所搭载的 &#8220;Exynos 5&#8243;（三星猎户座 5 CPU）在幻灯片上写得清清楚楚，而且白总还用他并不标准的英语拼读了 “Exynos” 这个有些拗口的单词。
（插图来自魅族 MX 3 发布会视频）
发布会结束之际，听到周围的“魅友”询问身边的朋友：“究竟说没说 CPU 是啥啊？”，被问到的眼镜男生回答：“没听见。智能八核，肯定是 6595 啊！”。我也有同样的疑问，但不能只根据“智能八核”就轻率得出结论，万一还是三星的 CPU 呢？我需要摸到真机。在手机体验区前排队的漫长时间里，一直有身穿蓝色“魅粉服”、脖子上挂着“魅友”参会证的男生和周围的人讨论手机的参数。究竟是不是 MT 6595？内存有没有 3G？拍照效果究竟怎么样？经过 20 分钟的等待，终于轮到我入场，走向一台机器的时候，一位看起来 30 来岁的先生正在翻看着 MX 4 的设置目录，询问旁边的工作人员：“究竟哪儿能看配置信息啊？”那位女工作人员回答他：“手机里看不了，你去官网看吧”。大哥离开后，终于轮到我捧起 MX 4。顾不上欣赏它的航空铝材做工以及 Flyme 4.0 的改进，先点进应用商店下载个 cpu-z 检测工具再说。结果连接的名叫 “demo” 的 Wi-Fi 网络不畅通，下载没速度。不过这点小事情难不住我，谁让咱是媒体呐，果断点选名称包含 “Media” 的 Wi-Fi，输入密码，搞定！于是我得到了下面的的结果：是的，就是联发科出产的 MT 6595 处理器。是的，就是 2G RAM。从发布会回到家，出于职业习惯打开魅族的官网。果然已经上线了 MX 4 的精美描述。然而在这些精美的图片里，描述性能的部分，依然没有标注 CPU 的型号：

而在 MX 3 的类似页面的相同位置上，却清清楚楚写明了 “MX 3 采用 Exynos 5410 芯片”：

最终，在 MX 4 页面最后方的“技术规格”里，总算找到了官方标出的 CPU 型号：“
MediaTek 6595 魅族定制版”。在这里，魅族并没有用更为人所熟悉的 “MT”、“MTK” 或者联发科，而是选择了 MediaTek 这个更陌生的单词。当然魅族这么叫也没有错，因为联发科技有限公司的英文名就叫做 MediaTek Inc.，只是这家公司常被简称为 MTK 或者联发科。所以绕了这么一圈，最终还是确定 MX 4 就是使用了联发科 MT 6595 芯片。我只是有点郁闷，为什么在发布会开始第 11 分钟的时候不直接就说明白了？关于这个问题的答案，睿智如读者诸君，肯定也有自己的一份猜测。既然已经采用了，终究会被知道的。越说得不明确，越容易激发好奇心。聪明的用户，不管怎么样都会去搞明白想买的手机用的究竟是什么 CPU。另外一些用户也许根本不在乎自己手机用的是什么 CPU，只要自己买得起、符合所在网络、做工精致、足够流畅、系统交互精美、功能有惊喜。而魅族在这些方面并无欠缺。
也许 “中低端” 的阴影依然在困扰联发科的品牌，但 MT 6595 是一块着实不错的芯：A17+A7 大小核方案，兼顾性能和功耗。在 Android 旗舰尚未进入 64 位的 2014 秋季，这是一块可堪一战的 CPU，正如魅族白永祥先生在发布上所描述的那样，它比 MX 3 上的三星 Exynos 5410 强出太多。而且，你看他还能跑这么高的分：


（插图来自MX 4发布会）
不知道躲在魅族官网角落里的 MediaTek 会不会觉得委屈？
我只是简单地期待在更醒目的位置看到魅族将它标注出来，如同三星 Exynos。这样才公平，不管对于联发科，还是对于消费者。
魅族，你觉得呢？
</content>
</doc><doc>
    <docid>141</docid>
    <url>http://www.phonekr.com/source-han-sans/</url>
    <title>思源黑体, 一款好用的开源中文字体</title>
    <content>昨天 (在中国其实是今天), Adobe 公司联合 Google 共同发布了一款开源字体 —— 思源黑体. 这款字体由 Adobe, Google, Iwata, Sandoll 和常州 Sinotype 五家公司共同合作完成, 可以说是前所未有的由五家公司共同合作完成的字体. 正因如此, 思源黑体提供了非常完备的 Pan-CJK 字符支持, 基本可以说完美支持简繁中文, 日文汉字和韩文汉字, 并且包含 Source Sans 字体家族的拉丁文, 希腊文和西里尔文字形. 与此同时, 思源黑体家族还包含了从 Extra Light 到 Heavy 七种字重. 另外, Source Han Pro 是一款开源字体, 你可以在 GitHub 上查看和 Fork 它,  或者在 Google Noto Font 和 Adobe Typekit 上免费下载使用.
 
之所以要在锋客网特别推荐它的缘故我想大家心里应该有数: 长久以来, Android 对中文字体的支持一直很糟糕, 基本上在应用设计的时候只能采用默认的 Droidsans Fallback 来作为中文字体, 而 Droidsans Fallback 又不包含多个字重, 使得设计中想要采用粗细对比来突出重要性这个常见的手法变得异常困难. 现在出现了思源黑体, 并且 Google 官方的说法是 &#8220;这款字体在设计时便考虑到了和 Roboto 字体家族的协同&#8221;, 不得不令人感到振奋.
 

希望在下一个版本的 Android 中, Google 能把思源黑体作为 Android 中默认的 CJK 字体.
</content>
</doc><doc>
    <docid>142</docid>
    <url>http://www.phonekr.com/dont-use-splash-screen-on-your-app/</url>
    <title>Splash Screen 是魔鬼, 不要在你的应用中加入这东西!</title>
    <content>回国快一年了. 既然人在国内, 就免不了用到各式各样的国产应用. 而偏偏安卓应用的质量还大多不太能看, 问题数不胜数. 我写下这篇文章, 借此来谈谈在安卓应用上最常见的一个问题: Splash Screen.
&nbsp;
实际上, Splash Screen 算是一件很有历史的东西了. 它的起源大概可以追溯到早年 PC 游戏和各类大型桌面软件上 —— 这些应用软件在启动时需要加载大量的资源, 又不能让用户产生软件死掉的感觉, 所以一个游戏或者软件加载的时候, 就会显示一个启动画面, 然后带上一个进度条什么的, 让用户知道这个软件是在加载中而不是死掉了 (当然, 还有一些软件确实是一面显示着启动画面, 一面死掉了&#8230;).
而在移动应用上采用 Splash Screen, 又可以追溯到 iPhone 刚刚发布的时候 —— 当然, 那个时候的“启动画面”还不是 Splash Screen. 最早的启动画面是一张仿画面造应用内容的画面, 或者干脆就是一张应用截图:

(Image credit: Cyril Mottier)
iOS 应用利用这样的一张启动画面, 令用户认为应用已经载入, 与此同时在后台拉取应用数据与资源, 并稍后呈现给用户. 这样的方式取得了不错的效果, iOS 很快给大家留下了“启动速度快”的好印象. 毕竟早期 iPhone 宥于硬件条件限制, 很多应用从点击图标开始加载到可用状态几乎都要花上两三秒. 如果显示一个黑屏, 那确实是太令人不耐烦了. 而到了今天, 随着硬件机能的飞跃, iOS HIG 里已经不再建议开发者把应用截图作为启动画面, 而是建议开发者尽最大努力避免启动画面 (As much as possible, avoid displaying a splash screen or other startup experience).
实际上, 标准的 Android 应用的启动也是这么一个逻辑： 先载入应用的框架 (当然, 在 Android 上不是图片, 而是实打实的应用框架), 同时在后台拉取应用内容, 之后呈现给用户. 详见： Android Design in Action —— 初期体验. 上一个版本的知乎 Android 客户端就是这么做的, 体验也相当之不错.

(Image Credit: +Android Developers)
可以看到, 从最开始 Apple 就没打算让启动画面变成现在的 Splash Screen 的模样. 但是不知从什么时候开始, 越来越多的开发方开始打起了这块屏幕的歪心思. 开始的时候仅仅是在框架图片上加个公司 Logo 强化一下品牌什么的, 然后就不知不觉的变本加厉, 连框架图片都不要了, 直接变成了一张公司 Logo, 甚至是广告什么的…… 启动画面就这么变了味儿, 演化成了 Splash Screen.
目光转回安卓这里. 大家都应该知道, 在国内, 尤其是国内的大公司, 安卓从来都是 iOS 的附属品, iOS 方面怎么搞, 安卓方面也亦步亦趋跟着. 于是当大家在 iOS 应用上把启动画面搞成了各种公司 Logo 和广告之后, 安卓应用当然是逃不了一劫, 只能乖乖跟着改. 而且在国内, 他们甚至可以在 Splash Screen 上加入可以点击的链接……
那么, 为什么 Apple 和 Google 都把 Splash Screen 看作过街老鼠, 恨不得除之而后快呢?
首先最明显的一点就是, 现在的机能与应用配合, 已经不需要那么长的时间来加载应用资源了 (但是即使时至今日, 依然有一些应用由于优化差劲等原因, 依然需要耗费很多时间来启动, 比如, Path……). 在理想的状况下, 用户点开这个应用到应用已经完全准备就绪之间的时间, 应该是短于一秒甚至五百毫秒. 这个时候加入 Splash Screen, 只会拖慢应用的启动.
其次, 启动画面会打断用户的思考. 很多时候, 用户是在心里带着一个特定的任务打开应用的 (比如, 计算器.当然,也许知乎用户并不会经常带着任务打开这个应用吧). 此时如果应用给用户闪了一个带有其他信息的 Splash Screen, 有一定的几率会导致用户一瞬间忘记掉自己原先的任务 —— 在先前的一篇文章里, 我怒斥了 Smartisan ROM 计算器那极为糟糕的设计, 就是因为它的界面设计会让用户在启动它的瞬间看到视觉错觉而导致忘记自己原先的任务. 对于计算器这样一个应用, 让用户忘记自己打开它是为了什么, 简直是不可饶恕的错误. 同理, Splash Screen 的加入也让很多其他的应用犯下了这样的错误.
而在 Android 上, 这个问题会变得更为严重 —— Android 作为一个多任务系统, 非常经常需要在应用之间跳转. 当用户心里带着任务从另一个应用跳转到这个带有 Splash Screen 的应用时, 他有可能会因为被 Splash Screen 吸引而一时忘掉了自己原先进入这个应用的目的, 严重的阻碍了跨应用交互体验.另外, 由于多任务的特性, 应用往往会有很多个不同的入口 —— 有的时候是直接进入主屏幕, 有的时候是进入某个子层级.有的应用更因为加入 Splash Screen 而打断了导航流程, 体验极其糟糕.
若是要在应用中加入 Splash Screen, 就必然需要额外的资源. 很多国内应用的 Splash Screen 是一张图片, 而在 Android 屏幕分辨率如此碎片化的今天, 准备 Splash Screen 使用的图片无疑会占用很多空间. 更令人感到哭笑不得的是, 有些国产应用的启动器没有为不同的屏幕分辨率/比例进行优化, 在 Nexus 4, 魅族 MX 2/3 这样非主流/标准分辨率的机器上显示的就是一张拉伸过的图片, 丑陋之极.
不管你的 Logo 有多好看, 都没必要专门用一个 Splash Screen 来展示 —— Android 标准 Action Bar 上已经留了一个位置给应用的 Logo (Oops, 如果这个应用采用的是 iOS UI 的话, 那 Top Bar 上确实是没有放 Logo 的地方呢). 更何况, 想要呈示应用品牌的话还有很多更好的办法, 为什么非要选择 Splash Screen 这种最不讨喜的办法呢?
更重要的是, 不管你的 Splash Screen 做得多精美好看, 它都是在浪费用户的时间.而当 Apple 最早提出启动画面得概念时, 是为了让用户觉得应用启动迅速, 响应灵敏. 而这个出于好意的决定今天却被各个开发商用来无端浪费用户的时间. 作为一个移动应用, 内容和功能才是第一要义, 而应用多显示一毫秒 Splash Screen, 就是多浪费了无数用户一毫秒时间. Android 的设计原则中, 特别强调了 Simplified My Life 以及 Make important things fast, 不就是为了避免用户的时间被无端浪费? 开发方没有任何的理由给用户增加无谓的等待. 人们已经在生活中等待了足够多的了： 等地铁, 等红灯, 排队, 等待网页内容加载, 等待下载, 化妆/等待伴侣化妆…… 为什么还要再让他们在应用里浪费时间呢? 更何况, 智能手机本就是为了减少我们的等待而生的.
这篇文章的部分观点整理自 +Cyril Mottier 的博客 Splash Screens Are Evil, Don’t Use Them! 与 +Roman Nurik 的博客 A mobile design anecdote on perceived latency and touch feedback &#8212; Fast can sometimes feel slow.
</content>
</doc><doc>
    <docid>143</docid>
    <url>http://www.phonekr.com/quickpic-beta-testing/</url>
    <title>快图浏览开始 Beta 测试啦~</title>
    <content>Google+ Community: QuickPic Beta
或者 QQ 群: 293875492
欢迎加入~
又: 有问题不要在这里反馈, 我会直接无视的~

</content>
</doc><doc>
    <docid>144</docid>
    <url>http://www.phonekr.com/android-niceties/</url>
    <title>团队成员的 Android 实用美观小工具推荐(不定期更新)</title>
    <content>
作为一个 Android 用户, 手机上自然是少不了一些能够快速实用的小应用和小工具. 由于他们太小了以至于我们觉得单独为它们分别开篇文章是略有点浪费了, 但是不推荐又觉得忽略了这么个优秀的应用心里过意不去. 于是就有了这个小集合. (其实是为了防止有人说我最好的东西都不推荐, 藏私货什么的我会乱说?) 觉得图太小的中键点图开大图.

Weather Timeline
也许你还记得 Sam Ruston 和他的 Hue, 我之前还写过一篇文章就 Hue 的设计讨论过动画在应用中的作用. 但是天不遂人员, 某一次硬盘事故中, Sam 丢失了 Hue 的源码, 悲痛之下 Sam 打算把 Hue 推倒重来, 做一个新的天气应用. 半年过后, Weather Timeline 便诞生了.

Weather Timeline 的主界面是很普通的地区视图, 以卡片的形式呈现了你所关注的地点的天气, 附带还显示了当地的时间. 点击右下角的 + 就可以添加新城市, 左右滑动某个城市即可删除, 当然也不必担心误删, 因为删除之后都会有撤销操作可供反悔.

随便点击哪个城市卡片便会进入详情视图, 在这里可以查看当下和未来 48 小时至一周的天气情况与概述. 当你卷动到底部的时候, 便会看到一个 &#8220;Open Time Maschin&#8221; 的蓝色卡片. 点击它就会弹出日期选择器. 当你选好一个日期之后, 就等着看魔法发生&#8230;
document.createElement('video');
http://www.phonekr.com/wp-content/uploads/2014/06/SCR_20140915_115753.mp4

在非常有青花的载入动画之后, 那天的天气就这么出现了~ 而查看天气的页面也是采用了 Material Design 的配色风格与设计, 给人一种新鲜感.
这个查看过去天气的功能其实是很多天气应用都缺失的, 绝大多数天气应用只能查看现在和未来短期的天气, 但是却不能查看过去的天气, 有些小遗憾. 有了 Weather Timeline, 你就可以借助神奇的时光机查看过去的天气了, 可以说是弥补了一个缺陷.
下载地址: Weather Timeline
&nbsp;
&nbsp;
AcDisplay
回想当初 Moto X 刚刚发布的时候, Active Notification 功能和通过体感控制快速启动相机让多少人大呼&#8221;这才是 Android 应该有的样子&#8221;. 如今, 感谢 AcDisplay, 我们不需要 Moto X 也可以在手机上体验到类似 Active Notification 的感受.

当你启动 AcDisplay 后, 新通知到来时, 手机屏幕便会自动点亮, 显示出当前的时间, 日期与通知栏图标. 时间区域和通知图标区域中间的点化线就是通知将要消失的时间 —— 在一小段时间没有操作之后, 屏幕会再度熄灭. 点击时间区域或者通知区域的话会让计时器重置.
按住通知图标, 便可以在原先显示时间的位置预览通知内容, 如果通知包含图片, AcDisplay 还会把图片做模糊变暗处理之后作为背景.
手指往通知内容区滑动后放开, 便可以直接打开通知相关应用. 如果通知包含相关操作, 那么便会在通知顶端显示出操作内容, 手指滑动到操作上便可以直接执行操作. 手指向通知右边滑动, 便可以把通知消去.

如果你在非通知区域滑动, 便可以解除 AcDisplay, 进入主屏幕或者锁屏密码输入界面. 非常便捷.
AcDisplay 和还有两个独特的功能: 你可以用 AcDisplay 替换掉 Android 自带的锁屏, 还可以启动类似 Moto X 上的手势 (传感器) 唤醒功能 —— 当你把手机从口袋里拿出来的时候, 不需要再次按下电源键唤醒, 手机屏幕已经自动点亮, 并显示着 AcDisplay 的时间界面, 你只需要滑动空白区解锁就行了, 非常便利. 在使用了几个月之后, 我认为可以确定 Active Mode 并不会显著增加电量消耗.
下载地址: AcDisplay
&nbsp;
Pocket Casts
不知道大家经常听 Podcast 吗? 我是经常听 Podcast 的, 通勤, 三餐时听 Podcast 非常好打发时间, 睡前一边听 Podcast 一边看 RSS 简直是一天最好的结尾. 这当然离不开一个优秀的 Podcast 应用. Android 上堪称优秀的 Podcast 应用我觉得恐怕都没必要用屈指可数来形容了, 因为能称得上优秀的就只有 Pocket Casts 一款.

Pocket Casts 的主界面是 Podcast 封面墙. 在 Podcast 封面右上角会有未听 Podcast 数标识. Pocket Casts 提供了挺强大的过滤器功能, 已经创建和默认的过滤器都放在 Drawer 中. 另外, 添加/发现新 Podcast 功能可以通过 Action Bar 上的 + 进入, 也可以在 Drawer 中通过 Discover 进入. 如果有正在播放的 Podcast, 会在通知栏和应用的底部显示一条简单的控制栏.

在某个 Podcast 的详情页面下, 你可以进行一些快速操作: 快速将 Podcast 批量下载到本地, 全部标为已听, 分享给朋友, 设置自动下载和跳过广告 —— 有些 Podcast 开头是有赞助商广告的, Pocket Casts 提供了设置从某时间开始的功能以便跳过他们.
点击某一个特定的 Podcast 节目便会跳出详情界面, 你可以直接查看本期 Podcast 的概要, 下载到本地/通过流媒体播放, 收藏 Podcast, 标为已听或者加入播放列表, 非常便利.

Pocket Casts 的正在播放界面也很便利: 主界面是个非常传统的正在播放界面样式, 有封面大图和播放操作控件, 不过这个控件有意思的地方就在于你可以在设置中自定义快进和快退的时间. 另外, 进度条和分割线 (以及其他界面下迷你播放器的进度条和播放/暂停按钮) 的颜色会随着 Podcast 封面的颜色改变. 左右滑动专辑封面可以进入 Podcast 详情或者播放列表. 另外, Pocket Casts 还提供了变速功能, 当你觉得 Podcast 中一段食之无味又弃之可惜的时候, 开个 (红色有角) 三倍速比直接快进跳过要保险的多.
Pocket Casts 提供了非常丰富的设置. 你可以让它在手机处于充电状态的时候自动下载未听 Podcast 以便离线收听, 还能指定自动下载的 Podcast 节目, 甚至还能让它仅仅是下载节目, 而用其他音乐播放应用来播放.
另外, 不仅是应用本身, 它的开发者 —— Russell Ivanovic (Rusty Shelf) 也是个非常有趣的人, 每一次 Pocket Casts 更新时他都会写出搞笑的 Changelog 让你在更新时不觉得无聊. Pocket Casts 的跨平台也做得非常棒 —— 它的 iOS 版本也堪称优秀应用 (虽然我觉得在 iOS 上不缺优秀的 Podcast 应用): 跨平台 UI/UX 设计示例 —— Android &amp; iOS 篇.
对了, 既然说到了 Podcast, 这里不妨稍微透露一下: TingTalk Podcast 制作决定! 现在正在绝赞准备中, 敬请期待~
下载地址: Pocket Casts
&nbsp;
SlideShare
SlideShare 是一个基于 Web 2.0 的幻灯片分享网站, 于 2012 年被 LinkedIn 收购. 不久之前他们推出了 Android 客户端.

客户端的独特之处在于, SlideShare 客户端维持了其网页版的特性, 让你你可以直接在主界面浏览各种幻灯片. 这和绝大多数 Android 应用都不同.

你可以选择直接联网查看, 也可以把幻灯片下载到本地, 方便离线查看. 如果你关注了感兴趣的主题, SlideShare 一天里可以占用掉你非常多的时间. 上面的精品幻灯片着实不少.
下载地址: SlideShare Presentation App
Libra
Libra 是一个记录体重变化走势的应用&#8230;

一图流. Libra 还有个很贴心的功能就是, 他会在每天早上提醒你记录体重. 你也可以以纯数值的形式查看体重的走势.
下载地址: Libra &#8211; Weight Manager
FlightTrack
FlightTrack 是一个航班追踪应用, 它有着非常精美的界面与交互动画.

它的主界面是日程卡片列表. 卡片呈现形式非常精美, 有地图概览, 参与者头像, 日期, 状态和活动名称. 横向滑动卡片可以删除这一日程. 点击 + 按钮即可新建行程. FlightTrack 提供了一套非常便利的航班搜寻工具, 你可以通过起降机场 + 日期或者航班号 + 日期来轻松定位航班.

在搜索结果页, 航班时间会以一个线段表示, 线段的起止代表了航班的起降时间. 添加完航班之后你就可以查看航班信息了. 航班信息的呈现形式同样非常有创意, 你可以左右滑动卡片查看起降地区的天气情况与机场的厌恶概况, 也可以上下滑动卡片使其展开以查看天气详情与航班详情, 所有的过程都伴随着流畅得动画效果, 非常赏心悦目.
下载地址: FlightTrack 5
Today
Today 是一个极简风格的日记应用.

你可以用 Twitter, Facebook 和 Google+ 账号登录 Today. 它的主界面非常简洁, Drawer 里也没多少选项. 你可以选择一些热门用户 Follow.
而作为一个日记应用, 最重要的还是写日记吧. Today 比起传统日记, 更像是微博式的日记, 让你用简短的语言 (和一张图片, 可选) 来记录自己的想法. 写完文字, 可以选择颜色或者配上图片, 然后就可以发送了. 发送完了之后可以选择分享到其他应用中.

日记浏览界面有 Translucent Bars, 图片都是全屏呈现, 很精美. 往下拉动就会进入倒计时界面, 告诉你一天只能写一条日记. 你也可以向上拉动浏览其它人的日记和更早的日记, 并且评论或点赞.
下载地址: Today
Convertbee
虽然 Google Now 基本上可以帮我们解决所有单位换算问题, 但是你的设备总有没联网的时候. 这个时候就轮到 Convertbee 登场了.

Convertbee 的界面非常简单, 就是单位选择和键盘. 你可以在左侧抽屉里选择单位的类型, 也可以通过左右滑动 Tabs 来查看历史记录和收藏的单位组合.

之所以推荐 Convertbee 还有一个原因就是这个应用里的单位实在是太全了, 居然有毫, 厘, 亩, 顷这种非常本地化的单位&#8230; 简直吓死我了. 另外, Convertbee 还能在联网的时候自动更新汇率, 非常实用.
下载地址: Convertbee
Versus
Versus 这个应用就像它的名字一样, 是 Versus.com 的客户端.

我觉得一张图就可以说明很多事情了&#8230; Versus 的数据库非常全, 国产手机什么的都能在其中搜索到. 查询结果页面里你还可以登录 Facebook 账号来为比较结果的重要性投票, 或者给出你认为同样很重要的差距.
下载地址: Versus
&nbsp;
3D Live Wallpaper
这个应用在 iOS 7 刚刚发布的时候火过一阵, 因为它能够做出 iOS 7 自带动态壁纸那样的视差效果. 不过在昨天更新之后, 它变得更加厉害了 —— 它能够导入 Google Camera 拍摄的, 纪录有主体信息的照片, 并且做出景深视差效果.
由于录制视频上传太麻烦而且画质不好 (专栏不支持 YouTube), 所以我就不录制视频了. 现在的 3D Live Wallpaper 的照片视差功能还比较不完善, 移动的距离大的话就会看出主体边缘的各种诡异重影或者脱线, 但如果只是小幅摆动设备的话, 观感还是非常有趣的.
下载地址: 3D Image Live Wallpaper
Scene
Scene 是一个很特别的照片管理与分享应用.
它的主界面是一个照片墙, 按照时间顺序从新到旧列出了所有的照片. 当你下拉列表它便会刷新, 这个刷新的动画非常有爱. Scene 提供了很有趣的照片管理功能, 便是分组相册功能. 向右拖动主界面即可进入分组模式, 你可以选择多张照片拖入一个相册中, 会有非常顺滑流畅的动画伴随着你的操作.
Scene 还能让你非常便利的寻找已经拍下或保存的照片. 你既可以在概览界面中拖动右侧的时间滚动条寻找照片缩略图, 也可以点击写着日期的白色方块进入日历视图来寻找照片.
另外, Scene 还具备非常方便的分享功能. 登陆了 Scene 帐号之后, 便可以方便的将一个相册分享给朋友. 另外, 在创建的时候你会看到在 Android 上罕见的漂亮动画.
之所以说 Scene 特别是因为它有着非常丰富而细腻的动画. 虽然在功能上也许并不是那么的丰富, 但是冲着方便的照片管理分享和那细致的动画, 就值得你去下载一个来试用一番了.
下载地址: Scene
CloudMagic
也许你会觉得很奇怪, Gmail 在 Android 上已经有一个如此强大的客户端了, 为什么还需要各类第三方客户端呢? 答案当然是因为这些第三方客户端都由各自的不可替代的特色. 先前发布的 Dropbox Mailbox 因为太丑了我就不推荐了, 这次要推荐的是一个既美观又特别的邮件客户端, 它就是 CloudMagic.

CloudMagic 支持多账户和多种不同的邮件服务. 我在我的手机上登陆了 Gmail 和 Hotmail. 多个账户会以可以展开的 Drawer 项目的形式呈现. CloudMagic 会自动为这个账户分配一个颜色.
CloudMagic 可以同时在一个界面里显示来自不同邮箱的邮件, 在最右侧用颜色条儿表示收件邮箱. CloudMagic 也支持滑动操作, 只不过不像 Gmail 那样滑动直接归档, CloudMagic 采用的是比较保守的滑动 + 点击操作, 既比纯点击要方便, 又比纯手势要安全.
CloudMagic 的一大特色功能 (也是为什么我留下了它而不是 Mailbox 的理由) 就是能够对邮件内容进行一定的快速操作. 比如说我收到了来自 Medium 的一周汇总, 里面有非常多的文章链接. 这时我只要双击邮件正文, 就会出现内容分析 (卡片) 页面. 在第一章卡片中, 我可以直接把邮件里提到的连接中文章直接放进 Pocket 以更好的版式进行阅读, 或者直接将邮件加入 Evernote 笔记/新建 Trello 卡片, 非常方便. 开发者表示更多的快捷功能还在开发中, 以后会陆续加入.
下载地址: Android/iOS
Vivino
不知道有多少读者是会平时喝点酒, 并且愿意了解自己喝的酒的呢? 虽然我不喝酒, 但是出于照顾这些酒友 (其实原因是这个应用真的很精美) 考虑, 这次来推荐一个关于酒的应用, 就是 Vivino.
&nbsp;
Vivino 是一个跨平台应用, 有 iOS 版本, 设计得同样非常精美. Android 版比起 iOS 版有个独特之处就是可以支持用 Google+ 登录, 非常便捷.
Vivino 没有采用最近大为流行的 Drawer 作为导航方式, 而是采用了最经典的 Tabs 设计. Vivino 在 Action Bar 上放置了一个硕大而醒目的拍照按钮, 这个设计非常有意思, 而且我也很喜欢. 拍照的功能是让你拍下酒的酒标以供识别.
默认界面是时间轴, 你可以在这里查看你关注的人最近都喝了哪些酒. 你也可以通过 Action Bar 上的另外两个功能键方便的从 Facebook 或者 Twitter 添加新朋友.
&nbsp;

在第二个 Tab 中, 你可以查看自己曾经记录过的酒, 以及他们的详细信息. Vivino 会自动识别你拍下的酒标并且转化为酒的属性, 你可以查看到这瓶酒的各种信息以及大家的评价. 当然你也可以自己写评价, 这样你的酒友们就会看到你对这瓶酒的评价.
另外两个 Tabs 下的功能是查看为你推荐的酒以及探索附近的酒庄/酒馆. Vivino 会根据你喝过的酒以及你评价朋友们的酒来分析你的爱好, 为你推荐合适的酒. 在查看附近酒庄/酒馆的功能中, 你可以方便的查看附近的这些酒庄/酒店里都有提供哪些独特的酒, 它们的价格, 以及酒友们的评价.
下载地址: Vivino &#8211; Vine Scanner
Reverse Dictionary
当你正在写作的时候, 会不会偶尔发生提笔忘字的情况呢? 最近我是越来越经常遇到这样的情况了, 是不是因为老了啊&#8230; 不管怎么说, Reverse Dictionary 是一款可以帮助你解决这种问题的应用 —— 当然, 仅限英文&#8230;
这款应用非常简单 —— 你输入想要查询的文字, 然后它告诉你这些文字对应的单词. 比如说我想到了一个词, 大概是和食物相关的东西, 但是我又一下想不出它到底是什么词, 我就可以通过查询 &#8220;delicious food&#8221; 关键词来看看. Reverse Dictionary 还在每个词语的解释页面中加入了同义词专页, 可以方便的查看同义词和近义词, 非常实用.
下载地址: Reverse Dictionary
Sunrise Calendar
这个之前在 iOS 上大热的优秀日历应用最近也在 Android 上开始了它的 Beta 测试. 比起原生的 Android 日历和 Google Calendar, 它的操作很新颖, 界面也很美观, 月/周视图比起 Google Calendar 更为科学, 我觉得很值得推荐.
这就是 Sunrise Calendar 的主界面. Action Bar与周指示合为一体, 颜色组合干净素雅, 不像 Google Calendar 那样如果你的日历项目多的话就显得乱七八糟的. 纵向拖动月历区域能展开月历视图便于浏览不同月份, 左下角的箭头可以快速让你回到现在的时间点. 月历下方就是日程表, 可以快速浏览过去和将要到来的事件 (而且会标注出还有多久开始), 比 Google Calendar 那样的要么显示月历, 要么显示日程的方式要灵活.

向左滑动主界面或者点击 Action Bar 上的三条竖线就会来到周历视图. 周历视图其实和 Google Calendar 并没有什么本质上的区别, 无非就是让每一天的宽度变大而已. 但是每天宽度变大的好处就是 Google Calendar 中一旦你的行程安排很多 (或者同时显示多个日历) 的话就完全不能看到日历详情, 而 Sunrise 还能看到一些. 单击事件就可以进入事件详情视图, 这个界面现在应该还在改进中 (毕竟是 beta 版本), 没有什么亮点, 相信以后会变得更完善的.
下载方式: 申请加入 Sunrise Calender for Android 的 Beta 测试社区 (前提你得要有个 Google+ 帐号), 通过之后进入 Google Play 的 Beta Tester 申请页面确认申请之后即可下载.
Event Flow

首先如你所见, 它是一款锁屏小部件, 也是一款主屏小部件. Event Flow 提供两种形式的小部件, 一种是事件流视图, 一种是月历视图. 其实基本上也没什么好多说的, 看图就很明白了. Event Flow 的一个特殊之处就是他会在每天的第一个事件旁边显示当天的天气预报 (能显示四天), 很方便. 另外月历视图下也可以通过颜色条来大致看出一天的行程安排.

Event Flow 提供了很详细的自定义设置, 你可以自己定义小部件里几乎每一项元素的颜色和透明度. 当然你也可以直接采用内置的四种主题, 一般情况下这就很够用了.
下载地址: Event Flow Calendar Widget
&nbsp;
Maps Measure
也许你会怀念旧版 Google Maps 里的一个实验室功能, 那就是地图测量, 可以很方便的测量地图上任意数点之间的距离, 对于规划长跑路线等行动来说非常方便. 可惜在新版地图里, 这个实验室功能被取消了. 不过不用担心, 现在 Play Store 上有了一个更强大的替代品, 那就是 Maps Measure.
铛铛! 如你所见, Maps Measure 不仅可以测量任意数点之间的长度, 而且还可以测量任意闭合多边形的面积! 简直太方便了~

Maps Measure 支持公制和英制单位, 可以方便美国同学直接查看测量结果. 同时它还支持搜索和切换地图为卫星图模式, 可以方便的在地图上找到你想要找的地方~
下载地址: Maps Measure
&nbsp;
Inflikr
可以说是 Android 上最美观的 Flickr 客户端吧, 采用了漂亮的 Translucent Bars 营造出了沉浸式图片浏览体验, 各种功能和分享也很完善, 没什么好挑剔的了.

Inflikr 的主界面就是照片墙, 如果你的自己人上传的图片很好的话这面照片墙的冲击力就非常强烈, 能牢牢吸引住你的目光. 左侧 Drawer 可以切换浏览的分类或者搜索, Inflikr 也提供了附近的人和探索功能. 另外, Inflikr 的保存分享非常便捷, 只要按住图片拖动到相应的位置即可完成, 并且它还支持直接将图片保存到 Dropbox, 非常方便.

Inflikr 还有一个杀手锏就是支持 Muzei 动态壁纸, 你可以在桌面上看到你最喜欢的摄影师的作品集或者你的自己人发的照片, 简直赞~
下载地址: Inflikr for Flickr
&nbsp;
Type Machine
也许你也在 Android 上遇到过这么个问题: 辛辛苦苦在 Gmail 里码了好长一封邮件, 然后不知因为什么原因, 突然间 Gmail 就 FC/ANR 了, 然后你辛苦码的字就全部付诸东流了&#8230; 这个时候是不是非常想摔手机?
大家都知道 Mac OS X 有个非常牛 13 的功能叫做 Time Machine, 可以在关键时刻救数据于水火. 现在, Android 上也有了这么一个能够在关键时刻救你码的字于水火的应用, 就是 Type Machine.
 
Type Machine 可以记录你在任何应用中输入过的文字. 除了能恢复之前输入的文字之外, 你还能在应用中查看输入文字的历史版本, 方便修订. 你还可以给应用设置 PIN 码, 防止你输入过的东西被别人看光光.
应用只要求了自启动权限, 其余功能是通过 Android 的辅助功能实现的.
下载地址: Play Store ($1.99, 看作买保险的话这真的很超值了)
&nbsp;
Switcher
这个应用相当于是 Android 的 Recent 键加强版, 能够让你方便的在各个应用中快速切换.
  
Switchr 提供了三种不同的切换模式 —— 卡片式, Cover Flow 式与弧式. 藉由由屏幕边缘自定的几像素热区向屏幕内滑动的手势, Switchr 便会出现. 它提供了快速切换/关闭运行中应用与关闭全部运行中应用 (关闭功能需要 Root 权限) 的功能, 并且能在切换应用的时候实时预览应用的运行状态, 非常方便实用.
除了预览/关闭运行中应用, 你也可以选择固定一些常用应用到列表底部, 这样就可以方便的从任何地方启动它们.
这个应用的开发者还开发了下面提到的 RoundR.
下载地址: Play Store/Pro 解锁.
&nbsp;
Muzei
还在为找不到合适的动态壁纸而操心? 喜欢换壁纸, 但是总觉得自己动手换好麻烦啊 &amp; 有些壁纸太亮/太花不适合放在桌面? 想要找些高大上的壁纸彰显自己的品味? 现在这些都不是问题了, 因为我们有了 Muzei, 一个高大上动态壁纸应用!
 
在默认状态下, Muzei 会每天推送一张世界名画作为你的壁纸. 应用的设置项非常简单, 只有模糊程度和变暗程度两种, 把这两个数值调整到合适的状态, 就不必担心壁纸过于明亮或花哨而影响主屏可视性了. 而只要在主屏空白处双击, 壁纸的原貌就会显现出来.
除了世界名画, 你也可以选择从自己的图库 (自带功能, 可以自定义切换壁纸时间) 或者 Tumblr, 500px 等网站 (需要插件) 来获取壁纸. 这个应用的 API 是开放的, 感兴趣的开发者可以访问他的 GitHub 来查看.
除了壁纸, 这个应用本体也非常精美, 有着漂亮的过渡动画与细节设计. 这个应用来自 DashClock 的开发者, Android Developer Relation Team 的 Roman Nurik. 目前 Play Store 上已经有一些不错的插件了, 比如前面提到的 500px, Tumblr, 还有 Reddit 插件.
下载地址: Play Store/插件.
&nbsp;
Cloud Emoticon
喜欢在 Android 上卖萌但是每次想要输入颜文字都要切换输入法? 输入法自带的颜文字表情没法满足你变态的卖萌需求? 还是说, 你已经达到了能够手打颜文字的至高境界? 有了 Cloud Emotion, 卖萌从未如此简单~
 
安装完应用之后, 你可以从 drawer 中的分类里选取你常用的颜文字, 添加到喜爱列表里. 之后, 你就可以随时方便的在通知栏里访问它. 打开之后默认进入喜爱列表, 点击某个颜文字就会自动将其复制到剪贴板并返回到上一个界面, 这时你只要粘贴就能完成了, 非常方便.
这是一个开源应用, 开发者提供了 GitHub 页面.
下载地址: Google Play.
&nbsp;
Beam File
Android  自带的 Android Beam 已经为我们的生活提供了非常多的方便, 通过它我们可以方便的交换名片, 照片和应用/音乐/书籍等. 但是 Android Beam 对于天朝用户而言依然不够强大 —— 如果我想要传给别人一些 mp3 文件, 或者一个 Zip/APK 包, 那么 Android Beam 就无能为力了. 这时候, 就轮到 Beam File 登场了.
 
主界面可以在设置中改成这种对话框, 甚至还能隐藏掉广告, 简直节操满满. 应用没有启动器图标, 所以设置必须在准备 Beam 这个界面进行.这个应用的方便之处在于, 只要发送方装有这个应用便能完成 Beam, 接收方甚至无需支持 Android Beam (开发者甚至可以以 Nokia N9 作为接收对象). 可以说任何能在文件管理器查看的文件都能够通过 Beam File 发送到其他手机上, 异常方便.
这个应用的开发者同时也是 Tinted Status Bar (一款 Xposed 插件) 的开发者.
下载地址: Play Store.
&nbsp;
Google Now LiveWallpaper
Google Now 有一个很有趣的特点就是搜索框的背景, 这个背景会在不同的时间/地点改变, 节日和纪念日还会变成相应的 Google Doodle. 于是就有开发者把 Google Now 在不同时间和地点显示的背景图给提取了出来, 做成了一个动态壁纸. 不过为什么是动态壁纸呢? 嘛, 当然是因为动态壁纸才能在每天的不同时间切换成符合那个时间的图片啦~
 
实际效果就是这个样子, 你可以在设置中自定义清晨/日间/黄昏和夜晚开始的时间, 壁纸会在那个时间自动切换成相应的壁纸.
下载地址: Play Store
福利: Google Now 壁纸 (分辨率皆为 2560X1098)
&nbsp;
RoundR (By NovaDNG)
很多老 webOS 用户也许会怀念 webOS UI 的边缘圆角卡片吧.
 
最近在 Play Store 中出现了一个小应用, 它能够把屏幕边缘四角变成圆角. 这就是 RoundR.
 
 
这款应用只有 68K, 权限要求也非常干净(在其他应用上方显示, 自启动). 你可以自定义圆角的弧度, 也可以自定义想要变成圆角的角.
顺便一提, 这个应用的开发者同时是开发了 Slidbar Pro 和 Floating Stickies 的人, 他对 Draw over other Apps 的应用可以算是驾轻就熟了~
下载地址: Play Store
&nbsp;
Wakey (by NovaDNG)
有的时候, 我会想要让屏幕保持常亮. 现在有了 Wireless Charging Orb, 我只要把手机放上 Wireless Charging Orb 就行了, 但是如果没有呢? 还得把开发者选项里的&#8221;充电屏幕常亮&#8221;勾上, 然后插上充电器, 或者去设置里把睡眠时间调成关闭, 多麻烦, 而且以后有可能会忘记改回来. Wakey 就提供了一个快速的让你的屏幕暂时不会自动关闭的手段.
 
左图就是应用的主界面了, 及其的简约, 但是丝毫不显简陋. 右下的 G 其实是一个网站, 相当于广告 + About 吧. 不过这个广告在这里也是相当和谐, 丝毫没有违和感. 右图是它的 Widget.
 
当 Wakey 启动之后, 你就会在通知栏中看到黄色小灯泡. 点击主体可以进入 Wakey 应用(虽然我觉得毫无意义), 点击下面的 Deactive 就可以关闭.
下载地址: Play Store
&nbsp;
Hashnote (by NovaDNG)
作为一个超级简单的记事应用, Hashnote 只有 779k, 但是它却提供了两个很有意思的功能——#Hashtag#话题功能和 @at 提到功能. 简而言之, 它可以识别出你笔记中的 #话题和 @提到, 然后在 Drawer 中呈现.
 
左图便是 Hashnote 的初始界面. 所有笔记会陈列在上面, 其中的 #hashtag 和 @mention 会以不同的颜色高亮显示. 顺便从左图里也可以看出, 邮箱地址是不会被误判为 @mention 的. 右边是我新建的笔记. 由于这个应用的特色就是 #hashtag 和 @mention, 所以在键盘上面会看到应用提供的 # 和 @, 让用户可以快速在笔记中插入这两个符号.
 
在主界面向右滑动就会打开 Drawer. 你所有的 #hashtag 和 @mention 都会呈现在其中. 点击某个 #hashtag 就是简单的过滤, 主页面上将只会显示含有这个 #hashtag 或者 @mention 的笔记. 当然, 你可以在记笔记时套用复数个标签, 这样就可以在过滤时得到唯一含有你选中的标签的笔记. 当然, 我觉得如果能够把选中的 #hashtag 或者 @mention 在 Action Bar 上显示那就更好了.
顺便说一下我没有截图的中文支持. 中文支持是没问题的. 但是一定要在 #hashtag 前后加空格(而不像普通的中文撰写那样不留空格), @mention 也同理.
下载地址: Play Store
&nbsp;
Periodic Table (by NovaDNG)
去年我学化学的时候那是各种苦逼, 本来我就不是很擅长计算之类的东西, 然后元素周期表也没背好, 分子式, 摩尔量计算什么的真实把我折腾的晕头转向. 这学期喔学乖了没选化学课, 但是却在这时候发现了这个应用&#8230;
 
这个应用非常非常小, 只有  187k. 左图便是应用主界面. 其实这是个列表显示的元素周期表. 不同的颜色代表该元素的类型. 一个值得注意的地方是, 所有的配色都是 Android 标准色, 看着很舒服. 你可以在搜索栏里输入你想要查询的元素的符号或者全名(要是支持输入质量或者电荷量查找相应元素那就神作了)查找相应元素. 右图是元素的信息页面, 可以说很精致美观.
 
在元素的详细信息页面, 你可以看到这个元素最主要的一些信息: 全名, 原子量, 符号, 原子序数, 类型, 电性. 在&#8221;更多&#8221;中还有元素块, 族, 周期, 以及尚在开发的其他功能.
 
虽然说这只是个元素周期表应用, 但是它还附赠了摩尔质量计算器和摩尔数计算器. 你可以简单的用数字来表示脚标.
其实这个学期没选化学课之后我就发现关于化学课的内容我已经忘了差不多一干二净了&#8230; 所以没事的时候打开这个应用稍微温习一下也没什么不好的&#8230; 以后反正还是逃不了化学课, 还不如早点准备&#8230;
下载地址: Play Store

&nbsp;
Ultimate Stopwatch &amp; Timer (by NovaDNG)
这个计时器其实非常非常早就有了(貌似从 2008 年 Android 刚出来没多久的时候就有了, 不信可以看下载量), 不过直到这个版本才采用了 Android Design, 变得算是美观实用了.
 
和 Opoloo 团队的计时器不同, Ultimate Stopwatch 走的是略显复古的路线, 计时器表盘非常华丽. 默认 Tab 是秒表, 提供了基础的秒表功能和记圈功能. 有意思的地方是每过一秒都会由一声&#8221;哒&#8221;的音效.
 
最后一个 Tab 提供了倒计时功能. 需要点击 Action Bar 上的闹钟按钮来设定时间. 就倒计时功能而言 Timer 虐翻它&#8230; 通知栏提醒也没有充分利用 Android 4.1+ 的优势, 只能说聊胜于无.
下载地址: Play Store
&nbsp;
Holo Compass (by Davids.Zerro)
Android 上的指南针一向为我所诟病&#8230;“怎么就没有 Holo Theme 的啊！！”于是，Holo Compass 一出，我就不再抱怨了。提供黑白两款主题（重启应用生效），以及流畅的转动效果，以后御用就它了。至于底下的“NSWE”是方向指示，你可以快速判别出你现在面对的方向。
 
下载地址: Play Store
&nbsp;
Air Quality China(中国空气质量) (by NovaDNG)
最近几天我们的帝都似乎又被阴霾笼罩, 对空气质量的关注又达到了一个顶峰. 也许有的 Android 用户羡慕 iOS 设备上有很多精美的 AQI 监控应用, 其实 Android 上也有符合 Android Design 的 AQI 监控应用, 就是我今天推荐的这个 Air Quality China.
  
左右拖动下面的图表区可以切换 24 小时数据和 30 天数据.
 
设置在齿轮图标而不是 Action Overflow 里, 略有点迷糊(不是重点). 可以在设置中选择城市, 我大略看了看, 基本上是覆盖了大部分大城市. 可以在这里选择监控站和数据形式(平均值, 最大值). 同时应用还提供了桌面 widget.
这个应用似乎也是个人作品, 作者是@Only在水一方, 感兴趣的同学可以关注他.
下载地址: Play Store.
&nbsp;
AntennaPod (by NovaDNG)
想在 Android 设备上听 Podcast, 又嫌没有一款既好看又轻便又靠谱的 Podcast 应用? 让 AntennaPod 拯救你的灵魂! Holo Theme, 小巧轻便, 功能齐全, 还附赠海外 Podcast(MiroGuide) 列表, 能设置睡眠定时, 可以使用流媒体收听也能下载到本地收听, 实乃居家旅行听 Podcast 必备之物~ 而且这货是开源的, 你可以去 GitHub 提交遇到的 Bug 或者干错 Fork 一遍自己来定制~
  
 
下载地址: Play Store.
Slider Widget (by Davids.Zerro)
有了这个，再也不用跑设置里调音量了！再也不用蹂躏音量键了（CM User请无视）！Slider Widget 有着全Holo theme 风格和色彩，可以让你在桌面建立多种样式的插件，点击插件就可以单独地线性调节音量，所谓线性调节嘛&#8230;就是将音量分成12级，一级一级地调&#8230;逐个数字准确地调&#8230;（强迫症最爱！）另外插件支持每个图标单独设置，还有Davids.Zerro（这货是谁？）最爱的透明度调节&#8230;伙计，上图！
         
下载地址：Play Store （还有天朝用户防和谐下载地址：酷市场） 另外，请不要吐槽没有中文，那几个英文给点耐心都能看懂&#8230;
Silence (by NovaDNG)
一款定时静音/飞行模式的应用, 功能上说是之前推荐过的 Shush! 的增强. 他还能定时开启 Wi-Fi 和蓝芽. 比较有意思的是他的定时可以分星期, 比如我周一这个时间要开会, 那么我就新增一个只在周一这段时间有效的, 静音, 关闭 Wi-Fi 和蓝芽的情景模式. 善加使用可以省电和避免尴尬.
 
下载地址: Play Store (有广告, 但是可以用 AdAway 去掉. 觉得好的同学可以买 $1.99 的付费版支持作者).
&nbsp;
Fuubo(抚波) (by NovaDNG)
如果很多时候你只是想发微博, 而官方客户端又臃肿又丑陋让人一点都不想看, 这时候你就可以试试抚波了. 抚波是专门用来发微博的工具, 但是做得非常精致漂亮. 可以在桌面上创建快速拍照发微博的工具, 能发定时微博, 离线微博(离线保存, 联网时自动发送), 支持草稿箱, 支持多帐号. 某种意义上和四次元互补.
 
 
下载地址: Play Store.
&nbsp;
Notification Weather (by NovaDNG)
  
 两张图就够了, 你可以看到这个通知栏天气显示了当日天气, 最高/低气温, 风速和四日天气预报. 最重要的是他的风格和 Android 4.X 严丝合缝, 放在通知抽屉里没有任何的不妥之处. 另外这款应用必须要在 Android 4.1 或以上的设备上才能运行.
下载地址: Play Store
&nbsp;
 Awesome On Off (by NovaDNG)
很早之前在微博上似乎推荐过. 这个应用没办法上截图. 你需要知道的是, 开启 Awesome On Off 之后, 你只需要在光线感应器/距离感应器(反正大多数手机上这俩货都是在一起的)钱轻轻挥手两次, 手机便会锁屏. 在锁屏状态下, 你只需要把手机从平放抬起到呈 30 度角面对自己, 手机屏幕就会开启. 这个功能不需要 Root, 也就是说任何 Android 手机都能用.
下载地址: Play Store
&nbsp;
Faster GPS(需 Root) (by NovaDNG)

AdAway 作者的另一个作品. 可以预先确定你所在的区域, 简短搜星时间. 在美国这里试用有奇效, 室外冷启动 GPS 居然能在 10&#8243; 之内搜到星. 不知道在大陆还有没有这么好的效果.
下载地址: Play Store
&nbsp;
Safe In Cloud (by NovaDNG)
 
这个东西是用来给健忘的人(比如我)保存各种网站的登录帐号密码, 银行卡账号什么的. 可以藉由 Google Drive 在各个设备间同步. 至于为什么没有界面的截图呢? 呃, 因为这货在前台运行的时候是不能截图的&#8230;
下载地址: Play Store
Mapsaurus Beta (by NovaDNG)

Mapsaurus 是一款可以帮你找到与一款应用相似的应用的应用(哎呦怎么这么拗口). 只要选中一款应用, Mapsaurus 便会开始分析它的关键词, 然后给出四个相关应用. 你可以不断的在相关应用里进行扩展查询.
下载地址: Play Store
</content>
</doc><doc>
    <docid>145</docid>
    <url>http://www.phonekr.com/navigation-drawer-done-right/</url>
    <title>正确的使用 Navigation Drawer</title>
    <content>译注: 这篇文章来自博客 Android UI/UX, 作者为 Taylor Ling.
这篇文章在现在看来恐怕很快便会显得不合时宜了, 因为 Google 刚刚更新了他们的 Google+ 应用, 采用了新的导航方式并抛弃了 navigation drawer. 当然, 我是丝毫不认为 Drawer 会很快淡出我们视线的.
在最近到来的 Gmail 更新里, Google 终于把它的 drawer 形式进行了统一 (比如在低层级界面中也可以通过边缘滑动唤出 drawer, 而且也把设置/帮助/反馈等操作放进了里面), 我个人是相当乐于看到这样的情况的, 因为有了这样的事实基础, 我们就可以更好的谈论谈论这个设计模式的一致性 (我认为 Google+ 和 YouTube 迟早也会改成这样的). (译注: 同感, 现在的 Google+ 看起来更像是个过渡版本) 我假设你已经看过这两篇关于 navigation drawer 是如何降低了用户活跃度和为什么以及如何避免汉堡菜单的文章 (如果你比较关注和 UI/UX 相关的新闻的话), 如果没看过的话, 建议你看一下 —— 这两篇文章都很有意思. 在 Zeebox 的案例 (文章一) 中, 我不太能理解为什么他们会决定采用 navigation drawer —— 显而易见的是这个应用并不需要采用 navigation drawer, 如果让我来设计的话我也许会采用 QuickReturnTabs (就像现在的 Google Play Newsstand 中那样), 来适当的增加屏幕可用空间 —— 尽管如此, 还是感谢他们提供了一个算是有参考价值的 A/B 测试. 这两篇文章 (以及我相信还有很多我没看到的) 都想要传达这样的观点: navigation drawer 是一个糟糕的设计模式, 请务必不惜一切代价回避它. 但是我在这儿显然是要唱个反调: 在 Android Design 的语境中, 你应该放心的使用它 —— 但是仅在真的有必要且经过仔细思量的前提下.
理解 Android 中的 Navigation Drawer
在 iOS, 尤其是在 iOS 7 中, 侧边菜单确实是与导航元素 (尤指返回键) 和侧滑返回操作 (但这个操作并不是真正的全局通用操作, 如果我记错了的话请不吝指正) 冲突, 但是这和 Android 上的情况完全不同. Android 上的 navigation drawer 要复杂得多, 边缘侧滑手势被保留用于从任意一个导航层级接入 navigation drawer (当然我知道在这个地方可见性是一个问题), 这保证了即使你在应用的深处也能令顶层导航有很好的可访问性. 在 Luis Abreu 的文章中那最关键的限制, 即平台导航模式冲突, 在 Android 上便不复存在了 (当然, 我知道他说的是 iOS 7).
信息结构 (Information Architecture, IA) 调整
对于 Luis Abreu 提出的, 关于当你采用 navigation drawer 时应当作出信息结构调整的观点, 我还是非常认同的 —— Navigation drawer 并不是一个能解决所有导航需求的万用解. 无论何时, 站在更高的角度来重新思考应用结构, 以便找到如何通过移除那些无益于展现内容的不必要的层级/信息以达到减少导航深度的方法, 都是件好事: 在 Android Design 中, 有一个写得不错的应用结构推荐.
姿势正确

如果在经过了仔细的考虑之后依然觉得有必要使用 navigation drawer 作为顶级导航方式, 那么请用, 并且以正确的姿势用. 并不是说我限制你的发挥, 而是因为作为一个需要被大量使用的交互方式, 它最好还是保持在设计规范的约束之内以维持一致性, 让用户觉得熟悉与可靠. 我们总是希望用户能&#8221;一次学习, 终身使用&#8221;, 尤其是站在整个操作系统的角度上来看 —— 我是不太想说这样的话, 但是每一个 Android 开发者与设计师都有责任在建立和维持 (注) 一致性这方面贡献自己的力量, 这样用户们就不必面对支离破碎的交互方式愁眉不展了. 用户越快的掌握如何使用一个应用并做到他们想做的事情, 他们就越满意.

注: 我知道时至今日有些 Google 自家应用依然没能与最新的 navigation drawer 设计模式保持一致, 但是我很确定他们正在改进. 别忘了 navigation drawer 花了多长的时间才进化为今天这个模样的. 早在 2012 年我就已经写过一篇关于导航抽屉的文章了!

&#8220;眼不见为净&#8221;
在 Anthony Rose 的关于 navigation drawer 的文章和在下面展示的来自 Luke Weoblewski 的推文中, 他们试图告诉我们, 当导航方式不是那么直观的时候, 用户的参与度便会降低 (尽管我不是很能确定在 Luke 的图表中到底是以什么作为参数的).
 @lukew: 直观总是赢家.
在一些情况下确实是这样的. 这个统计报告看起来非常唬人 —— 但我不认为我们看到了这些案例的全貌. 用户参与度降低意味着什么? 是意味着用户们不再在应用内探索了, 还是意味着第一屏 (也就是主界面) 对用户而言已经足够了? 会不会是意味着用户们在应用内 (因为干扰减少了) 以更快的速度与更少的操作完成了他们想要做的事情呢? 如果我的应用能够帮助用户提高效率, 我会把这样的结果视为一个成就 —— 毕竟这很大程度上意味着我的应用能让用户更快的达成目的. 当然, 我也非常赞成&#8221;眼不见为净&#8221;的设计理念, 但是这并不意味着我们必须要把所有的东西都暴露给用户, 毕竟每个 UI 元素在交互中都扮演着不同的角色, 他们都有着独一无二的重要性. 所以当你又一次需要用到 navigation drawer 的时候, 确定你是真的需要它 —— 你看, 新版的 Google+ 应用就证明了有时候, navigation drawer 也并不是唯一的选项 (译注).
延伸阅读: 由饭本前设计师 +Stephen Day 写的《从 Google+ 更新说说 Navigation Drawer》
</content>
</doc><doc>
    <docid>146</docid>
    <url>http://www.phonekr.com/mipad/</url>
    <title>小米平板的变数</title>
    <content>
昨天, 作为中国 Android 界影响力最大厂商之一的小米推出了自己的平板. 这台小米平板有着亲民的价格, 看起来高得吓人的配置, 以及依然不知道什么时候能买到的悬念. 另外一个亮点是, 小米平板采用了和 iPad mini with Retina display 一样的屏幕分辨率, 而小米甚至直接宣称这是为了“方便移植 iOS 应用与游戏”.
那么, 小米平板能为颓靡的中国 Android 平板应用注入一剂兴奋剂, 带来正向的促进吗?
这里看法比较悲观: 小米平板也许并不会带动大量开发者适配平板应用, 而最终会发展成一个新的&#8221;小米平板生态&#8221;.
小米平板最大的卖点, 从官方宣传来看应该是阅读. 小米平板的官方网站专门用了一整个页面来展示其优秀的阅读器和阅读效果. 甚至连 MIUI 在功能上的优化等都是一笔带过 —— MIUI 页仅仅是提及了平板适配系统应用 (所谓适配无非是拉大了应用并使内容充满屏幕, 也并没有应用到 Android 标准大屏解决方案的多分栏布局等) —— 且依然花了很大篇幅渲染优异的阅读体验, 而办公功能更是只用了一张图片草草说明. 而实际上, 小米平板作为一个消费内容的娱乐平板, 本身已经自带了足够多的内容资源了 —— 阅读方面有前面大肆渲染的多看, 音乐和影视都有自己的资源 (小米平板宣传页), 而这些资源才是小米的盈利重点. 可以说, 小米平板对第三方应用的需求其实很小, 只要开发者能适配游戏就可以满足作为一个娱乐板的所有需求.
而游戏方面, 小米采用了和 iPad 一样的分辨率, 暗示 (简直是明示) 游戏开发者&#8221;之前在 iPad 上用的素材只要原封不动搬过来用就可以了&#8221;, 一段时间内, 应该会有一些游戏开发商愿意针对它进行适配.
实际上, 这其中还有很多变数. 比如普及度. 如果没记错的话, 今天发布会说的是&#8221;六月中旬公测&#8221;, 结合小米一贯的饥饿营销 (或者说卖期货) 手段, 以及 Tegra K1 的铺货时间, 也许等到年底这台平板都不能得到很好的普及. 更何况在中国, 连三星 Galaxy Tab Pro 等大厂产品都没能引起广大应用开发商的重视, 可以认为大部分开发者认为平板用户很难对他们产生价值, 由此可以推断, 一个等到年底都不能经常在街上看到的平板不太可能让他们积极的去适配.
不过还有另一个变数, 那就是米粉. 俗话说会哭的孩子有奶喝, 会闹的粉丝有应用适配. 先前魅族 Smart Bar 就是个活生生的例子, 这家企业用微乎其微的市场占有率 (存疑) 逼迫很多应用不得不为其适配 Smart Bar. 魅族用户齐心协力尚能做到到这样, 小米依靠其更多 (也更会吼) 的用户能做到些什么, 还是有些值得期待的.
&nbsp;
另外还有一个值得担心的地方就是, 如果有大量未经重新设计就&#8221;搬运&#8221;到 Android 平板上的 iOS 应用, 又会对国内的 Android 平板生态带来什么影响? 答案无非就是让一些国产应用在平板上回到三年前手机应用的起点罢了 —— 至少有是有了. 只不过这一次和三年前的手机恐怕会有点不一样. 如果小米平板真的普及了, 而且能一统国内 Android 平板界, 那么恐怕到那时再试图推行 Android Design 的难度就不是一般大了. 更重要的是, 如果这一天真的到来了, 甚至没有说服开发者在平板上不采用 iOS 设计的理由.
另外, 还有一种可能就是, 很多应用不是将应用本身进行平板适配, 而是完全照搬 iOS 的方式出一个平板专用应用 (就像在 Android 2.3 时代一样). 这对任何人都是没有好处的, 但是很难说服开发者不这么做 (在小米平板统一国内 Android 平板界的前提下). 而如果要直接做 Responsive Design, 也不太可能做到手机模式和平板模式两套 UI 风格. 如果开发方倾向于直接把手机应用做 Responsive, 那么对大家来说都是大好事, 如果不是, 那对小米来说是好事, 对其他人迟早会造成问题的.
最后说句题外话, 如果有开发者愿意为 Android 平板 (而不是只为小米平板) 适配自己的应用, 请参看: Building a Dynamic UI with Fragments, Multi-pane Layouts, Android Design in Action —— 编与集.
</content>
</doc><doc>
    <docid>147</docid>
    <url>http://www.phonekr.com/adia-luoo-redesign/</url>
    <title>Android Design in Action —— 以落网为例</title>
    <content>
&nbsp;
落网是一个搜集介绍国内独立音乐的网站. 它的每一首歌都由人工推荐, 每一个主题都由落和他的伙伴们随心境打造 (一句话简介 by 刘文慧). 更多关于落网的资料, 请参看爱范儿对落网的报导 《不小心，落网》. 落网在一周前上线了 Android 客户端, 可以看出他们有意想要朝 Android Design 考虑, 但是不知出于什么原因 (推测是为了支持 Android 2.3), 整个应用非常的别扭, 控件的使用也很诡异. 这个应用的设计有着诸多可改进之处. 这次我就以落网 Android 版本作为例子, 讲解一下应该如何改进一款”原本就有意向遵循 Android Design”的应用, 同时希望这个范例能给大家带来一些参考.
这一次的主题是&#8221;保守&#8221;, 也就是说, 我不会在这次重设计中用上太多花哨新奇的效果, 都是中规中矩的改进.
1. 最新期刊 (首屏)
 
落网的首屏采用了大号卡片流的呈现形式, 美观大方, 冲击力很强大, 我很喜欢这个设计. 就呈现形式而言, 我觉得并无不妥, 便没做更改.
将 Action Bar 颜色稍微加深, 改为落网网页版的背景色 #dddddd
采用标准的 Drawer Hamburger
将原 Logo 的圆形底座去除, 拿出天鹅作为 Logo
放大正在播放信息的专辑图片, 加入曲名, 艺人名以及播放状态指示
采用标准 Android 卡片
分离期刊号与期刊名, 期刊名改为落网品牌色 #990000
将评论与收藏数纵向放置, 颜色改为落网品牌色
加入 Contextual Overflow, 内含直接播放选项
采用 Translucent Navigation Bar
2. 导航 (Drawer)
 
落网原先采用了撤去式 Drawer, 但是偌大的空间里只放了个人, 音乐, 收藏和设置四个项目, 显得空荡. 我保留了原先 Drawer 中项目的顺序, 留出了以后将会加入的播放器的入口.
采用 Google 官方 Drawer, 并让 Action Bar 上标题位置显示落网的名字
把帮助和反馈拉到 Drawer 中
将 Slogan 改为了落网品牌色
微调个人资料显示风格 (Play Store 风格)
给 Drawer 背景加入三段分隔颜色
3. 期刊分类
 
原先的期刊分类给我一种索然无味的感觉, 如果仅仅是现实分类的名称文字的话完全没必要用 Grid List 啊&#8230; 于是我就做了一点大胆的尝试.
采用标准 Android 卡片
将每个分类加入对应的描述图片
(分类的图上有好多彩蛋&#8230;)
4. 专题详情
 
详情页做得稍微大胆了一些, 主要是因为我觉得这个页面的布局太适合 Translucent 和 Multiplexed Action Bar 了.
将标题和期刊号放进 Action Bar 的标题处, 顶替原先并不重要的曲数信息
采用 Multiplexed Action Bar 和 Translucent Status Bar (卷动之后 Overflow 和播放按钮进入 Tabs 层)
加入标签信息
将播放按钮改成落网品牌色底座 + 白色图形
将评论, 收藏和分享放入 Action Overflow 以节省纵向空间
曲目列表专辑封面放大, 字号放大
5. 播放器
 
其实我挺搞不懂的, 为什么其他界面都是亮色调, 唯独播放浮窗是暗色调呢? 所以我就把它改成了亮色调&#8230;
采用亮色调
曲名改为品牌色, 滚动显示
更多按钮改用 Overflow 样式
播放控制按钮改用 Android 标准样式, 并覆盖专辑封面颜色 (这个似乎很流行的样子)
播放进度控制采用标准 Android 进度条 + 把手
浮窗整体下移
其实我还做了另一个版本的播放器:

试着采用右侧 Drawer 作为播放器, 因为比起右上角播放状态按钮, Drawer 可以从右侧边缘直接唤出, 对大屏操作更为友好, 纵向空间充足而可以直接展开所有操作. 改动太明显了我就不说了 (其实只是偷懒而已). 有个需要强调的地方就是, 在制作 Drawer 里需要拖动的控件时, 请务必屏蔽 Drawer 的滑动关闭手势.
6. 评论
 
标题栏加入期刊标题
写评论按钮移至底部, 以 Quick Return 样式呈现
加大字号, 加大行距, 规范边距
加强对比度
将用户名改为品牌色
将时间与赞统一放置于用户名右侧
7. 设置

我不太明白为什么在设置里会突然出现一个 iOS 6 风格的开关&#8230;
移除重复的个人信息入口
将开关改为选框
采用标准 Android 列表分类
评分已经在 Drawer 里了, 所以这里就不需要了
总结
重设计到这里就差不多结束了. 播放器界面由于原应用里未完成, 我就没做. 自从完成了 Nexus 4 Mock Up 工具之后, 做这样的重设计就变得轻松愉悦&#8230; 果然是工欲善其事必先利其器嘛. 落网方面的人态度也很友好, 不知道什么时候能看到他们改进的成果~
另外, 这次我没做图标重设计.
例行的对比图:

主界面

Drawer

分类

专辑详情

播放器浮窗

播放器 Drawer

评论页


设置页
&nbsp;
最后感谢刘文慧将落网推荐给我~
</content>
</doc><doc>
    <docid>148</docid>
    <url>http://www.phonekr.com/google-camera/</url>
    <title>Google Camera 初体验</title>
    <content>就在不久之前, Android 4.4 上的自带相机更新为了 Google Camera. 这个更新是个从图标到体验的从内而外的大更新.
首先新的 Google Camera 肯定不能叫做原生相机了, 我打赌它不会被包含在 AOSP 里, 应该变成了像 Google Keyboard, Google Calendar 这样的东西.
新的相机图标和之前 Android Police 泄漏的图标相距甚远, 而 Google 没有理由在短时间内多次替换一个应用的图标. 不过新图标比起旧图标确实略显扁平.
拍照体验这部分比较个人. 我觉得新 Google Camera 比老相机 体验要差. 我非常喜欢老相机的扇形菜单, 结果 Google Camera 里去除了, 直接打回最普通的点按式菜单, 我很不高兴. 左侧隐藏的模式切换菜单对于某些智商不够的用户而言恐怕是一辈子都不会发现该怎么调出的.

不过实话说来我很喜欢这个模式切换菜单, 这比老相机的模式切换要好看一些, 不过老相机更直观. 我也很喜欢选定一个模式之后的切换动画 (圆形扩散, 背景模糊). 一些原本只要滑动两次就能进入的设置被挪到了专门的设置菜单里. 而且设置菜单居然是 Holo Light 的&#8230; 有点诡异啊.
曝光补偿居然变成了默认隐藏, 需要到设置里开启手动调整之后才会出现. 拍照界面下屏幕底部一整块灰色区域都是快门按钮 (不过我也很好奇为什么 Google 不在拍照界面进入 Immersive Mode). 至于 Photo Sphere, 和 Panorama, 和老版本基本上可以说是大同小异.
和 4.4 原生相机一样, Google Camera 自带图库功能, 从拍照界面左划进入. 图库的操作和之前几乎没有区别, 上下滑动依然可以删除照片.

在 (且仅在) 这里可以调整之前拍的后期模糊照片. Google Camera 提供了焦点选择和模糊力度调整. 效果还不错.
这是我刚刚拍的后期模糊照片:
这是最大模糊力度的. 效果很梦幻, 我很喜欢 (但其实很不准确).
这是默认模糊力度的. 可以发现花瓶边缘有一点后期处理的痕迹. 不过我觉得已经比 HTC M8 的后期处理效果好多了.
另外, 后期模糊的照片可以进行再调整, 应该是保存了类似 RAW 的原始数据文件 (在 DCIM 文件夹中只有处理完成的图片).
耗电十分感人. 我仅仅用它拍了三张照片 + 两次后期模糊调整, 就变成这副模样了. 而且手机的温度和玩了半小时极品飞车有得一拼, 不知道是不是我的个别情况 (但是我这可是 Android 4.4 原生 Nexus 4 啊&#8230;).
看看好像也没什么好多说的了. 总之我挺喜欢 Google Camera 的新功能, 但是对去掉了原先的扇形菜单表示不满.
下载地址: Google Camera
</content>
</doc><doc>
    <docid>149</docid>
    <url>http://www.phonekr.com/android-popup-and-dialog-ui/</url>
    <title>Android 弹出窗口与对话框 UI 设计</title>
    <content>本文译自 Tim Green 在 Medium 上的博客里发的文章 Android Popup &amp; Dialog UI. 英文能力过关的同学可以跳过我的渣翻译直接看原文了.
当 Dropbox 发布了他们的 Mailbox for Android 的时候我看到了一些截图, 由此我想起了一些我从一月起就在收集的一些截图. 在 KitKat 和其他第三方应用中, UI 设计已经有了长足的进步, 其中的一点就是弹出窗口对话框 UI 的改进.
 
左图: Android 自带的日期选择弹窗; 右图: Android 自带的时间选择弹窗.

左图: Android 日历中的重复选择; 右图: Chrome 中的打印.
干净简洁的布局与有趣儿又引人注目的交互让操作变得轻松而愉快, 尤其是那在时间选择器中出现的双环.
同样的, 也有很多人试图在自己的应用中给他们的弹窗添加朴素而符合自己品牌形象的特征.

从左至右: Mailbox 的延迟对话框; Dropbox 的路径选择窗; Runtastic 的删除记录的绘画框; Sol Calendar 的定时框.

从左至右: Southern Rail 购买确认窗口, Airbnb 日期选择窗口, CloudMagic 欢迎对话框, Noom 总结窗.
就算是在这些临时窗口中, 也有一些很简单但是优美的设计能够让用户不因为看到了一个 Holo Theme 的对话框而觉得&#8221;我怎么一下子来到了另一个应用中?&#8221; 在我看来, Sol Calendar 和 Noom 是所有应用里做得很好的两个应用.
我还注意到一种趋势就是让弹窗从屏幕底部浮现, 并且占满整个屏幕的宽度. 虽然这比起前面那些标准的对话框来说并不是什么很大的改变但是却让这些对话框看起来显得时髦而利落.

我相信随着 Android 版本的迭代, 我们会看到越来越多的应用采用这种从屏幕底部滑入的对话框.
</content>
</doc><doc>
    <docid>150</docid>
    <url>http://www.phonekr.com/mi-troika/</url>
    <title>小米移动的三驾马车</title>
    <content>
在两年以前, 我也曾经是一个&#8221;发烧友&#8221; —— 一个最疯狂时一天刷四五次机, 两天不刷机心里就不会舒服的人. 我也曾经是 MIUI 的老用户, 只是在 Android 进入了 4.0 时代之后我就不再刷 MIUI 了. 至于原因, 后文会提到. 
但即使疯狂如我, 在 Android 已经发展到 4.4, 各厂旗舰纷纷踏上四核大道的今天, 也已经突破了连续三个月使用原生系统 (Nexus 4, Android 4.4, Rooted + ART) 不刷机的记录. 就在我已经&#8221;原生大法好, 退刷保平安&#8221;的这个时候, 小米推出了他们号称&#8221;不用刷机的 MIUI&#8221;的小米系统. 既然可以不刷机 (言下之意: 可以不用中断我的不刷机记录了, 耶!), 而且我又已经很久不用 MIUI 了, 对他们现在是什么样有点儿好奇心, 于是我便下了一个&#8230; 
当然, 今天我并不打算在这里讨论小米系统本身 (关于我对小米系统的看法可以移步我的微博, 到时候估计会专门写一篇来黑), 而是来浅谈一下小米系统的企图. 尽管我很想说说它的战略地位, 但怎奈我不是小米的人我也说不清楚. 文章里的事件大多凭印象, 如有错漏及不妥请不吝指出. 想看我黑小米的同学们可以 Ctrl + W 了&#8230;

MIUI 的困局
MIUI, 是小米公司的生存和立足之本. 在前 4.0 时代, 小米靠着 MIUI 拿下了第一批&#8221;发烧友 (或许我该说, &#8220;刷友&#8221;?)&#8221;, 建立了自己的用户基础. MIUI 能够在大部分主流机型上提供相对完整的米系体验. 由于 Rigo Design 出色的设计 (MIUI V5) 以及小米团队对本地化正确的理解, MIUI 取得了极好的口碑.
尽管 MIUI 为小米公司掘出了第一桶金, MIUI 的适配成本却居高不下. MIUI 一直走热门手机官方适配, 其他手机社区大神移植维护路线, 在 Android 4.0 之前, 由于那时的 MIUI 仍然是基于 CyanogenMod, 开发和移植难度并不会很高, 稳定程度与 bug 都可以接受. 进入 Android 4.0 时代之后, MIUI 转向原生开发路线, 导致官方适配机型维护成本激增且没有原厂 Android 4.0 的机型都不能升级至官方 MIUI V4, 而层出不穷的 Bug 也开始使很多非官方支持机型 (与很多官方支持机型) 的 MIUI 用户感到困扰. 而且在这时可以很明显的发现, 官方支持机型的增加显著放慢了, 有很多&#8221;准热门机型&#8221;都没有官方支持. 很快, 小米意识到这个问题并把 MIUI 的架构改成 PatchROM, 然后由自己或合作开发组做基于原厂固件的适配. 但是即使如此, MIUI 开发成本和实际效果之间仍然没能取得很好的平衡. 这个时候, 一些原 MIUI 用户选择了离去.
彼时 MIUI 的刷机动力 —— 优化, &#8220;发烧&#8221;与美化, 在 Android 4.X 时代逐渐显得疲乏. 在 Android 4.X 时代以前, Android 手机体验较差, UI 也嫌丑陋. 在这样的条件下, 用户选择刷如 MIUI 一方面是看中了 MIUI 具有很强的本土化优势, 另一方面基于 CyanogenMod 往往能带来比原厂 ROM 更加流畅的体验, 而 MIUI 的特色主题功能又能一改 Android 2.X 的丑陋面貌. 但是从 4.0 开始, Android Design 规范出现, Android 有了一套自己的成体系的整体设计风格, 并且系统 UI 与 Android Design 配合完美, 因此部分用户抛弃了 MIUI 投入了 AOSP 和 CM 等风格接近原生的 ROM 的怀抱中. 在 Android 4.1 之后, Project Butter 的加入又极大改善了 Android 长久以来被人诟病的卡顿迟缓, 当其中一些为了性能而刷上 MIUI 的用户发现原生 Android 4.1 比 MIUI V4 (Android 4.0) 流畅时, 这批用户也选择了离开 MIUI.
很显然, 曾经风光一时的 MIUI 在今天已经显出了疲态.
小米手机的陪衬
当越来越多的用户选择离开 MIUI 的时候, 小米公司自然不能坐视不理. 在用户､ 口碑基础尚存, 而在适配上却呈现疲态的形势下, 为了保障 MIUI 所承载的服务盈利模式, 小米以硬件来扩大利润､ 增强用户粘性并且进一步变革中国 Android 软硬件生态的扩张势在必行. 而他们的杀手锏就是小米手机. 1999 的超低价格, 顶级配置, &#8220;为发烧而生&#8221;&#8230; 各种宣传, 一方面吸引 MIUI 老用户购入小米手机, 另一方面也开拓了新市场 —— 很多大学生觊觎小米手机的超高性价比, 成为了小米的用户.
但是, 尽管小米手机提供了最完整的小米系体验, 对于普通用户而言, 获取小米手机的成本反而是三者中最高的. 即使在今天, 购买红米手机依然很难一次成功, 身边很多同学朋友都因为无法直接在官网上抢到而选择在淘宝等渠道加价购买. 在这里不讨论小米手机是否玩期货和饥饿营销, 但这显然是砸了小米手机&#8221;高性价比&#8221;的招牌. 而在这个时间点上, 小米也转移了宣传重点, 开始不断宣传小米手机的配置高, 跑分高, 性价比高, 减少了提到 MIUI 中人性化本地化改进的次数 —— 实际上在我印象中, 自从小米手机出现之后, 我就再没看到小米官方那么高调地做 MIUI 人性化功能的宣传了.
而实际上, 在 MIUI V5 时代, 小米手机的配置与使用体验并不比刷了官方支持的 MIUI 的其他厂商高端机型要好. 这点可以体现在相机/屏幕/其他各种硬件素质等很多地方 —— 毕竟 1999 就是 1999, 没办法和那些动辄 3000､ 4000 的高端机比. 而实际上, 小米手机似乎也从来没打算做高端, 从小米手机 1 开始就是打性价比牌, 走&#8221;屌丝&#8221;路线.
在这台三驾马车中, 小米手机从来都只是从马 (Side Horses), 没有成为主力过.
小米系统的渗透
雷军曾经说过, 小米的铁人三项是软件, 硬件与互联网服务, 而这三项里最有价值 (增长潜力, 用户黏性) 的其实还是互联网服务 —— 说白了, 就是内容. 不管是 MIUI 还是小米手机, 最高目的都是将用户导向小米的互联网服务 (硬件 + 软件 + 服务比软件 + 服务赚钱). 
而小米系统就是那个能够以最低的成本普及小米的互联网服务的选择. 
还有一个不能忽视的地方: 在互联网服务能够直接带来收益的付费项目 —— 主题, 应用, 音乐, 书: 这些服务都有着由其它传统同类网站已经培养多时, 有消费习惯的用户, 尤其是电子书和主题. 而这些用户有消费在线内容的需求､ 习惯和经历 —— 中, 他们的用户往往都是高端用户 —— 只有高端用户才能更好的意识到内容的价值, 并愿意为内容付费. 通常情况下, 我们很难在低端用户的低端手机上看到付费内容. 而如前文铺垫, 可以发现, MIUI 的中高端用户其实是在不断流失的. 现今三星等国际大厂及其他国产厂商的 ROM/UI 逐渐进步, 有的厂商甚至搞出了不输于 MIUI 的体验和优化, 而手机硬件的不断发展和 Android 4.1+ 的普及也使得新款中高端手机能够轻松推动这些 ROM/UI, 因为优化带来的刷机动力逐渐消失, 即 MIUI 的最有力传播途径 (刷机动力) 已经消失; 而小米手机又主打中低端, 对高端用户构不成吸引力. 那么小米应该依靠什么来重新打入中高端用户这么一片市场? 
重点依然是 MIUI. 如果能让 MIUI 更方便的渗透到中高端用户中, 小米互联网服务的用户就会随之增多. 在此之前, 小米曾经有一次不甚成功的尝试, 那就是小米桌面 + 百变锁屏 (卖主题). 这次尝试的中心思想其实就是分离核心应用以便推广, 实质为简化版的 MIUI. 而这个思路, 是正确的思路. 
观察小米系统的安装包, 你会发现他的文件名是 &#8220;MiuiLite&#8220;, 而安装之后显示的英文名则是&#8221;MIUI Express&#8220;. 这两个名字很好的概括了小米系统的性质, 那就是精简版的 MIUI, 一个即装即用的 MIUI. 这个 MIUI 比 ROM 本体小很多, 在一个应用里直接集成了大部分系统核心应用. 而小米系统作为一个 Android 应用, 适配不同机型的成本要远远低于 MIUI ROM. 以应用的形式出现的另一个好处就是那些刷机困难/无法刷机的行货手机也瞬间从 NPC 变成了可攻略对象, 瞬间又扩展了一批可能用户. 而官网上得知, 首批推荐机型为 HTC One, Samsung Galaxy Note III, Sony Xperia Z Ultra, 都是高端大屏手机, 而小米系统虽然相对固件而言体积较小, 但是这毕竟是在系统之上运行的一整套软件, 对内存和处理器的要求都很高, 而且有大量服务常驻后台. 能符合流畅运行小米系统条件的设备以及上文提到的国行/中国运营商定制手机的用户, 消费能力不会低. 可以看出小米从&#8221;发烧友&#8221;向真正准高端用户进攻的尝试. 由此, 小米系统的高端路线可见一斑.
这一次, 小米重新祭出了改善体验的大招. 在早先的造势宣传中, 不断强调系统应用体验的重要性, 主打宣传对桌面 (主题), 拨号/联系人, 短信和云服务这些一部手机基础功能的改善. 这一瞬间, 小米似乎又回到了 MIUI 刚刚起步时的原点 —— 重视本土化､ 人性化的操作, 优秀的设计 (是不是优秀这个可以再议), 重新把目标瞄向了对内容有消费能力与意愿的中高端用户, 和 (也许和前面重合度很高的) 不愿意/懒得/不会刷机的普通用户, 更好的传播 MIUI 与小米服务. 而 MIUI 和小米系统的用户都是小米生态系统 (商店应用/主题, 音乐, 视频内容, 书等小米系内容) 内的一员.
&nbsp;
接过了来自由于受竞争者和用户需求减弱冲击而动力疲软的 MIUI 的接力棒, 小米系统正式成为小米移动三驾马车的主马. 尽管小米手机被国内传统厂商借鉴模式并在渠道和宣传上打压而且一时无法摆脱低端印象, 但是小米系统在准高端用户领域做出了积极的尝试. 由此, 小米通过小米系统, MIUI 和小米手机这台三驾马车, 进一步扩展了自身互联网服务的受众群体, 高低搭配远近结合, 完成了小米移动的中盘布局, 堪称完美的妙着. 
</content>
</doc><doc>
    <docid>151</docid>
    <url>http://www.phonekr.com/a-new-journey/</url>
    <title>A New Journey</title>
    <content>
大家好。
真对不起用了这么俗套的开场，但是想必我们手中正敲击的键盘也不会是您走在前头的时候落下的，就这么着吧。
但是我们想做真正被你们需要的事。
有几位前辈都这么说过：“大家都能做新闻，要你们干嘛？”。有道理，大家获取新闻的途径太多了，永远没有一个地方可以保证自己的消息最及时。
但是做新闻并不是件容易的事。正因为不容易，我们希望替屏幕那头的您，找来每个领域我们认为最专业、认知最透彻的人。我们希望，大家可以不再需要每天带着焦虑症刷新各类科技微博、网站去追踪每一分每一秒可能发生的事，更不希望在充斥小道和捏造的环境里每个人都满腹猜疑，从而自己劳神去挖掘信息的源头、去关注更多的消息来源、去面对更多的未知和烦躁。
所以啊，我们会以自己为担保，挑选每天最有价值、最可信的新闻，在您上班路上以及睡前整理出来。就像喝牛奶或者刷牙一样，轻松而平常。
这么一群有热情的人每天只干两次活儿是闲不下来的。我们会在剩余的时间里，尝试用最客观的态度、最冷静的文法、最精炼的文字，去解读近期的热门话题或者传言，去剖析每一个争论背后我们认为的答案。
顺带一提，我们叫 TingTalk。
这是我曾经想要开的咖啡厅的名字。Ting 可以是“听”的拼音，也是拟声。清脆、干净，不拖沓。就像我曾经很喜欢一段咖啡厅环境音里的那声服务铃，让人觉得一切都井井有条，一切都在运转当中，一切都如往常那样让人心安。优雅、宁静。
台北有个地方叫“温罗汀”，它“有着华人世界少见密度最高的书店群，以及重要文人故居，加上附近台湾大学青年学子所带进的小众风潮——这一区域不只有书香、咖啡香，还有独立自有的人文精神。”。
这是“汀”的取材，而“说”，则是单纯的，对每一个人而言最友好的传递方式。
很感谢你看到这里，也很高兴认识你。
文: TingTalk
</content>
</doc><doc>
    <docid>152</docid>
    <url>http://www.phonekr.com/tensei-21/</url>
    <title>异闻录 21：高难度暴力杀人事件</title>
    <content>
2.7%
自周二发布盈利指引以来，三星的股价已经累计下跌超过了2.7%

74%
调查显示，实体店购物依然是全美74%的少女和53%的少年所首选的购物方式，一年前，该比重分别为82%和80%

400
比特币比价跌至400美元以下，自去年达到最高峰之后已经持续下跌超过3个月
100000
Foobar 在 Kickstarter 推出移动计划，筹款额达到10万、20万及30万美元时即推出 iOS、Android 和 Windows Phone版
437000
联合国公布的数据显示，2012年全球共有近44万人被杀

Mac OS 唯美向信息提示

「进击的巨人」入侵现实

very confident
正在中国进行访问的澳大利亚总理阿博特表示「非常确信」最近捕获的信号来自于 MH 370航班的黑匣子

我们正在解决服务器的迁移问题以保证服务器关闭之后大家还能玩这些游戏。（We&#8217;re working on transitioning those games after the shut down so you&#8217;ll still be able to play them.）
EA 表示，即使 GameSpy 关停多人游戏服务，依然会继续保证对 Battlefield 2等三个游戏的多人在线支持

（微软）需要把公司里的官僚主义机制一扫而光，把注意力集中下一波科技浪潮上。（Need for big clean out of bureaucracy and focus on next big tech wave.）
默多克表示「大数据」（metadata）可能就是未来科技发展的趋势

1，老板，你起开
法国议会今日通过法案允许雇工在下班以后拒收上司邮件
伟大、光荣、正确的法兰西万岁！
城防局职员凡尔纳用尽全身力气在众人的环伺下在白板上写下这句话，然后被警察带走了。
——不回邮件有错吗？
——没错，但是你不应该在德国人都到凯旋门了还无视紧急通知呀。

2，亚洲人民一张脸
西班牙电视节目盗用泰国 COS 场景并将其当作日本介绍
东京作为世界上最繁华的城市……诶，别看人家的路烂楼也破，这恰好证明了日本人民对文化传承的重视。
……
……诶？观众朋友们，大家看到了吗？瞧见日本人民与自然的相处是多么和谐，大象都可以旁若无人地在路上走来走去。
……
下面让我们采访这个漂亮的日本小姑娘吧……诶，小，小哥，这是一位小哥……
主持人的脸色憋得通红，擦了擦手上渗出的汗，继续说下去：
大家瞧，这位小哥说他花了好几十万泰铢做手术……诶，泰铢？！

3，一亿大劫案
黑客盗取韩国20万信用卡信息，并成功盗刷超过1.2亿韩元
1.2亿韩元折合约11.54万美元。
李总，我看你的这块表不一般呐。
诶，也就20万美元，不贵，不过是海南那边的小老弟送的，很有意义呀。
李夫人和来宾谈笑风生，就电力和地产问题进行了深入友好的交流。

4，平民的呐喊
由于邀请美前国务卿赖斯加入董事会，Dropbox 遭遇部分网民抵制

她小時候打过我大叔他小姨的三叔的哥哥的外甥；
她以前和小周谈过恋爱；
她级别比我高，月薪一万八；
上次我没有补请假条她批了我一顿；

小明把小红的缺点列了出来，心满意足地表示果然不能找她当女朋友，然后眼巴巴地看着小红挽着小王的胳膊经过。

5，高难度暴力杀人事件
一项研究显示，游戏的难度而非暴力内容可能才是导致玩家侵略性提升的原因
我练功发自真心都过不了！去死！
9岁的小明拼命地按着手柄，大骂「忍者龙剑传」。
一切都是屁，根本玩不下去，去死！
13岁的小明将「忍者蛙」使劲地摔在地上，脸憋得通红。
你是三岁小孩吗？去死！
15岁的小明将手柄扔到地上，愤懑地指着屏幕上的「黑暗之魂」大骂。
……
虽然这么不好玩，但俺感觉好好。去死吧。
说完这句话，27岁的小明将4寸长的匕首插进了要与他分手的小四身体中，笑了。

6，少年犯
日本三名中学生通过电话诈骗获利4.8亿日元
——哇，这么多钱欸，我们去买 PS4吧。
——笨蛋索青，买 Xbox One 不好，还能看电视！
——软粉死开啦，我要玩的是1080P 画质，你玩得了吗？
——我能玩 HALO，你行吗？
——你们别吵了，每样都买还不行。
——这是信仰！
……
最终，三名中学生因为购买游戏机发生内讧先后向警方举报同伙而被一网打尽。
</content>
</doc><doc>
    <docid>153</docid>
    <url>http://www.phonekr.com/about-my-near-future/</url>
    <title>关于未来, 以及一些才不是怎么样都好呢的事情…</title>
    <content>
(Image credit: Gnosis)
初次见面的读者, 初次见面. 好久不见的读者, 好久不见. 不知道锋客网的新老读者对 NovaDNG 有什么样的了解? 也许你有关注他的微博, Google+ 或者 Twitter, 也许在知乎上看过他的回答. 也许在你的眼中他是一个 Android Design 狂信者, 也许是一个 Android Design 布道师, 也许是个自高自大的人, 也许是个偏执狂&#8230;
如果你对他稍微更了解一些的话, 你会知道他是个大学生, 曾经在美国留学, 那一年里他整天泡在图书馆里, 而自从去年六月回到中国之后行踪就飘忽不定, 不知道到底在干些什么. 锋客网的文章也总是有一搭没一搭的写着, 有时候人品爆发连续两三天每天一篇, 有时候文思枯竭一个月没一篇&#8230;
&nbsp;
不过这些都不再重要了.
五月起, NovaDNG 就会正式加入一个新团队, 其名为 Q-Supreme (中文名叫快宜信息技术)(嗯哼, 这个名字还是 NovaDNG 自己起的呢~). 觉得这个名字很陌生? 当然啦, 因为这是一个新生的团队. 所以你看, 这个名字连链接都没有. 但是不要小看了这个团队. 这个团队目前由五名成员组成, 而随便拉出两个人来, 你会发现他们都是大神. 比如 —— 心之所在和作者南岭. 而这个公司就是在快图浏览的基础之上建立起来的.
稍等一下&#8230; NovaDNG 不应该是个大学生吗? 怎么突然就去工作了? 
其实在三月中旬的时候, 南岭大叔找上了 NovaDNG, 把他的想法告诉了 NovaDNG, 并请他去上海和他们促膝详谈. NovaDNG 便欣然去了上海. 在上海, NovaDNG 和南岭大叔一番畅谈. 他发现, 南岭大叔除了非常低调之外, 三观正, 技术硬, 人品也非常好, 总之趣味相投, 惺惺相惜. 之后, 他便决定加入这个新生的公司. 
加入了公司之后呢? 嗯, 也许你们会有更多的机会在公众场合看到 NovaDNG 本人 —— 他正在计划着去厦门, 上海, 南京, 广州的 GDG 做 Android Design 宣讲. 同时, 这个计划得到了南岭大叔的支持. 另外读者们也可以放心, NovaDNG 依然会继续耕耘锋客网, 将自己在工作中的心得体会整理成文章发布在这里.
NovaDNG 自然不会中断他的学习. 工作的单位离复旦大学新闻学院/艺术学院非常近, 离同济大学不过四五站地铁, 而地铁十号线能直达上海市图书馆. Q-Supreme 是弹性工作时间, 而 NovaDNG 在复旦和同济都有朋友和同学&#8230; 所以, NovaDNG 选择在工作之余和周末在复旦蹭课, 或者就像还在美国的时候一样窝在图书馆里看书&#8230; (啊, 总感觉似乎是在给新团队做广告的样子呢&#8230;) 当然, 他也会和以前一样不断的从互联网的海洋中汲取知识. 所以你应该放心, 虽然人不在学校, 但是下班之后的 NovaDNG 依然把自己看作一个学生, 希望能够学到更多的东西. 
&nbsp;
其实说了这么多, NovaDNG 的心里话是: 就要第一次正式参加工作了, 好紧张&#8230;
在 NovaDNG 的身边, 大家都规规矩矩的上着大学, 在大学里或者读着书, 或者开着小差, 或者玩着游戏, 或者谈着恋爱&#8230; 在此之前, NovaDNG 都在专注的做着他认为正确的事情, 丝毫不在意旁人的目光. 但是这次, 在这个时间, 他突然停了下来, 环顾四周. NovaDNG 发现自己是孤独的. 身边的同龄人里只有他一个人选择了在这个时间离开学校进入工作, 只有他一个人. 而去上海工作意味着再一次离开他熟悉的城市与亲人, 来到一个新环境. 而和美国不同, 尽管上海的人们依然讲着普通话, 他却不能像在大学时那样, 把自己窝在图书馆离和网络上试图避免在现实中和人接触; 他必须面对除了同事以外的各种各样的人, 站上 GDG 和其他活动的演讲台, 拼尽全力实现自己的理想, 而不是像在大学里一样只是把理想当作天边的星星.
他其实非常害怕寂寞. 锋客这个团队就是因为他对寂寞的恐惧而组建的. 他天真地认为, 聚集起一些志同道合的同龄人, 寂寞就会离他而去. 而事实上, 尽管他曾试图尽力维护这个团队, 但这个团队到现在却免不了七零八落. 锋客对于 NovaDNG 来说是一个心灵的藏身处, 这个藏身处曾经热闹过, 但是现在, 这里依然是寂寞的. 他假装自己经习惯了这样的寂寞, 但是现在当他停下来环顾四周时, 却又依然被这种感觉击倒.
NovaDNG 只在大学里待了一年. 这带来的后果就是, 他可是相当的 &#8220;Too young, too simple, sometimes naïve.&#8221; 也许有时候, 保持着天真未尝是件坏事, 但是对于刚刚进入这个世界的他而言, 这是一个致命的缺点. 也许他心里已经意识到了这个问题, 怎奈&#8221;天真&#8221;这样的属性也不是想要摆脱便能摆脱得了的. 想到这些, 他只觉得冷汗涔涔, 倍感压力. 
而在紧张的同时, 他的内心又充满了对未来的向往.
上海是一个大舞台. 汇聚了各种各样的角色, NovaDNG 在网上认识的很多高人都在上海. 上海还有百度 ISUX, 阿里, 新蛋.. 和其他的令人向往的地方. 就像站在大观园里的刘姥姥一样, NovaDNG 的心情非常复杂. 新的环境, 新的公司, 新的朋友, 新的同事&#8230; 就像刚刚去美国的时候一样, 一切都会是新的. 而且和大学不一样, 这一次, 他只能靠自己了. 一想到终于, 他能够用自己的力量完成自己的目标, 如何让他不觉得激动兴奋?
早些时候 NovaDNG 对媒体行业充满了憧憬, 成为记者是他一直以来的梦想. 因此你也许会注意到, 锋客网上时常会发一些带着采访报道性质的文章. 但是在去年的时候, 他在求职成为媒体记者的道路上遭遇了挫败. 之后他也发现, 几个进了媒体行业的才华横溢的朋友们, 待遇都不尽如人意. 于是他便将更多的时间花在对 UI 与 UX 的研究学习上. 直到今天. 但即使在今天, 他依然对新闻抱有热忱. (也就是说, 你以后也会在锋客网看到采访报道性质的文章) 而对媒体的兴趣也造就了他的产品观. 尽管还没做过产品经理, 他的好朋友龚叔曾经评价他&#8221;会是个不错的产品经理&#8221;. 这次来到新团队, 他也会第一次尝试扮演产品经理这个角色.  希望他能在这条路上顺利的走下去吧. 毕竟, 他可同时是产品经理和 UI/UXD 呢.
&nbsp;
NovaDNG 依然将工作之余的自己看作一个学生. 进了新公司之后, 他依然怀有自己的小梦想, 但是会全力为了实现目标而奋斗. 也许他会变, 但是请相信他会朝着好的方向变化. 他依然会在锋客网写文章, 频率也许没那么高, 但是想想, 他已经在锋客网写作三年 (算上极智的话) 了, 不会那么轻易的放弃的. 而且, 南岭大叔保证, 下班之后的时间是自由的 —— 这也意味着, 他依然会做一些 Redesign 尝试, 或者帮一些小团队/个人开发者设计/修改 UI. 感谢南岭大叔.
对了, NovaDNG 葫芦里依然有点儿药没有卖完, 敬请期待~
&nbsp;
就让我在这里尽情的矫情一回吧.
</content>
</doc><doc>
    <docid>154</docid>
    <url>http://www.phonekr.com/tensei-20/</url>
    <title>异闻录 20：我们中出了个叛徒</title>
    <content>

三星的律师翻来覆去说的全都是些无关紧要、有意误导甚至不实的指控，这些无疑已经让法官苹果公司造成了先入为主的影响。（Samsung’s counsel repeatedly made irrelevant, misleading, and even untrue statements that have undoubtedly caused the jury to form impressions that are highly prejudicial to Apple.）
苹果律师专利诉讼庭上直斥三星

「权力游戏」让死亡更加精彩

继「神海」系列总监跳槽腾讯旗下工作室之后，该游戏编剧和创意总监 Amy Hennig 现在加入了 EA 的 Start Wars游戏

游戏「龙腾世纪：审判」释出超逼真级别游戏截屏图

instagram 已经成为全美最流行的移动社交工具



22
Google 宣布其互联网热气球项目中的一只已经在22天内完成了500000公里的环球航行


 
12000000
微软 Office for iPad 上架一周以来下载量超过了1200万



2046
联邦交易委员会自2008年至今累计接到消费者两千多件针对 Yelp 的投诉，受此消息影响，Yelp 股价大跌超过6%



1400000
Google 付出140万美元的代价以了结与意大利人权组织在街景隐私问题上的纠纷


 
1，吃豆人，吃人
华盛顿大学开展了一项通过「吃豆人」游戏来实现电脑之间相互学习的项目
你会「吃豆人」吗？
Mike 用生硬的声音问抓获的反抗军战士，对方僵硬地摇了摇头。
可惜，只有做活体电池的用处了。
Mike 将尖锥刺入俘虏的颈上，拼命地吸取着他身体中的化合物质。
远处，满目疮痍战火轰隆，人类无论如何也不会想到一个小小的游戏竟然让电脑的智能进化达到无视三大定律的地步，2056年，「天网」崛起了。
一切，都只是因为一个叫「吃豆人」的游戏而已。


 
2，Glass 牌 Google Glass
Google 为 Glass 申请商标遭到美国专利局驳回
——好大好壮观诶。
——能容纳十万人呢。
——噢，那我们什么时候去诺坎普？
——你不是正在参观吗？
——诶？你不是说这是「新球场」吗？你在逗我？
12岁的巴萨球迷小明不听众人的解释，当场嚎啕大哭起来，透过指缝看到周围的人全都无奈而无动于衷，于是哭得更厉害了。


 
3，对您造成的不便我们深感歉意
中国比特币交易平台 FXBTC 发出紧急通知宣布不再接受充值和提现
总而言之，必须这样，才能促进比特币的高潮。犯着急性病的同志们不切当地看大了比特币的主观力量，而看小了反比特币力量。这种估量，多半是从主观主义出发。其结果，无疑地是要走上盲动主义的道路。
说完之后，老李请群情激愤的众人到东大街吃了一顿火锅，告诫大家继续用发展的眼光看问题，要坚信道路是曲折前途是光明的。
吃完饭后，老李将公司账户上的钱全部转走，连夜举家迁移。


 
4，漫游费战争
欧洲议会通过决议将在2016年前取消欧盟国家之间的通信漫游费以保护「互联网中立」
2016年，在乌克兰宣布加入欧盟之后，入侵乌克兰的俄罗斯军队一位下士在接受 CNN 采访时表示：
解决俄乌两国人民高昂的通信漫游费用问题，是我们此次军事行动的重要目的之一。
与此同时，随菲律宾海军的各国记者终于因为无法承担中国移动高昂的漫游费而最终宣布退出仁爱礁抢滩报道活动。


 
5，爱情正确论
之前发表反同言论的 Mozilla CEO 最终不得不辞职应付外界的争议
我反对同性恋！
Jack 说完这句话后，第二天被当地人权组织纠集同性恋群体堵在家门口进行示威，于是辞职。
我支持同性恋！
Jack 说完这句话，台下的阿拉伯群众顿时激动起来，纷纷摩拳擦掌表示要揍得他满地伤。
我不支持恋爱结婚！
Jack 说完这句话，底下饱受少子化问题困扰的日本听众纷纷露出疑惑和难堪的表情。
当夜，Jack 愤慨自杀，留下遗言：
爱情是狗娘！


 
6，总统，药不能停 II
白宫方面针对三星堆奥巴马合影的商业利用做出回应
白宫反对任何将总统形象用作商业目的的行为（As a rule the White House objects to attempts to use the president&#8217;s likeness for commercial purposes.）
——白宫发言人
哎，可惜了这么多年来我一直与群众吃汉堡、打篮球、洗牙的努力，如果大家都看不到的话，这个总统当着也太无趣了！
奥巴马一腔委屈地在电话上和对方抱怨。
看开开点，安啦……你们再去告诉林飞帆他们注意别演得太过火……当初我也是被大家叫做小马哥的，可是现在人老珠黄了，就叫人家马騜，哎。
马英九通过热线安慰着奥巴马，望着凯特格兰大道上的人潮，不禁露出得意的笑来。


 
7，我们中出了个叛徒
一位苹果产品知名博主出现微软 Build 2014上的 Azure 宣传推广视频中
Windows 7对 Windows 8说：
你这个叛徒，竟然背弃 Start 按钮！
iPhone 4S 对 iPhone 5说：
你这个叛徒，竟然背弃最完美的3.5寸屏幕尺寸！
iPhone 5s 对 iPhone 5c 说：
你这个叛徒，竟然用了塑料！
……
前诺基亚 CEO 现微软副总裁埃洛普看着台上意气风发的印度 CEO，不由暗地冷笑，掏出电话拨通：
诺基亚已死，微软亦不久矣，老库，一切尽入吾等彀中，天下英雄唯你我耳。

</content>
</doc><doc>
    <docid>155</docid>
    <url>http://www.phonekr.com/tensei-19/</url>
    <title>异闻录 19：总统，药不能停</title>
    <content>

Mayor DeBlasio
白宫新闻发言人将纽约市长 Bill de Blasio 拼错，引起外界讽刺

如果这个国家还有相信法律和人权的人在，那么运营商就必须执行法院的命令，取消对 Twitter 的封杀。（If there is anyone who believes there is rule of law and human rights in this country, TIB must execute the court verdict and lift the ban on Twitter.）
土耳其宪法法院宣布总理之前下达的 Twitter 封杀违宪


Twitter 将推出表情输入


微软将在 Windows Phone 8.1 中推出语音助手 Cortana



Yahoo 公共汽车被愤怒的群众堵在了汽车站



20
「最终幻想 VI」(Final Fantasy VI) 诞生至今已经整整 20 周年


1.12 亿
Kickstarter 在今年第一季度从约880000资助者手中筹得 1.12 亿美元，使得近 4500 个项目成功投产


 
1，爱国病
作为对俄罗斯在乌克兰问题山上的回应，NASA 从今天起开始停止与俄罗斯方面的联系
一个瘦长的农民问一个中尉：“你们连里有多少个日本鬼被打死了？”中尉回答：“在我排里一起作战的日裔士兵除了两个，全部牺牲了。”这个农民回答：“真他妈的可惜，没把那两个也打死。”
——「光荣与梦想」
夜深人静时分，奥巴马悄悄给马英九打去电话：
我已经把我国的爱国情绪都煽动起来了，你那面怎么样？
马英九轻快回道：
一切都在我计划中。


 
2，Let’s Start, AGAIN
「开始」按钮将在 Windows 8.1 的新版本中回归
——客官，你要啥你说，只要是你想要的我们都给！
——滚！
……
——客官，我给你说，你这个姿势不对哟，我给你介绍一种更赞的体位吧。
——滚！
库克和鲍尔默相遇，望着前任的足迹，相互苦笑一声，匆匆离去。


 
3，绿色爱情故事
「绿色和平」对 Amazon 数据中心在资源的使用进行了严厉的批评
宁要青山绿水，不要金山银山，Amazon 滚出去！
环保主义情侣小明和小红在反 Amazon 集会上相识并建立起深厚的革命友谊，三个月在 Amazon 迁走的当天举行了小小的婚礼。
……
物价天天涨，你一天不落家光搞去静坐，这日子还有法过？！
小红在民政局和小明办离婚手续的当天终于爆发，同日，在广大群众的强烈请求下，Amazon 最终重新迁回。


 
4，十年
Yahoo 宣称将加密服务信息以保障用户隐私安全
怀抱既然不能逗留
何不在离开的时候
一边享受，一边泪流
看到这条新闻，师涛和王小宁不由泫然欲泣。
他们花了整整一分钟进入装着 Windows XP 的电脑，打开360浏览器，用百度搜出 QQ 邮箱，给对方写了一份鼓励信，表示绝对不能在信息安全方面再出现隐患。


 
5，Windows 也是有自尊的
微软宣布9寸以下设备上的 Windows 8 及 Windows Phone 8.1 将实现免费授权
——我有 Office，办公利器一出，谁与争锋，啊哈哈哈！！！
iPad 不说话，自顾自地继续玩游戏，Android 友好地拿出漫画砸到 Windows 身上。
……
我可以玩「炉石传说」，你们行吗？
iPad 不说话，自顾自地玩 Threes，Android 友好地拿出 PSP 模拟器扔在 Windows 脸上。
……
我，我现在是免费的！
iPad 愣了一下，笑着走开了。
Android 继续友好地把 Windows 按在地上揍了一顿：
让你丫收我专利费，让你丫收我专利费。


 
6，总统，药不能停
奥巴马在不知情的情况下被三星利用成为其市场营销活动的一部分
嗯，这张还不错，下次应该注意笑的的时候嘴角弯曲最好保持在30°。
总统看到三星的 Twitter， 得意地抚摸着自己的下巴。
三分钟后，他接到了幕僚长的电话。
啥？我这算是被人利用了……三星也不会给我赞助……一点都没有？
奥巴马恍然大悟，不禁怒上心头，抓起电话拨通了号：
老马，还记得你以前说的那个药吗？吃了，腰不酸腿不疼脑筋也变清楚的那个，还有没有？


 
7，细仔互联网，愿做大哥否
日本最大的黑社会组织六代目山口组推出网站招募会员，以扭转成员不断减少的趋势
——芹泽，要毕业了呢。
——嗯。
——可我们之间还是没有分出胜负呢。
——噢。
——我还想和你再比一次，用最公平的方式。
——你们这些人真是麻烦，那就开始吧，
于是，芹泽和源治拿出 Windows 平板，开始比谁改装的舰娘更炸裂。


 
8，古巴危机
美国政府秘密策划一项类 Twitter 服务以发展反卡斯特罗力量试图颠覆古巴
在 ZunZuneo 计划曝光曝光后 13 天，古巴政府在联合国大会上表达了对美国的强烈谴责，美国当局表示不予置评。
2014 年 5 月，古巴在加勒比海地区海域试射中程导弹，引起美国政府强烈反弹，宣布将对古巴进行封锁和制裁。
6 月，奥巴马表示希望和卡斯特罗坐上谈判桌，用和平的方式解决两国之间的纠纷和争执，但古巴方面拒绝表态，同时与俄罗斯方面进行了秘密接触。
6 月 22 日，奥巴马在达拉斯举行和平演讲活动时遇刺身亡，凶手奥斯瓦尔德被当场逮捕，克里当日就任新总统，并宣布全国进入战争状态。
8 月，FBI 发布证据显示，奥斯瓦尔德与古巴政权私下有过接触。
8 月 14 日，奥斯瓦尔德在庭上被法警击毙，随后法警当场自杀身亡，随后，存放证据的档案室遭遇火灾。当日，普金呼吁美古两国保持克制，号召召开三国会谈。
8 月 15 日，克里发动对古巴报复式空袭，作为回应，俄罗斯驻军进入乌克兰，欧盟召开紧急会以，宣布对俄制裁，中国呼吁各国保持冷静。
8 月 16 日，美古战争正式爆发，美军在猪猡湾遭遇惨败，美军中央司令部情报显示，有不明国籍核潜艇游弋于西海岸。
9 月，美军占领古巴，俄罗斯攻陷乌克兰全境，两国在北京举行了亲切友好的会面，宣布和中国共同构建三国同盟维持世界和平，同年，欧盟彻底解体。

</content>
</doc><doc>
    <docid>156</docid>
    <url>http://www.phonekr.com/tensei-18/</url>
    <title>异闻录 18：猴族危机</title>
    <content>
NovaDNG: 异闻录是一个全新的栏目, 每天晚上的大概这个时间, 胡桑会为我们带来轻松愉♂悦的当天科技新闻汇总. 至于你问我为什么突然新增加了这么个栏目&#8230; 啊哈哈, 佐佑理不知道呢~



它们会毁了那些孩子的灵魂，把他们引到黑暗面里去。 (They can destroy their souls and lead them to the dark side.) 
——波兰一位神父严厉批评了乐高玩具


它不可能从一家到另一家间传播得那么快，让那么多人在黑死病期间死掉。 (It cannot spread fast enough from one household to the next to cause the huge number of cases that we saw during the Black Death epidemics.)
——英国科学家推翻了原来的鼠疫感染论，提出了空气传播疾病才是黑死病主因的新学说
我们认为，DNA 片段是大自然的产品，并不能仅因为被分离出来就将其视为专利。 (We hold that a naturally occurring DNA segment is a product of nature and not patent eligible merely because it has been isolated.)
——美国最高法院裁决 DNA 不能成为专利，但是人工复制的基因拥有知识产权


我是西斯大帝，我要参加总统选举
&nbsp;

战无不胜的朝鲜航天局 Logo 疑似借鉴了美帝 NASA 的设计
&nbsp;

Windows XP：老当益壮，宁移白首之心；穷且益坚，不坠青云之志
&nbsp;

Chrome： 无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风
&nbsp;
5.3%
Android KitKat 版本的市场占有率已经超过 5.3%，现在 4.0 及其以上版本的占有率高达 81%
94431224
亚特兰大机场成为 2013 年最繁忙的机场，北京机场以 1000 万多的吞吐差距位列第二
&nbsp;

4 亿
LINE 今日用户正式突破 4 亿，每日信息发送在 100 亿条以上
20 亿
苹果试图从与三星的专利纠纷诉讼中获得 20 亿美元的巨额赔款
&nbsp;

1，中国男人
马云表示国内某男艺人的婚外情无关紧要
他只是犯了男人都会犯的错误，现在笑话他的人也许也会犯同样的错。
马云说了这番话后，台下哄堂大笑，男嘉宾笑得前仰后合，女嘉宾乐得花枝乱颤。
晚宴结束后，马云接到来自成龙的短信：
马总你说得太棒了！今夜小聚，高尔夫球还是春卷，任君选择。
&nbsp;

2，这是谁干的！
微软网站 Windows on Devices 开天窗
前日。
——新产品就要上线了，上面的大老板很看重哟，大家可千万别捅出什么娄子出来。
——嘿嘿。 ……
今日。
Boss：
——谁干的，这是谁干的？！
——老板，愚人节快乐！
次日，临时工小明被辞退，他幽怨地表示：
作为一个文科生，刚来美国把时差记混了有什么办法。
&nbsp;

3，猴族危机
三星、东芝和 HTC 在愚人节使用了相同的彩蛋玩笑
&nbsp;

你看这是一副手套而已，其实它可以打手机！
——HTC

你看这只是一副手套而已，其实它可以用来拍 4K 视频！
——东芝

你看这就只是一副手套而已，其实它是一个 1600 万像素的相机！
——三星
你看这就只是一副手套，它也的确只是一副手套，但这是一副由原研哉老师亲自设计的手套，纯白款只要 3999 元哟！
——某国内未推出智能手机系统

4，要想过此路，留下买路钱
旧金山每年将向 Google 等公司的员工公共汽车征收费用以允许他们继续使用停车站
——你们占用了我们的公共设施！
——那我们交钱行不行？
——好！
……
——你们这样做会加剧普通人出行负担！
——那我们交钱行不行？
——好！
……
——你们……你们这样科技巨头已经破坏了我们城市的人文美！
——那我们交钱行不行？
——好！
&nbsp;

5，毕业生
纽约超过一半的科技公司从业者没有大学文凭
春风得意的大学毕业生 Jack 揣着终面通知踏进梦寐以求的公司。
——我是哈佛、康奈尔的工程学双学位学士，兄弟你呢？
——呃，我就上过一个学院（college）而已，最后还退学了。
——诶？那你还真不简单，学历不高……哎，不好意思。
——嘿嘿，没事。不过我感觉我这一关你应该是过不去了。
——?
——哦，我就是这家公司的 CEO 咯，嘿嘿。
——！
——对了，我之前上的伊顿。
Jack 面如死灰，白色衬衣的领口被汗水全部浸湿了。
&nbsp;

6，不好笑的玩笑
EA COO 因为愚人节开的玩笑而不得不向 Wii U 道歉
——这是银座的一间旺铺，不知大人是否能赏光和我们一起运作？
——嗯，这个还是可以考虑一下的嘛，但是你们卖了那么多楼怎么还留有旺铺？
——你们和他们合作，但不也是留了一手吗？
EA 和索尼相视大笑，把酒言欢。
此时，苦闷的任天堂一个人在东京湾的夜风中苦苦思索如何发掘新的游戏性。
&nbsp;

7，嘴炮无双
苹果和三星的专利诉讼纠纷继续白热化
苹果律师厉声批评：
三星现在已经彻底坠入抄袭的黑暗面了！
三星律师机智反击：
乖儿子，爹等会儿给你买糖吃。
苹果律师稍微一愣，憋红了脸说到：
你，你就只会抄袭！
三星律师轻轻拂过发梢，一阵清扬香气飘荡在法庭内：
乔布斯当年还是这样说 Android 的呢，Google 抄袭了？哼，无-稽-之-谈！
旁听的 Google 代表无辜地望着庭上的律师，无可奈何地苦笑了。
</content>
</doc><doc>
    <docid>157</docid>
    <url>http://www.phonekr.com/save-my-time-save-my-life-link-bubble/</url>
    <title>Save My Time, Save My Life —— Link Bubble</title>
    <content>如果你也和我一样是一个重度 Twitter 和 Google+ 用户, 而且更经常在手机上使用这两个客户端, 你可能会遇到一个问题: 当你打开一个来自 tweet/post 的链接时, 你不得不从 Twitter/G+ 客户端跳转到 Chrome/你的默认浏览器, 等网页加载完, 看文章, 然后再跳回客户端. 有时候更讨厌的是, 由于经过了短链接处理 (Twitter/bit.ly/goo.gl), 一个原本应该在 YouTube 里打开的链接依然强迫你跳转到 Chrome, 等 Chrome 解析短链接, 然后再跳转到 YouTube&#8230; 这个过程既毫无意义又让人烦躁, 而且最重要的是, 它让你花了很多完全没必要的时间在等待上.
那么, 问题就摆在这里, 有什么解决方案么?
今天, 我可以给出一个合适的答案, 那就是 Link Bubble.
应用截图
 
打开应用就会进入 Link Bubble 的主界面. 在主界面上你会看到一个简明扼要的统计 —— Link Bubble 已经替你节省了总共多少时间/每个链接节省了多少时间. 点击下方历史按钮即可以查看所有用 Link Bubble 打开的链接, 可以重新打开, 在浏览器中打开, 复制/分享链接或者清空历史记录.
 
 而 Link Bubble 真正的强大之处就是在于它能够省却大量的等待时间. 比如我在 Google+ 中点击了来自 Designmodo 的一个链接, 这时, Link Bubble 自动接管了链接 (需要在第一次使用时设置 Link Bubble 为地址的默认打开方式), 在屏幕边缘出现一个小提示环, 开始载入链接. 这是你可以继续浏览你的时间线而不必去在意那个链接的载入进度. 等到链接载入完毕之后, Link Bubble 便会自动以迷你浏览器的形式弹出, 让你查看链接的内容. 当你浏览完链接中的内容之后, 你可以直接从分享按钮中把这个链接分享给其他应用, 或者简单的按下 Back 键回到原先的应用中继续浏览时间线.
 
Link Bubble 还提供了方便的快速处理链接的功能. 你可以为它设置两个快速操作 (我选择的是添加到 Pocket 和通过 PushBullet 推送). 如果你觉得这篇文章适合稍后阅读, 你可以直接按住这个小圆球, 往左上角 Pocket 图标拖动, 然后, 这篇文章就会直接进入 Pocket 的阅读列表. 同理你也可以把 Twidere 设置在右上角, 这样你就可以快速的分享一篇文章到推上. Link Bubble 还支持同时加载多个页面, 你可以不必担心原先预载的页面被后来的页面覆盖掉.

Link Bubble 的另一强大之处就是它可以省去短链接在 Chrome 等其他浏览器中解析这一烦人的步骤. 如果你的手机上已经安装了支持原链接的应用, Link Bubble 便能替你省去解析链接 —— 跳转这一步, 在后台解析链接, 解析完了之后直接打开应用, 十分便利.
 
在设置里你可以调整何时自动弹出载入完的页面, 快速操作的应用和默认打开某些链接的应用, 也可以选择以隐身模式打开链接. 另外, Link Bubble 调用的是 Android WebView.
关于应用
Link Bubble 的构思令人拍案叫绝, 这个应用确实是可以节省大量消耗在等待载入上的时间, 让 Twitter/Google+/RSS 等浏览体验更上一层楼. 但是目前在这个版本里有个很明显的问题就是, WebView 在手机上的性能实在是有些着急, 开两个网页往往就会显得很卡. 不过 Romain Guy 已经给出了改进意见, 相信在下个版本中性能就会有所改善.
实际上在短短的试用中, 我觉得 Link Bubble 简直就是为了优化社交应用体验而生的. 以往我们在社交应用中看到链接的时候, 难免要进入链接 —— 这个时候一般是进入一个新的应用/全新的界面 (应用内置浏览器), 等待载入, 看完之后再返回时间线. 这样可以说很大程度上破坏了社交网络时间轴的线性结构 (进入新应用/新界面时对线性结构, 其中的跳转/等待时间产生了分叉). 而 Link Bubble 可以让这个分叉依附在时间轴上, 不会给用户的浏览加入跳转/等待时间, 保持了线性结构的完整性, 优化了阅读体验, 是社交网络应用非常棒的&#8221;补丁&#8221;.
另外我觉得, 如果能让 Link Bubble 自动用 Instapaper 处理链接, 会是个很不错的主意.
Chris Lacy 是何许人也?
也许你早已听过 Chris Lacy 的鼎鼎大名. 或许你并不熟悉这个名字, 但是你用过 Action Launcher —— 一款对手势的利用有着独到见解的启动器, 或者你正在用 Tweet Lanes —— 一款思路新颖, 便于发推和快速互动的 Twitter 客户端 —— 刷推. 这两个应用都是 Chris Lacy 的手笔, 在用户中好评度极高.
Chris Lacy 确实是个非常有创意的开发者, 他来自澳大利亚的布里斯班, 2010 年之前在一家游戏公司 Krome Stuidios 工作. 他于 2010 年离开 Krome Studios 并创建了一个不怎么为人所知的应用工作室 Digital Ashes, 而这个工作室在 2012 解散了. 之后, 他就靠着 Action Launcher Pro 维持生计. Link Bubble Pro 版本售价高达$4.99, Chris 也在 Google+ 上发了一篇文章说明状况:
我不是那些资产过亿的公司比如 Google Facebook, 我不会用免费的服务来换取你们的数据以便于在广告上回本, 我也不在一家获得了百万风头的公司上班.
就像你一样, 我得养家糊口, 我有家人, 要换贷款, 要吃饭, 要做各种各样现实生活中你们在做的事情. 写应用发布到 Play Store 上赚钱是我的全职工作.
我很早就决定要以这个价格发布 Link Bubble 了. 这和我给应用申请的专利没关系. 我不会把在申请专利上花的钱转嫁到用户身上.
我并不是一个在收容所面前乞讨的流浪汉. 我的目的是要做出那些让已经用着好手机的人们乐于使用甚至乐于购买的应用.
我觉得 Link Bubble 是一个 Google/Facebook 级别的大创新, 我觉得 Link Bubble 会很大程度的提升 Android 设备的使用体验, 而且提升得比我见过的任何应用都要多, 它会每天替你省下几分钟的时间. 难道这些东西连 $5 都不值得吗? (而且别忘了, 我也不会搜集你的使用习惯和数据拿去做广告/卖钱)
Link Bubble 有免费版. 等你觉得你需要高级版的功能的时候再花钱.
说句老实话吧, 我觉得 Link Bubble 的价值远远不止这么可怜的五刀, 很多桌面上的生产力工具都会漫天要价, 二十刀都是信手拈来, 我定个五刀已经是为了照顾很多人的感情了. (NovaDNG: 我想到了某神器 OmniFocus&#8230;)
我依然认为买一个好应用是一件性价比非常高的事儿.
高级版不会降价.
当你买了我的应用时, 你支持了我的工作以便我能够让现有的应用更完善, 或者开发新的应用.
作为自己应用的用户 我无比赞同并且建议你好好看看想想下面那条推里的那句话.

(我觉得是时候从说&#8221;好棒的应用, 而且它是免费的诶!&#8221;转到说&#8221;好棒的应用 —— 但是招子放亮点, 他可是免费的.&#8221;了.)
对于那些支持我并且购买了高级版的用户, 我感谢你们. 对于那些认为五刀太贵的用户, 我也希望你能在使用免费版的时候感到开心, 然后意识到我在这个应用费尽心思的价值.
对于这个应用, 我最后送上一句评价:
一寸光阴一寸金, 寸金难买寸光阴.
下载地址: Play Store (Free)|Play Store (Pro) (需要和免费版一起安装)
</content>
</doc><doc>
    <docid>158</docid>
    <url>http://www.phonekr.com/serendipitous-ideas/</url>
    <title>Muzei —— 意外之念</title>
    <content>这篇文章译自 Muzei 开发者, 我们的老朋友 Roman Nurik 在 Medium 上发布的一篇博客, 讲述了 Muzei 诞生的经历.
智能手机是非常能展现人们个性的私人物品. 所以我丝毫不为看到一大堆优秀的 Android 应用在 Play Store 的&#8221;个性化&#8221;分类下出没现而感到奇怪. 那些能够让你定制到牙齿的壁纸, 小部件, 第三方启动器和其他应用确实没有理由不流行.
让时间回到 2012 年下半年, 当我第一次在内部邮件 (嗯, 我在 Google 的 Android 部门工作) 中看到关于新的锁屏小部件这个概念时, 我第一时间就开始在自己的锁屏上玩起了时钟小部件. 除了一些基本的字体调整之外, 我还自己画了一个类比时钟. 当我意识到&#8221;这里有足够的空间可以让我放下天气图标和数字&#8221;时, 正是我叫出&#8221;啊哈~&#8221;的瞬间 —— 这个想法对我而言有着重大意义, 毕竟我并不太经常仅仅是为了看看我出门要不要带伞而特地打开 Google Now.
与此同时, 我的同 (ji) 事 (you) Adam 经常在吃饭的时候和我讨论这些玩意儿. 我们最后决定做一个&#8221;可接入&#8221;的锁屏插件, 一个我们能轻松的增删功能来满足自己需求的&#8221;仪表盘&#8221;.
于是, DashClock 就这么诞生了.
DashClock 与白色
在一两个星期的公司内部消化之后, 大家都觉得 DashClock 不仅仅适合锁屏, 放在主屏上也挺好使的. 这很简单, 只需要再添加一行代码就成了. 但是问题就这么来了: 就像其他的锁屏应用一样, DashClock 上所有的信息都是白色的. 在原生 Android 中, 锁屏背景会自动降低亮度以保证这些白色元素的可读性, 但是主屏幕是没有这样的保护的. 很多小伙伴都在用高对比度的风景图/独特的抽象画/他们最爱的家庭照做壁纸, 虽然这些图片很漂亮也很有意义, 但是他们并不能让你放在主屏幕上的东西更具有可读性. 更悲剧的是, 这种可读性不佳在 DashClock 这样的白色小部件上显得尤其严重.
于是我选择了在文字下方添加一个半透明黑色方块这样一个简单粗暴的方式来解决这个问题. 问题解决了不是吗? 呃, 我并不这么觉得&#8230; 实际上, 我并不认为这样能算是解决了, 连接近都不算.
这可是 Android 啊老兄! 人们需要更多的选项, 需要让所有的东西都尽在掌握! 就在加入了黑色方块背景之后, 一个同在 Google 工作的弟兄给我发了一封申请:
功能申请: 把前景色从白色换成 Holo 蓝色, Holo 红色等等, 或者黑色.
我接受了这个申请, 但是当我在 2012 年二月启动 DashClock 并且这个申请收到了 80 个以上的投票时, 我才加入了改变前景色为黑色这么个选项. 在缓和了最要紧的问题同时, 我也一直对这个解决方案感到不满. 这个鲠一直在我的喉咙里卡了非常久 —— 足足九个月啊我的老天 —— 而我每天下班回家的路上都会思考这个问题.
回家的路
灵感来临是一件很有趣的事儿. 它们完全有可能不请自来, 在最出人意料的时间现身. 我个人倾向于认为坐在电脑前面盯着显示器等待好主意送上门来实在是无用功. 通常情况下, 这些东西只会在你出门跑步之类的时候不期而至.
不管怎么说, 我当时正快速行走在初冬的曼哈顿, 林肯中心区那寒风凛冽的路上, 双手绝望地在我的口外套口袋深处寻找温暖的庇护所, 目光飘忽地看着前方的路面, 脑海里充斥着关于如何对付高对比度壁纸和一些相关的破事儿. 是的, 埋头走路会让你错过很多东西 —— 别急, 往下读~
我想要用更优雅的方法来解决 DashClock 前景颜色这个令人讨厌的问题; 我坚持认为问题出在壁纸上, 而不是我这儿. 那么, 我该怎么处理好壁纸呢? —— 我应该如何改善 DashClock, 甚至是其他小部件和所有桌面元素的可读性?
就在那次散步中, 我回忆起了某日我在 Medium 上看到的一幅由精挑细选出来颜色渐变组成的抽象作品 (Design/UX 收藏的背景图). 这幅图对于主屏元素可读性来说是非常理想的, 但是并不是非常私人, 而且这会花上我巨量的时间精力来为每种情绪设计合适的调色组合. 我同样也想起了 Timely, 我最爱的应用之一, 有着一个非常棒的主题设计工具, 这个工具带来了非常好用的背景. 它没有边缘, 你也可以选择比较深的颜色来保证白色元素的可读性.
 我一回到家就立刻打开 Photoshop 画样图. 这些由径向和线性元素渐变组成的壁纸在主屏幕上看起来会怎么样呢? 我很快就意识到他们虽然看起来还不错, 但是有两个问题. 首先, 就像前面说的, 设计调色组合和渐变斜率实在是太花时间了. 其次, 更重要的是, 那些用家庭照和风光照做桌面的人该怎么办? 别忘了, 手机是非常私人的设备. 一堆颜色甩在主屏幕上并不是什么有趣的墙纸. 这很不魔法. 于是我放弃了.
&nbsp;
回家的路, 终极版
第二天, 就在同一条回家的路上, 我打算四周看看, 试图捕捉到周围的环境中任何可能引来灵感的东西. 然后, 灵感便送上门了. 他就在那里 —— 问题的答案, 开心地在我每天回家的路上等着我.

(GIF 版本)
在百老汇和阿姆斯特丹之间的 65 号大街上, 有 20 个左右的这样的巨大的 LED 广告牌. 他们不断地循环播放各种林肯中心演出或事件的图片广告. 图片之间的切换效果非常丰富, 包括滑入滑出, 渐变淡入&#8230; 以及从模糊到清晰的渐变. Bazinga! 照片始于一片神秘的模糊, 而后渐渐伴随着文字信息而进入焦点. &#8220;这就是我的主屏应该有的样子,&#8221; 我想. 模糊的壁纸依然能够在一定程度上传达原图的含义, 同时也消去了锐利而引人注目的边缘.
在你主屏上的模糊照片
我以百米赛跑的速度疾驰回家, 开始探索如何将这么个简单的技法应用到解决主屏壁纸问题上. 我可以直截了当的让你选一张图片, 然后让它模糊, 然后把输出的图片作为你的壁纸 (然后我就发现已经有不错的应用能做到这一点了). 我依然觉得有些不满意, 毕竟有些时候你还是希望能够清晰地看到你的孩子, 或者优美的自然风光.
何不试试动态壁纸? 自 Android 2.1 起, 应用就能够设置动态壁纸, 而这些动态壁纸甚至能响应触摸事件, 这样的话让照片暂时变清晰就不再是个问题了, 用个简单的双击手势就能轻松解决. 从技术层面上看, 这简直是完美的解决方案.
于是在 2013 年十一月的那个晚上, 我开始制作这款动态壁纸的概念原型图, 并且命名为&#8221;模糊测试&#8221;. 我很快就意识到了仅仅是模糊还远远不够, 于是便决定加入变暗的滤镜作为背景保护. 大概在 Android Studio 里码了几百行代码并且运行之后, 我的壁纸脱胎换骨.
博物馆与灵感
在我制作&#8221;模糊测试&#8221;的同时, 我也在想很多其他的东西: 我的灵感来自何方? 纽约市是一个巨大的灵感来源 —— 65 大道的街区和林肯中心堪称现代科技与建筑的集大成者. 纽约市同样以它传奇般的博物馆而闻名, 博物馆如 MoMA, 充满想象力的展品和精美的艺术品汗牛充栋. 不仅仅是这些作品本身充满了感染力, 艺术家和她的环境, 甚至是人类历史, 时间的流逝, 宇宙万物这样的更深层的概念, 带来了强烈的视觉与精神冲击. 
我意识到, 我真正想利用这个动态壁纸项目做到的, 并不仅仅是让用户的主屏幕变得好看一点儿, 而是给他们带去灵感. 就像去 MoMA 走一遭能带给我数不清的问题和想法, 这些在我们口袋中的科技产物是可以努力成就一个更崇高的目标的.
旅途之始
接下来就是长达四个月的制造 Muzei 的旅程, 而这段旅程则在 2014 年二月的紧张而令人满足的发布时达到高潮.

在这段四个月的开发中, 我了解到了牛逼的 WikiPaintings 计划, 泡到了我那完美的美术老师未婚妻 (顺便从海量的艺术品里挑选出了现在用着的这些画), 学到了更多我早就想学的关于 OpenGL ES 2.0 的知识, 加入了外部艺术品接口 (就像我在 DashClock 里做的一样), 在 Google 云平台上建立了一个小型的服务器端艺术品管理界面和图像伺服系统, 从 Google 的同事们那儿受到了巨量的反馈, 当然, 也经历了很多在排除问题和捉虫中度过的不眠之夜.
这段旅程和它的结果都让我受益匪浅. Kenton, 在伦敦的一位友人, 最近在 Google+ 上和我分享了这么一个帖子:

&#8220;Muzei&#8221; 是俄语单词&#8221;музей&#8220;音译, 意味着&#8221;博物馆&#8221;, 而这正是 Muzei 最大的一个目标: 一个为你的 Android 主屏准备的, 活的博物馆. 它的另一个目标是希望能够在你的潜意识里植入一个&#8221;去访问一下离你最近的博物馆&#8221;的想法, 博物馆是一个你能继续受到来自世界和无数奇迹的启发的地方. Roman 桑大胜利~
回首
于是, 耶, 这毫无疑问是件关于想法是如何形成的, 有趣的事儿.  DashClock 是从一个将他引向美观的锁屏应用的新 API 中诞生的. 而 Muzei 则是从一个为了解决 DashClock 那苦逼的可见性产生的问题中成型的, 但是它却达到了一个全新的高度. 它变成了一个通过开源与扩展性刺激开发者的途径. 它酿就了一件我用来纪念我在 Android 中喜爱的事物与我有幸居住的这个旖旎城市的纪念品. 但最重要的是, 它化作了一条通过我们人类在这个星球上留下的优美的艺术品给人们带去灵感的路. 
</content>
</doc><doc>
    <docid>159</docid>
    <url>http://www.phonekr.com/navigation-anti-patterns/</url>
    <title>Android Design in Action —— 十大导航错误</title>
    <content>
大家好, 这里是 2014 年第一期正式的 ADiA 教程. 在上一次的设计错误文章里, 我们已经简略的提过了一下导航设计上的错误, 这一次, 我们就这个话题展开, 指出一些大家在设计应用导航时经常被犯下的错误以便警示大家.
 
十大导航设计”反模式”, Android 开发者联系团队为你用心呈现~ 希望大家看 (乖) 得 (乖) 开 (中) 心 (枪)~
&nbsp;
1. 将导航项放在 Action Overflow 里

我应该已经不止一次在各种 App 上看到有人把导航项放在 Action Overflow 中了. 经常被放进 Action Overflow 的导航有&#8221;主页 (脑子一定是被保险柜夹了)&#8221;, &#8220;商店 (有时其实可以理解)&#8221;, &#8220;我的信息 (微信, twitter 中枪)&#8221;, 甚至一些分类. 但是 Action Overflow 真的不是导航项该去的地方, 别忘了这地方是 Action Overflow, 是用来放操作的. 还有另一个很重要的原因是, 在很多有着 Menu 按钮的手机上, 应用中是不会显示 Action Overflow 的, 他们得被 Menu 键唤出, 可见性太低了, 而且关于 Menu 键还有一大堆问题 (这里就不展开了).
还有一点很重要的就是, 在现在的 Android 上, 界面 UI 已经逐渐形成了一个规律 —— 导航靠左, 操作靠右. 如果你硬是要把导航放进 Action Overflow, 无形中也会违背这个规律.
&nbsp;
2. 错误的导航层级

这个错误也是颇为常见的. 在 Android 中我们有很多常见的导航方式, 比如 Tabs, Spinners 和 Drawer. 这些导航方式当然是可以搭配着使用的, 但是当你搭配使用这些导航方式的时候, 请注意他们之间的层级关系. 当你规划你的导航层级的时候, 一般情况下是要构造一个树状结构, 在一个层级下有其他的子层级, 以此类推. 在 Android 中, 不同层级一般对应着不同的导航方式. 而错误的用法是, 比如上图中那样的, 用 Tab 作为最高导航层, Spinners 作为次层, 而 Drawer 作为最次层. 在 Android 上, 这三个导航方式对应的层级是遵循着比较严格的规定的.

上图呢才是一般情况下的正确做法. 通常情况下, Drawer (如果有的话) 代表着最高的导航层级, 然后则是 Spinners, 再次是 Tabs. 如果你有超过三级的导航层级, 我们强烈建议你把最顶端的几个都放在 Drawer 中 (只有 Drawer 能容纳超过一个导航层级, 因为 Drawer 中的项目能够以合理的方式展开), 然后把剩下两个层级分配各 Spinners 和 Tabs. 当然, 实际上作为一个移动应用, 简化层级也是非常重要的, 我们强烈的不推荐你在应用中采用非常深的导航层级, 这只会让用户感到困惑.
还有一点需要注意的是, 虽然在上面的示意图中 Spinner 和 Drawer 共存而且看起来 Spinner 在 Action Bar 上 (Drawer 实际上在 Action Bar 之下), 但是在实际应用中, 当用户划出 Drawer 的时候, 你应该让 Drawer 渐变成另一副模样 —— 只留下在应用中全局通用的操作, 比如搜索, 隐去其他的东西, 比如 Spinners, 换成 App 的名字. 这样的话就不会产生导航层级上的困惑了.
另外, 关于 Drawer, 我们还有另一期专门介绍它的 ADiA: Android Design 趋势——Navigation Drawer.
&nbsp;
3. 不能滑动切换的 Tabs.

在 Android 中, Tab 几乎是绑定了横向滑动的操作. 用户对 Tabs 的期望就是他们可以被滑动. 如果你在页面上采用了 paginate (ViewPager) 内容, 那么内容上的滑动操作就会和 Tabs 的全局滑动产生混淆. 当然, 如果页面中只有一小部分是可以滑动的内容 —— 比如一个非全屏的图片浏览, 那么这么做是完全没问题的, 只要不与 Tabs 本身的滑动手势冲突即可.

正确的做法很简单, 只要把横向的 ViewPager 改为纵向就行了. 当然, 如果你有其他的解决方案也很好, 只要规避与导航的手势冲突就可以了.  
&nbsp;
4.  深层/顽固的 Tabs

什么叫做&#8221;深层&#8221;的 Tabs? 要解释深层, 一般来讲我们用&#8221;浅层&#8221;来做对比. 在 Android 上, Tabs 应该是浅的. 你用 Tabs 来作为视图更变, 或者分类切换之用, 而不应该在 Tabs 之内再有层级和历史. 通常情况下, Tabs 只应该在导航界面出现. 在上图的例子中, 用户点击一个项目, 理应打开一个全新的页面, 而不是刷新 Tabs 下的内容. 这种持续出现的 Tab 就是我们所说的深层 Tabs, 或者说在 Tabs 之内有历史.
之所以不这么做的原因是, 当你离开了这个 Tab, 比如说滑动到了另一个 Tab 上的时候, 你就把这个 Tab 置于了一种尴尬的境地 —— 现在这个 Tab (对于用户而言不可见) 应该显示什么呢? 当用户从另一个 Tab 回到这个 Tab (无论是点击还是滑动) 时, 他应该保持原来的样子 (显示内容) 呢, 还是显示列表? 在这种情况下, 用户会很容易的感到困惑. 为了避免这种尴尬, 我们建议 Tabs 最好做得浅一些.
另外, 若你的 Tabs 坚持不变的话, 很大程度会影响到 Back 的作用. 当用户切换到不同的 Tab 并且在这个 Tab 中做了一些操作之后, Back 的作用就会变得不甚明确. 如果你非得在同一个视图内显示新内容, 那么我们建议你采用 Drawer, Drawer 才是为全局内容切换而生的.

上图显示的才是正确的做法, 打开一个新的, 没有 Tabs, 有 Up 的界面, 而不是继续显示 Tabs.
&nbsp;
5. 溯回 (反向遍历) Tabs

前面说的 Tabs 不应该深层, 同样也提到了 Tabs 不应该包含历史. 什么叫做不因该包含历史呢? 就是指, 你在 Tabs 上的操作不能被 Back 溯回. 同一个导航层级是不应该被溯回的.
&nbsp;
6. 溯回 (反向遍历) Drawer

和 Tabs 一样, Drawer 中的导航项也不应该被溯回. 理由同上. 当用户在不同的导航项中切换时, 你应该重置任务状态. 在不同的导航项目中切换就像是切换到不同的应用中一样 (比如说, 在 Google+ 中, Photos Tab 根本就是另一个应用&#8230; ). 在用户按下 Back 的时候, 你应该退出应用, 或者回到应用的主界面 —— 这里的主界面是指那个自然状态下的初始界面, 一个你特别希望用户 (同时用户也特别期待能够容易地) 回到的地方.
&nbsp;
7. 深层的 Navigation Drawer

前文说过, 一个移动应用不应该有复杂的结构. 如果你需要特别多的导航层级, 那么说明你真正应该做的其实是简化你的应用结构. Drawer 存在的意义是提供一个稳定的导航枢纽, 让用户不需要记住自己在什么地方, 他只要打开 Drawer 就能自然的明白一切. 但是, 如果在 Drawer 里面弹出了一个次级 Drawer 会把很多人逼疯.
Drawer 虽然有能力承载多个导航层级, 但是正确的做法不是这样的.

当你需要在 Drawer 中放入多个导航层级的时候, 不应该以新弹出一个 Drawer 的方式, 而是应该以展开/折叠的方式呈现这个子层级. 展开和折叠并不会造成整个控件的剧变, 同时能展示给用户少多一些的项目. 关于 Drawer 上的导航项以及触摸区域的设置, 在 Android Design 中另有提及.

如果你的导航层级真的很深, 你可以单独做出一个次级导航页 展示所有的导航项目. 比如说, 在 Play Music 中, 曲库下的 Tabs (艺人, 专辑, 风格, 曲目) 其实完全可以做成 Drawer 中的次级导航项, 但是把它们分散到 Tabs 中能够更好的优化导航. (上图这样则是有点类似腹肌式的导航方式. 当然, 最好不要只是在上面写着文字, 可以往里面添加点图片啊, 内容预览什么的)
&nbsp;
8. 错误的 Drawer 转场
我们在这里说转场的时候, 是意味着过渡动画和一个有着 Drawer 的界面和没有 Drawer 的界面之间的切换. 下面两个错误都和这个转场有关.

当用户打开 Drawer, 按下其中一个项目之后, 他不应该被带去一个有着 Up 箭头的新界面. 所有在 Drawer 中呈现的导航项, 都应该在其界面中显示 Drawer 指示 (比如说, &#8220;汉堡&#8221;). 而且, 当用户通过 Drawer 从其中一个导航项进入另一个导航项,  他不应该看到标准的视图切换动画 (渐变 + 放大, 常见于进入新界面/新活动时), 而应该是一个细致而迅速的渐隐 + 渐显动画, 伴随着 Drawer 的关闭而完成. 同样的动画也应该应用在 Action Bar 的转变上. 还有一个对于开发者而言常见的讨论是, 应该用 Activity 还是 Fragment? 这个问题并没有标准答案, 也很难回答. 一般来说还是视情况而定 —— 它实现起来难度如何? 对于我的应用而言靠谱吗? 如果你有什么建议的话当然欢迎评论.

上图展示的就是正确的做法, 在 Action Bar 上显示 Drawer Indicator.
&nbsp;
9. 不显示 Up 箭头

上文说过, 所有出现在 Drawer 中的导航页面都应该显示 Drawer 指示, 这点反过来也是一样成立的 —— 没有显示在 Drawer 中的东西就不应该显示 Drawer 指示. 比如在上图, 当用户进入某个内容的时候, Drawer 指示依然显示. 实际上, 这个内容页已经不是导航页了, 也没有在 Drawer 中显示, 这里是应用更深的层级, 已经不归 Drawer 管了. 这里应该显示的是 Up.

在显示 Up 同时, 你也可以允许用户以边缘滑动的方式唤出 Drawer. 你不需要总是显示 Drawer 指示来告诉用户可以唤出 Drawer, 因为在次级界面中唤出 Drawer 是某种意义上的&#8221;进阶用户操作&#8221;. 有人发现了, 那很好, 没人发现, 不要紧, 通过 Up 他们依然能够找回他们需要的导航. 另外, 你可以看看 Google Play Newsstand 是如何处理在没有 Drawer 指示的地方处理 Drawer 的 —— 渐变动画真的非常重要.
&nbsp;
10. 右侧导航

前文说过, Android 上有个规律就是&#8221;导航靠左, 操作靠右&#8221;. 对于从左向右阅读的用户而言, 左侧导航项能够更好的强调导航层级. 另外, 由于 Spinners 只能出现在左侧, Tabs 也往往将最左侧的一个设为默认, 右侧的 Drawer 与这些操作距离过远. 而且, Drawer 指示放在左边, 操作的时候向左回缩, 如果在右侧使用 Drawer 的话就会遇到视觉隐喻冲突.

正确的做法就是如上图所示. 当然, 如果在从右向左的语言环境下 (比如说, 希伯来文什么的, 不过我觉得我们国家的开发者应该不怎么会去做希伯来语适配吧&#8230;), 那当然是应该反转这些东西的位置.
&nbsp;
以上就是本期 ADiA 介绍的全部十个导航设计错误. 如果你有更多的常见/不常见错误, 或者对于上面提出的错误有更好的解决方案, 当然欢迎评论.
最后, 一如既往的感谢 +Roman Nurik 和 +Nick Butcher 的 Android Design in Action 活动.
</content>
</doc><doc>
    <docid>160</docid>
    <url>http://www.phonekr.com/iuni-and-more/</url>
    <title>极客公园环聊日常 —— 由 IUNI 引发的杂谈</title>
    <content>今天晚上龚叔 (+Carlos Gong) 在环聊里转发了一条 IUNI 的微博, 引发了一场挺有启发的讨论.
&nbsp;
出场人物:
+Geoffrey.R HSU: 我 (全程打酱油)
+王洪森: @王洪森 (主角 1)
+Carlos Gong: @冬虫夏草卡洛斯 (主角 2)
+John York: @detecti1914 (吐槽役 1)
+Tony Qian: @tonyq0802 (吐槽役 2)
&nbsp;
Part 1: IUNI 与动画
Carlos Gong &#8211; 6:48 PM
http://weibo.com/p/1006063840873722 我得说，作为第一个版本，INUI 似乎没让人太失望。
PPT 整体上比老罗/李楠/雷军都要舒服些。虽然小细节上值得吐槽的地方有。
王 洪森 &#8211; 6:52 PM
我觉得有点动画很多余
浪费性能
Geoffrey.R Hsu &#8211; 6:53 PM
我觉得动画还不错
看着挺愉悦的
也不算繁复
John York (detecti1914) &#8211; 6:53 PM
卖点是设计么
王 洪森 &#8211; 6:54 PM
老罗的锤子我后来在我朋友手机上体验过
我觉得有细节、有灵气，但很多地方都缺乏深思熟虑，想当了前面没想到后面
John York (detecti1914) &#8211; 6:54 PM
特性没看到什么的感觉
王 洪森 &#8211; 6:54 PM
我觉得 INUI 的操作不直观
虽然操作方式很基本，挺适合手机，但给的提示太少
用户不看演示，不可能天然知道。
Geoffrey.R Hsu &#8211; 6:57 PM
闹钟那里简直精仿 iOS 7…
设计也不是很好…
王 洪森 &#8211; 6:59 PM
我觉得是一个性能理想化，设计苹果化的 UI 设计
Geoffrey.R Hsu &#8211; 6:59 PM
+1
精辟的总结
王 洪森 &#8211; 7:01 PM
直观和直接是我现在觉得比较合理的设计，否则为了动画效果影响开发进度，就会跟老罗一个德行，只有跳票。
Tony Qian &#8211; 7:03 PM
动画这东西，看着好看，用着还想好用，那太难了。
王 洪森 &#8211; 7:04 PM
iOS 上的 path 算是能做到这点，但已经比较要求性能配合了。
Geoffrey.R Hsu &#8211; 7:04 PM
Android 现在是打算开始重视动画了
王 洪森 &#8211; 7:05 PM
其实我觉得交互的趣味，可能比动画更有点意义，比如 clear
Geoffrey.R Hsu &#8211; 7:05 PM
4.4 新加入了那个 scenes 就是个信号
好的交互也需要配合上合理的动画才能发挥全力啊
&nbsp;
Part 2: 风格问题
Tony Qian &#8211; 7:05 PM
这个系统是 iOS 7 么
王 洪森 &#8211; 7:05 PM
同意
哈哈，拖泥你真黑
确实，开创性少了点，还不如 Windows Phone
Tony Qian &#8211; 7:09 PM
跟在别人屁股后面肯定是死啊
这也不拍明年苹果 iOS 8 风格大变
丫就傻逼了
Geoffrey.R Hsu &#8211; 7:09 PM
哈哈哈
Tony Qian &#8211; 7:09 PM
老罗当年拍胸脯说跟着苹果 3.5 一生挚爱
结果现在尴尬了
Geoffrey.R Hsu &#8211; 7:09 PM
iOS 8 视觉风格应该不会改了
Tony Qian &#8211; 7:10 PM
Ubuntu Phone 也好，Jolla 也好
都有自己独立的风格
王 洪森 &#8211; 7:10 PM
iOS 7 真的太大胆了，目前从放出的 7.1 测试版来看，苹果还在努力优化及合理化它
Tony Qian &#8211; 7:10 PM
都在力求和 Andorid iOS 保持区别的时候，国内还跟在 (iOS) 屁股后面
王 洪森 &#8211; 7:11 PM
同意拖泥
Geoffrey.R Hsu &#8211; 7:11 PM
是啊
托尼 +2
王 洪森 &#8211; 7:12 PM
国内的总是想把安卓做成 iOS
Geoffrey.R Hsu &#8211; 7:12 PM
没错啊…
王 洪森 &#8211; 7:12 PM
真心不知道为了个什么
Geoffrey.R Hsu &#8211; 7:12 PM
国外的都在创新, 国内的都在学 iOS
价值观问题… 吧…
Tony Qian &#8211; 7:14 PM
我一直觉得 Google 在设计上多用点心，Android 还能上好几个档次
第三方 OME 机会很多的
Geoffrey.R Hsu &#8211; 7:14 PM
是的
问题就是 Google 不打算让 Android 的设计出风头啊…
努力在减少系统的存在感呢
&nbsp;
Part 3: 关于 MIUI 和小米 (还有元宵)
王 洪森 &#8211; 7:15 PM
不过背后使用安卓这层，我觉得小米无论从品牌形象，产品、甚至幻灯片，丫人家起码是风格一致的，虽然品味不敢恭维，但起码丫没有准备要像 iOS （视觉上），而且至少一致。
Tony Qian &#8211; 7:16 PM
没错~
王 洪森 &#8211; 7:16 PM
就怕东一榔头西一榔头，或者丑到要死还不知道改的。
Geoffrey.R Hsu &#8211; 7:16 PM
+3
MIUI 其实还是有仿 iOS…
王 洪森 &#8211; 7:17 PM
6
目前没追7
Geoffrey.R Hsu &#8211; 7:17 PM
嗯
那算是历史遗留问题
王 洪森 &#8211; 7:18 PM
我觉得它更多的是在系统操作的抉择上趋向 iOS。比如安装和卸载等。
Carlos Gong &#8211; 7:19 PM
MIUI V5 的时候明显感觉到整个系统从开始规划的时候就进行了统一的架构设计和风格规范。
Geoffrey.R Hsu &#8211; 7:19 PM
毕竟是 Rigo 操刀
龚星Carlos Gong &#8211; 7:19 PM
我觉得这是 V5 比 V3 V4 最大的进步。
也是 MIUI 甩掉国内其它 ROM 最重要的一点。
Geoffrey.R Hsu &#8211; 7:20 PM
Rigo 在架构规划方面我觉得目前国内无出其右
其实就连乐 OS 都很好
Tony Qian &#8211; 7:21 PM
原来那个元宵是洪森啊
我以为是 Carlos 的新头像呢
王 洪森 &#8211; 7:21 PM
其实但从产品层面出发，我觉得是不完整和全面的。安卓原生确实更符合 Google 的调性。
John York (detecti1914) &#8211; 7:21 PM
Carlos Gong 以前用过类似的吧
Geoffrey.R Hsu &#8211; 7:21 PM
哈哈哈哈哈哈哈哈
王 洪森 &#8211; 7:21 PM
魅族在产品层面的设计其实也不错
Geoffrey.R Hsu &#8211; 7:21 PM
那个元宵哈哈哈哈哈哈哈
Carlos Gong &#8211; 7:22 PM
现在也在用啊，我的 QQ 头像～
王 洪森 &#8211; 7:22 PM
但问题是他们的手机界面那么好看，而幻灯片那么难看就是有问题的
Geoffrey.R Hsu &#8211; 7:22 PM
Flyme 2.0 其实挺好的…
&nbsp;
Part 4: 颜色问题 (以及基佬)
王 洪森 &#8211; 7:23 PM
大家都能知道小米的品牌色是那个比较偏红的橘色
却很难说出魅族的品牌色
Tony Qian &#8211; 7:23 PM
等诺基亚来创新下，三星这种销量第一的怂包没戏，HTC 快死了，LG 就是个跟班，Sony 被之前的成功拖累。
看好诺基亚
Carlos Gong &#8211; 7:23 PM
IUNI 幻灯片还好吧，至少不算丑。细节就不说了，恶心的地方不少。。。。
Geoffrey.R Hsu &#8211; 7:23 PM
蓝色啊
Tony Qian &#8211; 7:23 PM
小米那个品牌色是牺牲了美感堆砌出来的
到处都是橙色
Carlos Gong &#8211; 7:23 PM
至于风格。。。。。 刚刚开始，没法要求他们用北极蓝做出一套自己的幻灯片然后全厂到处用吧。。。。
Tony Qian &#8211; 7:23 PM
橙色，不管好不好看
王 洪森 &#8211; 7:24 PM
而魅族的发布会弄到那么大阵仗却用了个苹果官方模版了事
Carlos Gong &#8211; 7:24 PM
小米开始各个场合用橙色也是在小米一代出了以后的时候。。。。
魅族这个。。。。。 李楠的个人趣味影响太大了。。。。。
苹果的官方模板和高桥流文字排版是李楠个人的爱好。
Geoffrey.R Hsu &#8211; 7:25 PM
小米橙太 2.3 了…
魅族蓝比较 4.0
王 洪森 &#8211; 7:26 PM
魅族的蓝并没有充分被贯彻和突出
Carlos Gong &#8211; 7:26 PM
魅族蓝没有充分贯彻 +1
Geoffrey.R Hsu &#8211; 7:26 PM
至少幻灯片上没有
+2
王 洪森 &#8211; 7:26 PM
我们明显对知乎的蓝更有印象
Geoffrey.R Hsu &#8211; 7:26 PM
哈哈哈哈哈哈哈哈
Carlos Gong &#8211; 7:26 PM
是的。
Tony Qian &#8211; 7:26 PM
flyme 3.0 感觉整体变暗了
和之前的蓝有点不同
Geoffrey.R Hsu &#8211; 7:27 PM
知乎换图标之后蓝色也变暗了
Tony Qian &#8211; 7:27 PM
原来很基佬
现在是老gay 的感觉
王 洪森 &#8211; 7:27 PM
靠
Geoffrey.R Hsu &#8211; 7:27 PM
Flyme 3.0 不如 2.0 好看…
王 洪森 &#8211; 7:27 PM
xingyuan也暗了
Geoffrey.R Hsu &#8211; 7:27 PM
基佬和老 gay 的区别是啥…
王 洪森 &#8211; 7:27 PM
也变老gay了
Carlos Gong &#8211; 7:28 PM
拖泥的一直没暗～
王 洪森 &#8211; 7:28 PM
嗯，年轻的 gay
&nbsp;
Part 5: Flyme 与魅族 (以及小伙伴们的腹黑日常)
Carlos Gong &#8211; 7:28 PM
我刚从西单大悦城回来。那边的 MX2 也已经默认 flyme 3 了～
Geoffrey.R Hsu &#8211; 7:28 PM
我漏掉了什么没看吗…
Carlos Gong &#8211; 7:29 PM
MX2 刚开始的时候是软件硬件眼前都一亮的。。。。 现在握着还是温润舒适大小正好，软件看着已经味道有点不对了。
王 洪森 &#8211; 7:29 PM
魅族自己出的应用，除了底部的 smartbar 几乎没办法看出是他们家的东西
Carlos Gong &#8211; 7:29 PM
不过话说 MX3 的背其实很舒服。。。
王 洪森 &#8211; 7:30 PM
而小米的一看就能知道
Tony Qian &#8211; 7:30 PM
MX 3 握感比 MX 2 下降了很多
Carlos Gong &#8211; 7:30 PM
额。。。。 flyme 2.0 时代有一个突出特征是右上角的 scrollable tabs，3.0 砍了。
王 洪森 &#8211; 7:31 PM
MX 3 背部闪光灯附近手感很次，剌手
Carlos Gong &#8211; 7:31 PM
措辞改一下，2.0 时代有一个很突出的特征是浅蓝色顶部 action bar 带右上角 scrollable tabs，这个设计现在貌似是砍掉了。
王 洪森 &#8211; 7:31 PM
小米的装在什么 rom 上都能看出是小米
而魅族首先不能随便装在别的上面
Tony Qian &#8211; 7:32 PM
MX 2 的闪光灯不是 LED 的，会发热，如果用来当做手电筒，会把后盖融化
Carlos Gong &#8211; 7:32 PM
小米的突出风格，其实也是 V5 之后 RIGO 接管才做出来的。不过现在风格已经明显到把多看装在 iOS 上都知道是小米出品了。。。。
Tony Qian &#8211; 7:32 PM
现在去给 Mac mini 上 SSD，求祝福
Carlos Gong &#8211; 7:32 PM
#祝挂
Tony Qian &#8211; 7:33 PM
Mac 怎么备份啊
王 洪森 &#8211; 7:33 PM
祝你永远幸福
仍掉就可以了，不用备份
&nbsp;
Part 6: 魅族与小米的设计与产品
Carlos Gong &#8211; 7:33 PM
大到 T 字结构，小到分享按钮的样式，多看 for iOS 都是一股浓烈的小米味道。
王 洪森 &#8211; 7:35 PM
魅族设计早期是 eico 做的
Carlos Gong &#8211; 7:35 PM
后来魅族把 eico 当时的项目主管挖过去了。黄章回归演讲的时候坐在左边那个。
王 洪森 &#8211; 7:36 PM
唯一记得的是音乐是个大唱片，很老的拟真设计，结果还很少人用到。
还有一个“设计”就是底部的大M，只能开魅族首页，史上最屎设计。
Geoffrey.R Hsu &#8211; 7:39 PM
eico 我很不喜欢
王 洪森 &#8211; 7:40 PM
不过其壁纸那几个气球，配合解锁时需要的上滑动作是有引导的。而且让人感觉轻，这部分觉得要比小米那个各种炒作的山水城市的高几个段位。
Carlos Gong &#8211; 7:40 PM
小米的壁纸大赛就是个笑话。。。。
魅族一直很会玩界面上的这一套。flyme 1.0 开始就有一个特别舒服的充电界面。
王 洪森 &#8211; 7:42 PM
eico 设计的 weico pro 没比官方客户端好多少，当我在犹豫装weico 还是官方客户端的时候，我突然豁然开朗，因为我已经没在玩微博了。
让它们都去死去吧。
Carlos Gong &#8211; 7:42 PM
有的时候会觉得小米已经把这种诡异的不正常气质固化下来想改都很难改了。
尽管这样，感觉 MX3 的 1999 现货还是没法和小米直接竞争。原因说不好，但就是这样。
王 洪森 &#8211; 7:44 PM
软硬结合这事其实魅族做得比小米好。
Carlos Gong &#8211; 7:44 PM
是的。
王 洪森 &#8211; 7:44 PM
但手机只是一部分，小米有他们可以消费的内容
而魅族只能空享受下没有飞线的手机本人
小米已经有亚文化相关的各种周边，包括虚拟的，包括物理的。
Carlos Gong &#8211; 7:46 PM
「我觉得 MIUI 的强大之处大致是三个地方：1、系统层面上，有成体系的结构隐喻、美学风格和基本界面架构（锤子和 Vibe 这种属于没体系的）。2、launcher 和自带应用的特性和体验。比如彻底无打扰的录音机，和电话短信联系人这些基础功能上的特性体验。3、在界面和需求上对生态圈的号召力和控制力。比如有能力让国内应用优先适配 MIUI 的界面风格，比如自己有全套云服务、内容服务（收购的多看）甚至是未来的智能家居服务（比如小米电视和小米路由器）。」
这是之前我的总结，但感觉这个跟手机竞争关系其实不大。。。。
王 洪森 &#8211; 7:46 PM
比如主题，多少设计师在为他做设计呀
Carlos Gong &#8211; 7:47 PM
毕竟生态在纯手机方面又能有多少影响力呢～尤其是在国内。
王 洪森 &#8211; 7:47 PM
比如图文的内容通过多看，用米币购买
同时路由器、盒子、电视等等
手机用途用法不断涌现
还都在小米帝国里
魅族就只有无飞线，窄边框
和M首页和smart bar，不知道在闹哪样
李楠当年致力于让短信和微博私信打通，好号称包含多少思考我就觉得很 2
相同的精力哪怕做个半死不活的米聊，都不会显得太尴尬
魅族本身毫无互联网产品可以称道
&nbsp;
结尾卖萌
Geoffrey.R Hsu &#8211; 7:53 PM
洪森大哥 +13
龚叔 +5
王 洪森 &#8211; 7:53 PM
请叫我元宵
Carlos Gong &#8211; 7:54 PM
洪森 +14
Geoffrey.R Hsu &#8211; 8:32 PM
元宵大哥 +15
Carlos Gong
</content>
</doc><doc>
    <docid>161</docid>
    <url>http://www.geekpark.net/topics/217084</url>
    <title>在拉斯维加斯，我经历了一场智能化生活的洗礼</title>
    <content>作者：龟途慢慢</content>
</doc><doc>
    <docid>162</docid>
    <url>http://www.geekpark.net/topics/217080</url>
    <title>Quip 模式难以复制，因为中国市场缺的是 Google Docs</title>
    <content>作者：早优夫斯基</content>
</doc><doc>
    <docid>163</docid>
    <url>http://www.geekpark.net/topics/217083</url>
    <title>提醒你出门带伞这件小事，背后是价值百亿的蓝海</title>
    <content>作者：杨雪</content>
</doc><doc>
    <docid>164</docid>
    <url>http://www.geekpark.net/topics/217081</url>
    <title>细数社交巨无霸 Facebook 与美国媒体的「爱恨情仇」</title>
    <content>作者：黑板报值日生</content>
</doc><doc>
    <docid>165</docid>
    <url>http://www.geekpark.net/topics/217079</url>
    <title>OV 销量同时超越华为，苹果放出新 MacBook Pro 真机图 | 2016 年 10 月 26 日</title>
    <content>作者：colorvc</content>
</doc><doc>
    <docid>167</docid>
    <url>http://www.geekpark.net/topics/217074</url>
    <title>从 iPhone 到自动驾驶，我们所经历的智能化时代</title>
    <content>作者：拉风的极客</content>
</doc><doc>
    <docid>169</docid>
    <url>http://www.geekpark.net/topics/217070</url>
    <title>年轻人的第一款电动牙刷：素士声波牙刷 X3 使用体验</title>
    <content>作者：谁是大英雄</content>
</doc><doc>
    <docid>181</docid>
    <url>http://www.ifanr.com/737451?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>Google 发布了一款办公神器，剑指微软的 Surface Hub</title>
    <content>
在微软的 Surface 系列产品线中，除了面向个人消费者的 Surface Pro 系列和 Surface Book 笔记本，还有一款专门面向企业用户的巨屏设备 Surface Hub；其典型的使用场景就是会议室办公协作。

图自：microsoft
如今，Google 也推出了一款与 Surface Hub 功能相似的产品，名为 Jamboard。

图自：Google
基于云端的 Jamboard
在 Google 官方描述中，Jamboard 是一款用来协作的数码白板（digital whiteboard）,它能够让团队成员实时分享和合作完成创意；更重要的是，按照 Google 的一贯思维，Jamboard 同样也是基于云端服务的。
在具体的配置上，Jamboard 搭载了一块 55 英寸的可触控 4K 分辨率屏幕，拥有高清摄像头、扬声器和 WiFi 连接功能。为了让 Jamboard 能够在更多场合下使用，Google 还为它设计了一个配有轮子的底盘，可以方便用户移动。
软件方面，它所搭载的是经过特殊定制的 Android 系统。由于是基于云端，Jamboard 可以实现不同成员在不同设备之间的同步操作，而操作的结果在可以 Jamboard 上同步显示；不仅如此，它还可以实现基于网络的远程协作。

图自：YouTube
Jamboard 还与 Google 的 G Suite 套件实现了深度整合。G Suite 套件中集合了一系列办公专用的 app，可以更加方便地实现办公功能。举个例子，在会议中，用户可以直接将文档从 Drive 中拖动到 Jamboard 上，非常方便。
另外，为了让 Jamboard 更好地运作，Google 为它专门提供了两个附件：一个可以精准操作的电子手写笔和一个电子橡皮擦。这两个附件都不需要充电，当用户使用它们在 Jamboard 上操作时，Jamboard 能够识别并给予相应的反馈。

电子手写笔和电子橡皮擦
不仅如此，Jamboard 还能自动识别用户用手指做出的擦拭动作。
按照 Google 官方的说法，Jamboard 的售价会低于 6000 美元，将会在明年开卖。作为对比，微软推出的 55 英寸版 Surface Hub 售价为 8999 美元。
G Suite 的硬件外壳
虽然 Google 已经声明 Jamboard 的售价不高于 6000 美元，但它的定位非常明显，就是面向企业级用户，而与个人消费者没有太大的关系。
另外值得注意的是，在 Google 官方博客宣布将要推出 Jamboard 的，正是 Google 方面负责 G Suite 的产品经理 TJ Varghese。
实际上，Jamboard 与 G Suite 之间的关系无比密切。

图自：slickmedia
G Suite 成立于不到一个月之前。今年 9 月 30 日，Google 在官网宣布，将在原有的企业办公应用（Google Apps for Work）的基础之上，组建一个全新的企业办公服务，并命名为 G Suite。
G Suite 包含了一系列可以被应用于办公领域的服务，其中有 Gmail，Docs，Slides，Drive，Calendar，Hangouts 等。它们之所以被整合在一起，一方面是品牌方面的统一，但另一方面可以说是 Google 在向企业办公市场的一次重大迈进。

图自：networkedindia
而 G Suite 的直接对手，恰恰是微软的 Office、OneDive、Skype for Work 等一系列办公应用。
值得注意的是，G Suite 中不仅仅加入了 Google 原有的应用，还集合了 Google 包括自然语言处理、图像识别、智能分析在内的多项人工技能技术。
不过，G Suite 虽然优秀，但它毕竟是不存在实体的服务；从功能实现的角度，它还缺乏一个适用于办公场景的硬件承载者。而 Jamboard 的出现，恰恰扮演了这个角色。
因此可以说，Jamboard 是 G Suite 的硬件外壳，也可以说是 Google 迈向企业办公市场的另外一个重大决策。

图自：Google
另外，鉴于 Google 的 Chromebook 在教育市场已经有所积累，其与 Jamboard 同样也可以在教育办公领域形成犄角之势。这也可以认为是 Google 的另一个布局。

图自：Google
正面对抗 Surface Hub
简单来说，Jamboard 的出现，是 Google 在企业办公市场针对微软 Surface Hub 的一次正面挑战。
从目前的情况来看，Jamboard 应该是处于 Google 规划中的硬件产品；Google 在官方的介绍中，只是提到 2017 年可以买到，但是关于这项产品的配置介绍，却是非常笼统的。

图自：Microsoft
而相比较而言，微软的 Surface Hub 早已经在今年 3 月份发货，而且在实际的办公体验上，Surface Hub 并不差。虽然价格相对高了一点，但 Surface Hub 依然不失为一个有力的竞争对手。
题图来自：YouTube
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>182</docid>
    <url>http://www.ifanr.com/737392?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>为了让你在国外花钱更方便，这些公司也是拼了</title>
    <content>
在刚刚过去没多久的十一假期里，我们足不出户也能在朋友圈里看遍世界。出境游成为了不少年轻人规避出游高峰，享受假期的优选。
国家旅游局发布的数据显示，2016 年上半年中国公民出境旅游人数达 5903 万人次，比上年同期增长 4.3％。中国已经成为泰国、日本、韩国、越南、俄罗斯、朝鲜、马尔代夫、英国等国的第一大入境旅游客源地。
盯上出境游的可不只是游客，不少中国互联网公司也希望借此机遇，实现自己“梦寐以求”的国际化战略。
出境游：携程的下一个强劲增长点
10 月 24 日，携程宣布与美国纵横、海鸥、途风等三大旅行社企业达成战略投资与合作，全面布局北美旅游市场，携程集团高级副总裁、携程旅游 CEO 杨涛表示，走向国际化、布局出境游目的地是携程的重要战略。

在线旅游平台配合目的地旅行社推出在线旅游产品，这样的模式或许会不断推动携程出境游业务总交易额（GMV）的提高。目前携程出境游业务除常规的跟团游之外，还囊括了包括接送机、国际租车、门票预订、Wi-Fi、保险等独立业务，若能够通过旅行团的形式向消费者打包出售旅游产品，对于携程的收入是一个利好消息。
现阶段，出境游既是投资者非常关注的一块业务，也是携程目前增长最为快速的业务。在今年 3 月份的 2015 财年第四季度财报电话会议上，高盛集团分析师 David Jin 询问了携程出境游和境内游总交易额比例问题，携程联席总裁兼 COO 孙洁表示：
目前，出境游业务在公司总 GMV 中的占比仍然很小，但是出境游业务在公司总 GMV 中的占比增长速度远远快于境内游业务。我们预计，到 2020 年，出境游业务 GMV 将在公司总 GMV 中占到相当大的比重。
类似的高管发言还出现在 2016 财年第一、第二财季中，方便我们对携程出境游业务的发展趋势有所了解：
出境游对公司各个业务的营收均有贡献。具体来看，出境游对携程酒店业务的贡献有 15%－20%，对机票营收的贡献有 30%，度假业务占 60%－70%。——携程 CFO 王肖璠（2016 财年第一季度）
&nbsp;
我们将会通过专注于提供一站式在线旅游平台，扩展出境游业务覆盖度，提高运营效率，以强化携程的行业领导地位。——携程 CEO 梁建章（2016 财年第二季度）

根据艾瑞咨询发布的《2016 年中国在线旅游度假市场研究报告》，2015 年出境游业务占据了国内在线旅游市场 52.6% 的份额，市场规模非常可观，携程网则在此占据了 25.1% 的市场份额，高居市场首位。
移动支付：银联、蚂蚁金服形成两大重要势力
中国是目前世界上移动支付最为发达的国家，没有之一。这样的市场环境也促使中国银联、支付宝等国字号银行机构及互联网公司加快海外布局，为中国人在海外放心买买买打好支付基础。
而在这场商战中，中国银联显然依靠官方地位走得更快更好。
10 月 21 日，银联国际宣布与德国两大收单机构 B+S Card Service、CardProcess 公司达成合作，总计开通当地 5 万多家商户受理银联卡，使德国商户的银联卡受理覆盖率从现在的 30% 提升到 50%。银联还透露在英国、法国、瑞士、捷克等国家有超过 100 所大学支持使用银联卡支付学费。

（图片来自：Business Insider）
银联官方数据显示，截止至今年 9 月 13 日，银联卡可以在境外 1800 万家商家和 130 万台 ATM 使用。服务方面，如在境外发生卡片丢失、被盗等情况，持卡人能在 220 多个国家和地区超过 40 万个服务网点，申请最高等值 5000 美元的现金支援。
除了商业上的合作，银联还在向境外输出芯片卡标准。10 月 16 日，银联宣布与亚洲支付联盟 7 家会员机构达成芯片卡标准授权合作，这也意味着银联主推的云闪付功能未来很有可能会出现在新加坡、泰国、韩国、马来西亚、印尼等亚太国家，进一步降低中国消费者境外刷卡的门槛。
不过，考虑到银联是直接由央行批准成立的金融服务机构，既是金融市场的参与者，也一定程度上影响着市场规则的制定，所以银联的境外发展路径具有唯一性，不可复制。以支付宝为代表的互联网金融公司，更多地是凭借自己在移动端上的优势及对用户需求的把握，在消费者和商户需求最旺盛的领域展开激烈竞争。

（一家支持支付宝消费的韩国店铺，图片来自：新华社）
以韩国为例，根据第一财经报道，拉卡拉在今年 8 月末宣布与韩国友利银行达成合作推出本地结算业务。至此，得益于中国游客赴韩旅游、购物的巨大需求，中国已有支付宝、微信支付和拉卡拉三大移动支付品牌进驻韩国。早在 2015 年 5 月，韩国副总理崔炅焕就与马云会面，表示将全力支持支付宝在韩国普及。目前，韩国不少主流免税店都已经支持使用支付宝结算。
在几大互联网金融公司里，蚂蚁金服的海外布局规模或许是最庞大的。在此前有关双 11 启动仪式以及蚂蚁金服与 First Data、惠尔丰（Verifone）达成合作的报道中，爱范儿（微信号：ifanr）曾经提到目前支付宝“全球收全球付”服务覆盖全球超过 200 个国家和地区，支持美元、英镑、欧元等 18 种货币一键结算。在 9 月份刚刚结束的二十国集团工商峰会（B20）中，马云提出并倡议的 eWTP（世界电子贸易平台）得到了极高的关注，若 eWTP 最终能成为现实，那蚂蚁金服及旗下支付宝作为阿里的金融“触手”，势必会借 eWTP 的发展，进一步推动其全球支付网络的建设。

将中国企业推向海外的不一定是战略，也可能是消费者的欲望
国际化一直都是中国互联网公司的难题，不少在国际化稍有起色的互联网公司都还仅仅停留在东南亚地区的发展中国家。但是在对出境游市场有所研究之后，爱范儿（微信号：ifanr）却发现了国际化发展在这个领域独特的呈现方式。
伴随着中国游客的脚步走出国门的，既有蚂蚁金服、微信支付、携程、中国银联这样的互联网巨头及金融机构和他们成规模的境外业务，也有小米 MIUI 境外漫游、滴滴出行海外版等偏重于给消费者提供多一点便利的特殊服务。而这些公司的业务之所以能在海外开花，无一例外不是与他们最熟悉的消费群体——中国消费者的需求保持紧密联系。
不过在看似充满成就的“布局”之下，这些互联网公司也要花更多精力确保自己的海外业务的基层执行能力，否则即使将自己的 Logo 贴得满大街都是，也不一定能确保海外服务的体验能够与国内保持一致。毕竟向消费者提供服务的并不是行业大佬，而是分布在街头巷尾的便利店收银员、专车司机等典型的本土服务业劳动者。
题图来自：Frontier Magazine
  
    

      
        
          麦玮琪 (Michael)
          
          关注无人机、汽车，探讨商业模式和科技产品与社会的结合。工作邮箱：michael@ifanr.com
        
      
    
    
      
                    
          
                                  邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>183</docid>
    <url>http://www.ifanr.com/737357?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>“美国滴滴”Lyft CEO 否认公司在售，但靠“补贴大法”还可以撑多久？</title>
    <content>
昨日《华尔街日报》主办的 WSJDLive 全球科技大会上，Uber 在美国最大的竞争对手、美国第二大打车应用 Lyft 的联合创始人 John Zimmer 出席，并当场否认了 Lyft 正在对外出售的传闻，并称 10 月订单量实现翻倍。
订单量翻倍，营利能力还是堪忧
John Zimmer 透露，自去年年底以来 Lyft 在美国的订单数量已经实现翻倍，今年 10 月已达到 1700 万份，而去年 12 月仅为约 700 万份。
今年 6 月份，Lyft 聘请了投资银行 Qatalyst Partners LP 作战略顾问，而 Qatalyst Partners LP 以擅长公司买卖交易著称，因此引来部分分析师怀疑出售 Lyft 的大门已经打开，竞购方可能是资金充裕又对共享专车领域兴趣盎然的通用汽车。

这一怀疑也部分源于 Lyft 自身的状况。自 2007 年创立以来，Lyft 通过多轮融资募集到 20 多亿美元，与 Uber 在美国本土的交战还在持续，目前仍处于亏损状态。对此，齐默在大会上仍对 Lyft 的盈利时间表缄口不言。
但他透露 Lyft 有在未来几年内 IPO（首次公开招股）的计划。“我们并不急于上市，IPO 才是最接近的事。”John Zimmer 说。
虽然今年还有 2 个月左右才结束，但 John Zimmer 估计今年 Lyft 的订单总量会是去年的三倍。目前 Lyft 主要的业务拓展方式仍是共享专车平台的“土办法”：通过大量的现金补贴吸引新用户和专车司机。因此，Lyft 的盈利能力被这部分支出大大压缩，成为目前为止还没有实现盈利的主要原因。
John Zimmer 不断强调 Lyft 订单数量的上升，却避而不谈盈利计划，反而让 Lyft 尴尬处境欲盖弥彰——订单越多，亏得越多。
在“反 Uber”这件事上，Lyft 越来越孤单
在 Lyft 努力扩大美国市场份额，老对手 Uber 则更多把精力投向全球业务。另外，反吞下 Uber 在华业务的滴滴出行也不满足于中国市场，开始思考扩张全球业务。
同样是 WSJDLive 大会上，滴滴出行总裁柳青高调宣布公司将向中国以外的市场扩张，夺取全球份额。美国这块沃土当然也在滴滴考虑范围内。

而去年滴滴还是 Lyft 带头的“反 Uber 同盟”成员之一，成员包括新加坡共享专车平台 Grab 和印度的 Ola。这个联盟试图引导乘客在另一个国家选择联盟成员服务，借此抵抗 Uber 的全球拓展步伐。而滴滴一旦进入美国市场，自然就成为 Lyft 的直接对手。
对此，John Zimmer 表示，Lyft 与滴滴出行的关系有点类似美剧《摩登家庭》 中成员相互独立的关系。他发言称，滴滴出行与 Uber 中国业务合并“很大程度上不会影响到双方的工作或是业务”。

和 Uber、滴滴相比，Lyft 目前独有的优势在于和通用汽车的良好的关系。今年年初，通用汽车向 Lyft 投资 5 亿美元，而且双方计划在未来五年内合作进军无人驾驶市场。
在分工上看，Lyft 能为通用汽车提供丰富的客户资源，而通用汽车作用实力雄厚的老牌汽车制造商能为 Lyft 提供硬件和技术支持。
如果这个无人驾驶计划能落地， Lyft 能将每公里的费用降至 5 美元。更低的价格意味着 Lyft 有希望逃脱目前“补贴多越亏，为了市场份额又不能不补贴”的怪圈。
进入 2016 年下半年，包括 Uber 在内的共享专车平台们都在苦苦寻觅新的盈利模式。都说“补贴烧钱一时，占领市场一世”，但烧的钱什么时候才能转变为真正的盈利，除了视乎平台本身财政状况外，还要看投资人们对这一领域的信心。
从 Lyft 目前的状况看来，投资人们的耐心极限已经临近了。无人驾驶开发也好，市场兼并也好，全球共享专车平台思考变现方式的进程将显著加快。
题图自：《华尔街日报》
插图自：《华尔街日报》、Bidnessetc
  
    

      
        
          刘 浩南
          
          请指教~工作邮箱：liuhaonan@ifanr.com
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>184</docid>
    <url>http://www.ifanr.com/737296?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>逼宫亚马逊，Google Express 又放大招了</title>
    <content>
据今日美国报道，Google 宣布旗下 Google Express 服务将在美国新增 13 个州，真正做到“只要你掏钱，我哪里都可以送”。
&nbsp;

（图片来自：Google Express 官方 Facebook 截图）
&nbsp;
从 Google Express 官方 Facebook 帐号 10 月 25 日发布的消息可以看到，目前 Google Express 已经覆盖了美国的东西两岸。而据统计其辐射范围将接近美国本土的 90% 区域，近 7000 万消费者将因此受益。

不求最全，但求最远
&nbsp;
我们的宗旨是让人们能够更加便利地从他们真正喜爱的商店购物。
Google Express 总经理布莱恩•艾略特 （Brian•Elliott）的发言强调了 Google Express 存在的核心价值：便利以及独特。
自 2013 年 3 月在美国旧金山和硅谷范围内上线以来，Google Express 的扩张脚步一直没停下来。艾略特曾在九月份表示，其计划在今年底将 Google Express 的在线购物速运从目前的 20 个州和区域拓展至全国范围。
&nbsp;

（图片来自：SiliconBeat）
&nbsp;
为了与电商大佬亚马逊（Amazon）进行竞争，Google 这次也是下了血本了。为了加快在全国范围内的扩张，Google 表示将“忍痛”放弃一部分业务，如部分生鲜和食品杂货的运送，以与已占先机的亚马逊 Prime 服务一较高下。
&nbsp;

（图片来自：TechCrunch）
&nbsp;
与亚马逊提供的海量商品不同，Google Express 目前合作的 50 多个商家均是经过“精挑细选”的，“我们挑选的商家都是人们真正喜欢的，他们会有种自己不是在网购的感觉。” 艾略特指出了 Google Express 的精品化战略。
与此同时，Google 还计划与第三方运输机构进行合作，以降低其运营成本。
&nbsp;
赶超亚马逊，道阻且长
&nbsp;
从 Google Express 上线以来，一直拿来与亚马逊旗下的 Prime 进行比较。但无论是从运输效率、价格竞争还是渠道铺设来看，Google Express 要走的路还很远。

运输效率—— Google Express 和 亚马逊 Prime 都支持最快当日送达。


 价格—— 尽管现在都是付费服务，Google Express 提供两种付费方式供消费者选择：95 美元的年费会员或者 4.99 美元起的单次付费；亚马逊则比较单一，需花费 99 美元订购 Prime 的年费会员才可获得当日送达服务。


 渠道——这一直以来是 Google 的短板，与亚马逊的直接供货渠道相比，Google Express 只能借助与传统经销商的合作完成货源供给。

&nbsp;

（图片来自：Bidness Etc）
&nbsp;
雪上加霜的是，一直引以为豪的访问流量优势也被亚马逊拿走了。
据彭博社报道，几乎将近一半的美国在线购物消费者选择在亚马逊网站或者移动客户端上直接搜索购物信息，这对于以搜索引擎作为核心业务又渴望在电商领域突围的的 Google 来说无疑是一个不好的信号。
可以预见的是，Google Express 这一波大招尽管炫目，但要狙击亚马逊还要多修炼。
题图来自：TechCrunch
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>185</docid>
    <url>http://www.ifanr.com/737354?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>柳青说滴滴要展开国际化扩张，但这是一件不容易的事</title>
    <content>
据新浪科技，滴滴出行总裁柳青在 WSJDLive 2016 全球科技大会表示，滴滴将向中国以外的市场扩张，夺取全球份额。在此过程中，滴滴有可能与一些国家的当地专车服务展开合作。
我们希望全球化。
与 Uber 直接在全球建立业务的全球化做法不同， 一直以来，滴滴更多的是通过投资入股海外的打车出行平台的方式形成自己的全球化布局。
例如说，滴滴与 Uber 中国合并后不久，就投资了东南亚地区最大出行软件 Grab。
但这不是滴滴第一次投资 Grab 了，也不是它第一次投资海外打车平台。2015 年 9 月，滴滴入股美国本土打车软件 Lyft 1 亿美元，之后又投资入股印度 Ola 3000 万美元。
这是滴滴在海外扩张至今采取的主要策略：曲线救国，通过投资进入其他海外市场。
除此之外，滴滴还通过打通产品线的做法进行扩张。
今年 4 月，滴滴还在美国上线了“滴滴海外”，用户可以用滴滴 app 呼叫到 Lyft 的汽车。值得一提的是，为方便中国用户使用，“滴滴海外”界面均为中文显示，整体叫车发单流程与国内保持一致。
与 Lyft 产品互通这一做法让滴滴在形式上直接进入了美国市场。
去年年底，滴滴、Lyft、Grab、Ola 四方曾宣布建立全球合作框架，这次合作除了能够为他们带来更多收益和更大的用户群体之外，全球无缝连接的服务也让他们具有和 Uber 一样的全球竞争力。

图自：Tech in Asia
这次四方合作也被视为形成了“全球反 Uber 联盟”。但这个联盟却在滴滴与 Uber 中国合并后陷入了尴尬甚至瓦解的境地。
Lyft 与 Uber 在美国市场的竞争已有很长时间，本来 Lyft 与滴滴合作，前者以为有了合作伙伴能一起对抗 Uber，但却没想到合作方转而又与竞争对手合作。Lyft 官方发言人 Alecandra LaManna 曾说：“我们将进一步评估与滴滴之间的伙伴关系。”
除了 Lyft，Grab 和 Ola 也得重新审视和思考自己和滴滴的合作得到哪个层面合适。外媒在对 Ola 相关人士采访时获知，Ola 仍坚持认为滴滴出行收购 Uber 中国不会给公司业务构成影响，因为滴滴只是 Ola 的小股东，且虽然 Ola 和滴滴出行有结盟关系，但好在尚未发布合作产品。
滴滴没有像 Uber 一样亲力亲为地去开拓疆土，而是通过与本土化的打车软件合作形成海外格局，但也由于复杂和不确定的合作关系，让自己的全球计划变得有些窘迫和尴尬。

图自：PitchBook
如今，滴滴柳青重新表示，滴滴正在评估应该进军哪些新市场，既有可能与当地现有的专车公司合作，也有可能与之竞争。如果滴滴认为当地的企业实力不够强大，便有可能与之竞争。
这是一场艰难的比赛，但我们乐在其中。
也就是说，滴滴可能不仅仅通过各种嫁接形式来进入海外市场，也将会采取和 Uber 相似的做法，直接进入当地市场提供打车服务。
当然，Uber 在进军国际市场时引起了不少争议和冲突，这也将是滴滴全球化进程里不得不面对的问题。
题图自：新浪科技
  
    

      
        
          陈 诗蔚 (chenshiwei)
          
          VR/AR/新兴媒介，工作邮箱：chenshiwei@ifanr.com
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>186</docid>
    <url>http://www.ifanr.com/737231?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>Uber 自动驾驶全球首秀：193 公里和 5 万罐啤酒的完美征途</title>
    <content>
今年 8 月被 Uber 以 6.8 亿美元收购的自动驾驶卡车公司 Otto ，终于在本月 20 日清晨，完成了全球首次自动驾驶卡车送货任务。
司机沃尔特‧马丁将这辆 18 轮卡车从柯林斯堡的啤酒厂开上 25 号州际公路后，打开了“接管”开关，卡车进入自动驾驶模式，他随即起身离开驾驶座，来到后座系好安全带闭目养神。

图片来自：视频截图
在无人干扰的情况下，Otto 的卡车自动行驶了 120 英里（约 193 公里）到达科罗拉多的斯普林斯，为安海斯-布希啤酒厂（Anheuser-Busch）运送了 5 万罐百威啤酒。
科罗拉多州运输部的官员参与了线路规划，并监督了自动驾驶的整个流程。卡车在行驶过程中，科罗拉多的巡逻队全程跟随。交货后，啤酒厂支付了 470 美元的运费。
卡车司机要失业了？
这并不是一次普通的测试，193 公里的路程意味着 Otto 自动驾驶系统已具有实际使用价值。
不同于特斯拉的 Autopilot 自动驾驶系统，Otto 的系统提供真正的“4 级”自主权，一旦进入州际公路，它便能完全接管驾驶，解放司机双手。
这一原理与飞机的自动驾驶类似：飞行员操纵飞机起飞到一定高度后开启自动驾驶仪，使飞机自动按指定的姿态、航向、高度和速度飞行，而飞行员则集中精力完成其它与飞行安全相关的工作。
不过司机们无需为此担心，Otto 的自动驾驶系统仅能用于高速公路，因为高速路的路况较为简单，不必避让行人、自行车或停靠在路边的车辆等。同时，它会让车辆保持安全的车距，并且只有当绝对有必要时才会变道。
而在到达目的地的最后几公里，由于进入到路况复杂的市区，还是需要切换到手动驾驶模式。

图片来自：The Verge
Otto 也表示他们的系统并不打算跟司机们抢饭碗，其联合创始人 Lior Ron 认为，在未来，司机的角色可能更像“港口引航员”，负责引导卡车到达目的地。
至少在可预见的未来，驾驶员仍然是自动驾驶中不可或缺的一员，但除了处理复杂道路情况外，他们也能做些其他事。“我觉得我得练习一下瑜伽。”马丁在采访中开玩笑说道。
卡车有望率先实现大规模自动驾驶

图片来自：The Verge
Otto 安装在测试卡车的自动驾驶装备并不复杂，包括位于驾驶室和拖车的 3 个激光雷达检测单元、一个连接到保险杠的雷达螺栓、一个位于挡风玻璃上方的高精度摄像头。车内还有两个红色按钮用于控制自动驾驶系统开关，一个靠近方向盘，另一个在座位后面的卧铺旁。
Otto 表示这些硬件适用于任何具有自动变速器的卡车，而他们的最终目标，无疑是想要实现美国 430 万卡车的自动化。
至于为何选择从卡车行业切入自动驾驶市场，Otto 自有其考量。
卡车运输占据了美国 70%的运费，每年运送货物达 105 亿吨。然而，卡车司机的数量却远远无法满足需求。美国卡车协会估计，当前卡车司机的缺口约为 4.8 万名，到了 2024 年，这一数字可能会扩大至 17.5 万。
Otto 的自动驾驶系统虽然不能完全取代司机，但无疑能提高运输效率，缓解日益短缺的卡车司机资源缺口。
更重要的是，自动驾驶技术还能进一步提高道路的安全性。

图片来自： MashableAsia
美国交通部数据显示，美国卡车年行驶里程占所有车型里程数的 5.6%，但事故率却高达 9.5％。每年约有 400 万起卡车交通事故，造成约 4000 人死亡，而几乎每一起事故都是人为因素造成的。
而在长途驾驶中，电脑往往人脑更为靠谱，因为电脑并不存在疲劳驾驶的情况。
此外，有研究表明，使用自动驾驶卡车可以使排放量降低 15% ，行驶 10 万英里可以节约 5000 英镑。
然而，Otto 自动驾驶硬件成本高达 3 万美元，在投入商用之前，还需要解决成本过高的问题。
目前，Otto 正在致力于提升自动驾驶系统的基本体验，比如让加速和制动过程更为平滑稳定，以及提高车道控制等。他们的长期目标还包括预测其他司机的可能行为、建筑区域导航、处理突发恶劣天气等危险。
题图来自：The Verge
  
    

      
        
          吴羚
          
          工作邮箱：wuling@ifanr.com
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>187</docid>
    <url>http://www.ifanr.com/737080?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>瑞典政府：只要带相机的无人机都不能飞！</title>
    <content>
摄像无人机 = 监控摄像头？这是瑞典最新法规给带摄像头的无人机所下的定义。
自无人机出现以来，有关于 “偷拍”、“窥视” 等词就一直跟在它的后面，无论在搜索引擎还是视频网站搜索都能有大量相关信息。由于无人机可以进行远程操控，飞离机主对他人进行拍摄。对于瑞典来说，这严重违反了他们的监视法。

图片来源：Drones Globe
因此在近日，瑞典法院裁定，将带摄像头的无人机列入禁用名单，除非是为了调查犯罪案件或事故，否则像是婚礼、新闻等需要使用无人机的活动都要申请许可证。
虽然这一法规可以有效保护个人隐私不被泄露，但却严重打击了瑞典正在蓬勃发展的无人机市场。据统计，仅 2015 年瑞典就售出了 2 万多台无人机，其中有 1000 多台都用于商业目的。

题图来源：PetaPixel
瑞典本土工商业组织就带头反对，他们不仅认为该法案过于严格，而且执行起来也相当困难。哪怕摄像无人机被禁止，其他类型的无人机却没有，所以执法机构将很难判断无人机是否在飞行时进行偷拍，也很难采集偷拍的证据。
也许瑞典在反对声音下可以考虑更改这一法案，毕竟 2014 年的时候他们还裁决摄像无人机合法可用。
瑞典可以学习一下友邻英国的无人机法案：
小型无人机（SUA）操作员必须保持时时刻刻能看见无人机，对无人机能够完全掌控，在飞行时为其他飞行器、人群、车辆以及建筑保持一定的空间以免发生碰撞事故。
配备相机的无人机不得在距离人群、车辆、建筑等 50 米内飞行，在拥挤的地段，无人机不得在距离拥挤物体 150 米以内的空间里飞行。
&nbsp;
题图来源：YouTube
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>188</docid>
    <url>http://www.ifanr.com/737136?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>苹果的汽车操作系统，可能是“黑莓出品”</title>
    <content>
据彭博（Bloomberg）最新报道，苹果安排了数十名软件工程师在其加拿大办公室里研发自动驾驶汽车操作系统，并且其中二十多位都是从黑莓（BlackBerry）QNX 公司挖过来的。
这些工程师现工作于苹果在渥太华市郊坎纳塔的办公室，离 QNX 办公室只有五分钟步行距离。坎纳塔办公室成立于今年年初，据说是苹果为了能够更好地吸纳当地自动驾驶软件人才的举措。

图片来自 TechCrunch
虽然 QNX 最为广为人知是建造车内娱乐系统，但其于去年就开始研发自动驾驶车辆软件了。苹果看似特别青睐黑莓 QNX 成员，不仅挖来了工程师，早于今年 7 月，已经聘请前黑莓 QNX 负责人 Dan Dodge 参与到苹果汽车项目 Project Titan 中，而另一位关键人物则是 QNX 前资深工程师 Derrick Keefe。
Dan Dodge（图片来自 investottawa.ca）
由于苹果不是在建造实体车，因此有传闻说他们已经开始用 VR 模拟测试自动驾驶平台了。该 VR 技术由另一 Project Titan 的小队研发而成，由 VR/AR 专家 Doug Bowman 带领。
虽然在过去的一年里， Project Titan 招来了很多“大人物”，但在上个月的时候，项目组经历一次大型裁员。该项目目前应该仍处于一个不太稳定的状态，并且工程师也面临着一个强硬的最后期限 —— 要在 2017 年秋季推出可行的自动驾驶操作系统。
题图来自：汽车科技
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>189</docid>
    <url>http://www.ifanr.com/737040?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>Google 光纤撂挑子了，超高速网络想说爱你不容易</title>
    <content>
&nbsp;
曾经羡慕嫉妒恨美国人可以使用比传统光纤快近 100 倍的 Google 光纤 （Google Fiber），此前为了升级服务， Google 光纤更是刚与高速无线网络服务商 Webpass 达成合作，现如今推出这一试验性服务的 Google 却表示撑不住了。
美国时间 10 月 25 日，Google 光纤宣布暂停其在十座“有潜力城市”的光纤拓展计划。
Google 光纤 CEO 克里格•巴瑞特（Craig•Barratt）在官方博客上发表文章称:
我们必须坚持不只是攻城掠地，更要稳固城池——不断扩展科技、商业、政策的边界——坚持做提供超高速网络服务的行业领导者。因此我们决定重塑我们的计划去达到这样的目标。我们必须做出改变去更加关注商业和产品体系。更为重要的是，这个计划将强化我们在新科技和资源调度方法的关注度，以此带来比今天更为丰富的超高速网络资源。
Google 光纤从 2011 年 3 月开始上线，目前该服务已经拓展至美国的 13 个城市地区，而此次关停的 10 座“有潜力城市”包括：达拉斯、杰克森维尔、洛杉矶、俄克拉荷马城、凤凰城、波特兰、圣何塞以及坦帕。
&nbsp;

（图片来自：Google Fiber Official Blog）
据 engadget 消息，此次关停并不会影响之前已铺设及确定上线 Google 光纤的城市，而此前处于公司“扩张版图”内的城市包括芝加哥、达拉斯、波特兰、坦帕以及圣迭戈，其继续 Google 光纤服务的前景不容乐观。
尽管巴瑞特指出 Google 光纤的服务订阅数以及营收在不断增长，但基于高额的光纤网络运营费用和未达标的订阅人数之间的矛盾，Google 可能会考虑暂缓其在物理光纤缆线方面的铺设。

（图片来自：Tech News Today）
此外有消息称，Google 光纤将同时裁减这些城市的员工，受影响人数近百分之九。
巴瑞特同样在博客文章中表达了自己离开 Google 光纤 CEO 职位的意愿，称其将继续担任顾问。
题图来自：VentureBeat
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>190</docid>
    <url>http://www.ifanr.com/736607?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>为了运送 88 包棉花，这两家银行用上了区块链和物联网</title>
    <content>
比特币的“激情不再”，让人们愈发不再通过各大“投机者斗兽场”去尝试暴富。这也让人们对于区块链愈发正视和乐于尝试。

图片来自 BusinessInsider
前天，澳洲联邦银行（CBA）、富国银行（Wells Fargo）就利用区块链、物联网进行了一次银行间贸易事物的试验，目的只有一个：验证区块链技术和物联网技术的实用性。
此次交易的双方实际上同属博瑞棉花（Brighann Cotton），只不过分别为美国部和澳大利亚部，交易的内容是将一批 88 包的棉花从美国的德克萨斯州运到中国的青岛。

图片来自 Skuchain
而他们使用的区块链技术是美国区块链公司 Skuchain 的 Brackets 系统，而在 Skuchain 上也有这套系统主要优势的简短介绍：

它能够促进金融家对常见的交易物如采购订单、发票、库存和付款约定进行贷款，同时允许贷款成为抵押资产，放款操作将会直接由真实世界中的事件触发。
它提供了一个实时可信的交易状态查看能力，这也大幅度的提升了交易中所有参与者的信息透明度，并且帮助他们建立更加强的相互信任，从而建立稳定的供应链生态。
它增强了市场中抵押资产的流动性，同时也大幅提升了常见的“贸易融资”工具，比如保理，融资 PO，供应商库存管理等。这同时也提供了进行更深层次金融的机会。

在这次交易中，这些特点也有所体现。原来交易中的大量的纸质信用证通过存储在私有分布式账本上的一个数字智能合约来执行。这份智能合约由计算机代码编写，一旦达到合约条件，交易就会自动执行。

图片来自 Wikipedia
而合约条件自然就是棉花到达目的地，博瑞棉花使用了一个 GPS 设备来追踪运输中货物的地理定位。一旦他们到达最终目的地青岛，智能合约就会自动放出资金。
澳洲联邦银行的现金流和交易服务处执行总经理 Michael Eidel 表示：
我们想要证明区块链、智能合约与物联网可以实现结合。从客户的角度看，三项技术的结合可以实实在在地带来令人兴奋、简单便捷和直接的用户体验。
通过这三项技术，原来需花费数日的人工处理程序如今可以在几分钟内完成，这就降低了成本，提高了效率。除此之外信息的透明度也有所上升，因为所有数据都在同一个私有分布式账本之上，并且数据还不可篡改，发生业务欺诈的可能心也大大减少。Eidel 还表示：
我们追求的并不是建立一个完全灵活的模型，而是开始真正使用一些非常重要的新技术，把各种技术结合起来并带来一个可行的良好用户体验。
下一步，他们打算拓展物联网部分——尝试将他们运用在保险行业中，提高对投保货物的监控。Eidel表示：
可以进行一个试验，添加一些传感器来测试湿度和温度是否超出范围。然后对这些条件进行编码的智能合约就会发出通知，告知保险公司货物可能已经损坏。
用这种方法，在出现一些失误情况时会变得十分有用，因为这些设备可以准确展示什么时候发生了事故，事故当时的货物所有权归谁所有。
从技术的角度来看，这一次尝试想要推广开来还将面对各种各样的困难，但是很明显，各种各样的测试必然会成为区块链接下来发展的一个重要阶段。尤其是对于很多只利用部分特性的应用场景，能否真得对现有模式形成冲击，也只有试过才知道。
题图来自 Myrugshop
  
    

      
        
          李 赓
          
          鲜衣怒马少年。
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>191</docid>
    <url>http://www.ifanr.com/737087?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>刚拿到 5000 万美元的 Hyperloop One，打算再融资 2.5 亿美元</title>
    <content>
尽管 Hyperloop One 刚在本月中旬拿到了 5000 万美元融资，但他们将在明年初启动新一轮融资，这一次的目标是 2.5 亿美元。
《福布斯》最先爆出这一消息，他们声称获得了该公司的一份融资文件，并透露 Hyperloop One 目前的项目经费预算已经超出了提出这一概念的马斯克当初的估计。这份文件的真实性已经得到了其 CEO 罗博·洛依德(Rob Lloyd) 的证实。

图片来自：Forbes
Hyperloop One 自成立以来，筹集的资金已达 1.6 亿美元。Hyperloop One 计划在 2020 年建成货物运输系统以及 2021 年完成乘客输送系统，但《福布斯》获得的文件显示，这两个项目的成本与预期有很大出入。
马斯克在 2013 年提交的白皮书中，预计从洛杉矶到湾区的 Hyperloop 线路成本只需要 60 亿美元，即每英里不超过 1150 万，远低于高铁。
然而，Hyperloop One 在 7 月和 10 月提交给潜在投资者和地产开发商的报告却显示，许多项目的成本比“钢铁侠”预估的要高得多，比如一条长为 107 英里的环湾区隧道或隧道+高架轨道组合，花费就将达到 90 亿至 130 亿美元，即每英里成本为 8400 万至 1.21 亿美元。

图片来自：Time
此外，在上一轮融资中，Hyperloop One 透露他们打算在迪拜的杰贝阿里港建设超级高铁运输系统，这条从迪拜到阿布扎比的线路长达 93 英里，预计成本为 48 亿美元。
也就是说，在 Hyperloop One 第一期总计长达 520 英里的超级高铁项目中，成本预算达到了 640 亿美元。
尽管 Hyperloop One 一直强调一旦项目上马，利润将相当可观，单个项目至少也有 35% 的利润率，到 2030 年可能会更高。但 Hyperloop One 至今仍只是一个原型产品，公司在自身发展和证明概念的可行性上耗资巨大。
这也是为什么在短短两年内，虽然手握 1.6 亿美元投资，Hyperloop One 却仍在继续寻求融资的原因。
融资文件表明， Hyperloop One 已经开始在以每年 5% 的收益与 15%的 C 轮最终股价折让，向投资者提供额外的可换股票据。一些风投专家认为这可能表明该公司正在进行大量现金积累，用于 Pishevar（创始人）所说的“资本密集型业务”。
对于 Hyperloop One 画的大饼，很多人始终持怀疑态度，而 Hyperloop One 一直也是麻烦不断，比如与其联合创始人布罗根·班布罗根（BroganBamBrogan）之间的官司及内讧等。但外界依然认为，Hyperloop One 是最有可能实现“超级高铁”这一设想的公司。
题图来自：Tech Crunch
  
    

      
        
          吴羚
          
          工作邮箱：wuling@ifanr.com
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>192</docid>
    <url>http://www.ifanr.com/737013?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>词错率降低至 5.9%，微软今日发布用于语音识别技术的“认知工具包”</title>
    <content>
一个月前，微软的对话语音识别技术在产业标准 Switchboard 语音识别基准测试中实现了词错率（word error rate, 简称 WER）低至 6.3% 的突破 ，创造当时该领域内错误率最低纪录。
近期，微软进一步将词错率降低至 5.9%，首次达成与专业速记员持平而优于绝大多数人的表现。
微软的语音识别技术可以一次又一次刷新纪录，在很大程度上要归功于 CNTK (Computational Network Toolkit) 这个开源工具。
该系统最初是为了研究语音应用而建立，后来拓展发展成为微软本地化深度学习系统。CNTK 工具包已于一年前在 GitHub 上开源，目前包括微软人工智能个人助理小娜和 HoloLens 的语音识别都是基于 CNTK 实现的。CNTK 跟其他开源软件最大的区别是它能做大规模、分布式的机器学习，同时保证强大的性能。
今天，该工具包进行了更新，新增一个被称为“认知工具包”的测试版。
针对语音识别的研究可以追溯到上个世纪七十年代 DARPA（Defense Advanced Research Projects Agency，美国国防部先进研究项目局，主要致力于美国国防高新技术的研究、开发和应用）资助的一个相关项目。此后几十年，越来越多研究机构和大型公司陆续加入其中。
“这次突破是过去二十多年语音识别技术不断积累的结果，”微软主管语言及对话研究组的研究员 Geoffrey Zweig 称。

现在微软达到的 5.9% 的词错率是什么概念？
在行业标准 Switchboard 语音识别任务测试中，人类对照组（由专业速记员组成）将对话语音转录成文字，目前有记录的最低词错率就是 5.9%，这就意味着微软的语音识别系统的语音识别能力已经高于世界上绝大多数人而与人类专业高手持平，创造了一项新的世界纪录。
此次语音识别的里程碑式突破将对消费者和商业产品产生深远影响，因为语音识别技术能够显著增强人们的日常计算体验。这些产品包括像 XBOX 的娱乐设备、像微软小娜（Cortana）的生产力工具以及能实现实时语音到文本转录的个人人工智能助手。
微软团队的词错率虽然实现了与人类专业速记员持平的 5.9%，但这并不代表计算机就能完美识别出每一个单词。如果哪天计算机能完美识别“蓝瘦”、“香菇”，那语音识别技术又将达到一个新的高度。
  
    

      
        
          陈 诗蔚 (chenshiwei)
          
          VR/AR/新兴媒介，工作邮箱：chenshiwei@ifanr.com
        
      
    
    
      
                                邮箱

          
                
    
  
  #欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>193</docid>
    <url>http://www.ifanr.com/736513?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>美国《消费者报告》汽车可靠性排名出炉，特斯拉沦为垫底之一</title>
    <content>
以权威性著称的《消费者报告》（Consumer Reports，CR）最新发布了《2017 年车辆品牌可靠性调查报告》。
这份调查报告采用给读者发放问卷的形式，调查读者自己驾驶的车辆在过去 12 个月内出现的故障和质量问题，并且派专人在指定道路对车辆进行试驾，再加上安全性数据。综合统计调查结果后，依据车型可靠性分数来预测出品牌平均分数。
今年，CR 共收集了超过 50 万辆车的数据，涵盖了从 2000 年到 2016 年的 300 多个车型，还有 2017 年初的几个车型，以下是品牌排名：

表现依旧优异
在 CR 的分析报告中，使用了 “不足为奇” 这一词来形容排在榜单一、二位的雷克萨斯和丰田。它们以一贯优异的表现继续留在了榜首，CR 还称赞其造车模式已相当稳定。
同时，在十大可靠车型报告中，丰田普锐斯、4Runner 车型和雷克萨斯 CT 200h、GX、GS 车型均有上榜，两家就已经占比一半。

图片来源：Motor Trend
紧随其后的别克由于其核心产品线成熟，车辆的大多数问题也已经解决，同时别克推出的几款新车也相当亮眼，可能对未来的品牌表现产生影响。今年别克生产线还进行了调整，将 SUV 的产量下调，轿车占比更多。
都是 Model X 惹的祸
排在末尾的几家品牌中，第一次上榜的特斯拉特别显眼。这是由于在去年年底发布的 2016 年最佳车型中，CR 给予了特斯拉 Model S 的两款车型超过 100 分的超高评分。这在当时相当轰动，因为这是 CR 所给予过的最高评分。
对于 Model S 《消费者报告》给予的评价是：
Model S P85D 具有里程碑式的意义。
虽然 Model S 表现优异，却也难以补上 Model X 的大窟窿。
看了标题的你，可能以为给特斯拉背锅的会是他们的自动驾驶系统，然而 Model X 车型的硬件隐患更多。从灵敏传感器误判到漏雨，再到鹰翼门故障，系统升级后又再次故障…… 这一系列的问题让车主不胜其烦。
（爱范儿（微信号：ifanr）曾经报道过《用 8 万美元的 Tesla Model X“鹰翼门” 切黄瓜？这并不是玩笑》）

图片来源：YouTube
因此 Model X 也被 CR 列入了今年排名最低的 10 款车型之一。
 有起有落
与 2016 年的汽车品牌可靠度排名相比，英菲尼迪完成了一次逆袭。从 24 名到第 8 名，足足上升了 16 个名次，除了看好他们发布的几款新车，CR 也把 Q70 车型列入了十大可靠性车辆，从而拉动了品牌平均分，CR 评价到：
Q70 操作相当敏捷，转向和行驶稳定，后排宽敞的 L 型座椅十分舒适，并且和同类车辆比价格更为优惠。

图片来源：Motor Trend
反观跌幅中最为意外的，是一向 “稳重” 的本田，这次它跌出了最可靠品牌的名单，在这方面可谓是第二个“特斯拉”。本田思域的问题接连不断，断轴隐患、引擎故障、电子系统故障…… 停售、召回一系列风波使这个可靠的日系品牌丧失了一大批忠实顾客。
电子化系统
关于品牌榜单，CR 调查了十几个车辆可能存在不足的方面，包括嘈杂的制动器、糟糕的内饰、主要保险杠的损坏，还有保修期外变速器维修或四轮驱动系统的故障……

图片来源：YouTube
大部分品牌的下跌，都是因为自己某一款车型出现了非常严重的问题。并且由于近年来，汽车厂商大量加入复杂的电子化操作系统，而系统故障导致的差评也存在很多。
鉴于这是一份纵观行业的榜单，而如果消费者需要依据榜单选购车辆，那么车型可靠性榜单可能会更加有参考性。

&nbsp;
题图来源：Wired
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>194</docid>
    <url>http://www.ifanr.com/737015?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>几乎确认：新款 MacBook Pro 将搭配 OLED 触控按键和 Touch ID</title>
    <content>
当地时间 10 月 27 日苹果新品发布会的看点，已经没有悬念地落在了新款 MacBook Pro 的身上；而且这一次，人们不仅需要一款新产品，还需要一个新设计。

据外媒 MacRumors 报道，在最新发布的 macOS Sierra 10.12.1 版本中，有一张关于在 MacBook 电脑上使用 Apple Pay 的图片。而在这种图片中，一款标有 MacBook Pro 的产品赫然出现，而且它的键盘上方拥有一个黑色长条，这个长条取代了现有的一排按键。

图片显示，这台 MacBook Pro 正在请求用户确认是否使用 Apple Pay；长条上同时显示了一些内容，这些内容是在提示用户将手指按在长条最右侧的一个模块来使用 Apple Pay。
从这些细节来看，几乎可以确认，这个长条就是一个能够显示不同内容的 OLED 可触控屏幕，而长条右侧则配置了一个可以进行指纹识别的 Touch ID 模块。
根据此前的消息，这块 OLED 屏幕将可能被命名为“Magic Toolbar”。
另外还有一张细节图，可以隐约看到在 OLED 屏幕的右侧，有一个相对独立的模块；二者从视觉上几乎是一体的，但细看依然能分辨出来。

注意细看 OLED 长条右侧
关于上述内容的真实性，还可以从此前新款 MacBook Pro 的泄露图中得到佐证。
今年五六月份，一组关于新款 MacBook Pro 外壳的泄露图曝光。其中一张泄露图显示，在键盘上方的确取消了一排实体功能键，留出了给 OLED 屏的空间；此空间右侧有一个小的相对独立模块，可以用来放置 Touch ID 模块。

这张泄露图所展示的信息，与我们目前所看到的新款 MacBook Pro 设计完全相符合。
另外，从这组泄露图中也能看到关于新款 MacBook Pro 在外观上的其他设计。比如说，机身两侧将会有 4 个 USB Type-C 接口和一个 3.5 毫米耳机接口；而 SD 卡槽、HDMI 接口和 MagSafe 接口将会被取消。

关于新款 MacBook Pro 的相关配置预测，可以参见爱范儿（微信 ID：ifanr）此前的文章。不过正如文章所言：
这次新的 MacBook Pro 真的不需要期待，你所需要做的只有存钱和买。
另外，爱范儿（微信 ID:ifanr）目前也已经受邀参加此次苹果新品发布会，届时我们将第一时间带来新款 MacBook Pro 的相关信息，敬请关注。
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>195</docid>
    <url>http://www.ifanr.com/736986?utm_source=rss&utm_medium=rss&utm_campaign=</url>
    <title>对话网约车：外地司机的愤怒，京籍司机的尴尬</title>
    <content>
整理 | 崔神
与我一同坐在直播间里的，是三位西服笔挺、皮鞋锃亮的网约车师傅，他们都是模范专车司机。这与我们上次在街上抓的形色各异的网约车司机看上去很不一样。
之前我在问领英要这些师傅介绍的时候，对方扔过来的是网上对他们的新闻报道。所以真聊起来，感觉他们显然对采访这事儿并不陌生。他们的观点表述没有那么凌厉，却有另一种独特。
三位网约车师傅：

边师傅 户籍燕郊 京牌车 做网约车 1 年多
王师傅 户籍河南 公司车 做网约车 1 年多
张师傅 户籍北京 京牌车 做网约车 1 年半


壹
博望志：新政关于网约车的排量和轴距要求，会带来哪些影响？
张师傅：排量的 T 是个关键问题，我感觉现在德系车一般带 T 的多一些，你像日系车就不带 T，它就是 1.8，这就非常尴尬。
滴滴专车现在主要路上跑的，有几项大车，天籁、本田雅阁、帕萨特、凯美瑞，那毫无疑问帕萨特是大众的车，一般都是 1.8T 以上的。
那凯美瑞、本田雅阁包括天籁，它没有带 T 的，要么就 2.0，要么就 1.8。但是一般我们拉活儿的人都会买 1.8 的，终归要省油，成本减少了。一旦出台 1.8T，那可以想象一下……
所以我不太赞成这个 1.8T。因为轴距我认为差不多都能达到，因为专车属于 B 级车，它都会这样设计，就是这个 T 我觉得比较敏感一点。
边师傅：我觉得排量这个出来以后，限制了很多快车，快车这部分消费群体很大，他们觉得我只想把它作为代步工具，我就是从 A 点到 B 点，你把我带到那就行了，我就是这个要求。
但是我不想花太多钱，因为我工资没那么高，只想作为代步工具，他这样直接就把这么大一部分的消费群体给砍掉了。有这个 T 以后肯定都要 B 级车以上，这对普通老百姓来说是不公平的。
对于赚钱多的人没影响，我就打专车嘛，本身我也想舒适一些，对于我挣钱少的人，我就没办法了。所以对这个群体是有影响的。
这对老百姓来说是不利的，还有就是本身也不环保。排量越大肯定污染越多嘛，那还用说啊。那就违背了国家提倡的这个绿色出行，那你要那么大的排量，肯定污染就会多。
博望志：现在买新车也是 1.6 以下的购置税低？
边师傅：对呀，这就是为了绿色出行，所以才有补贴的。那前面说补贴鼓励大家买小排量的，这样减少环境污染，结果后边出这个政策，这个（1.8T 以下小排量）不能干（网约车）。这本身就跟大的政策、大方向相违背了。
王师傅：我觉得新政一出来，大部分车就不能干网约车了，专车有一部分，快车就更别提了。你想国内自主品牌的国产车，可能有一半以上都做不了网约车了。
把咱们民族产业就给打压下去了。我前两天查了一下资料，奥迪 A3 和宝马 3 系都够不了这个标准，更何况国产车了，更做不了了，轴距达不到。
排量国家倡导新能源和环保，都出 1.4 和 1.6 的。我觉得其实只要是合乎国家标准出厂的车辆，应该都能在路上运行。一个是干净整洁，服务质量跟得上，符合大众的出行就可以了。对国家发展经济，拉动内需，都有利嘛。
张师傅：我也有个观点，专车跟快车肯定有区别之分，专车就是要高端，因为价位是不一样的，所以要求车的档次也是不一样的。
应该是两个政策，细分化，快车有快车的政策，有不同需求的人，坐不一样的车。一刀切车就少了，大家的出行费用就增加了。就会出现车挑人了，不是人挑车了。我肯定选哪个活儿大挑哪个，就跟以前出租车一样了。

贰
博望志：关于户籍的问题，大家有什么想说的？
王师傅：我认为是歧视外地人，我首先就受到影响了，我就不能工作了。我认为我已经融入这个城市了，已经有感情了，对这个城市也做出了很多贡献。
保险啊，纳税啊该做的都做了，就是缺了一纸户口。我在北京也 10 多年了，我自认我比北京有的司机也不差。
张师傅：我对京籍还是挺赞同的，主要是北京实在是太拥堵了。如果把外地车都砍掉，我觉得北京也会缓解压力。再加上如果自私地说的话，我们的收入更有保障了。
关于京牌我觉得这个可以推给滴滴公司，它自己应该有一些车辆。滴滴应该有些自营的车辆，滴滴可以招聘司机，司机打工有个合理的工资定价，这也是解决问题的办法。
边师傅：京牌对于我来说我是赞成的，因为本身你就是在北京的路面上跑，如果不是京牌的话，他所有的档案全在外地，北京的交管部门什么都没有，存在安全隐患问题。所以京牌还是应该限的，要不然北京本身就很拥堵了。
我听说确实有一些村里的几个小伙子，家里有车，一想北京活儿多，拉滴滴能挣钱。从外地基本都是张家口或者河北周边的，说周一一大早开着车来北京了，然后天天拉，也不租房，困了累了就睡车里，睡几个小时起来再接着跑，到周六的时候开回去。
回家休息两天，周一又回来了。这肯定是增加了北京路面的交通拥堵，肯定是疲劳驾驶，这么干肯定存在危险，他不光是对自己安全不负责任，对别人，对乘客和别的车带来危险。
户籍的话限制有点苛刻了，像我就是外地户籍司机，我就是燕郊的，我依然会在北京生活，依然在北京工作，人还是在北京。因为我的家整个都在北京，顶多我换一个行业，难道我就不在北京了么？减少北京的人口了么？
互联网 + 的时代，是共享经济的时代，是为了把像我这样的，我自己的车本身自己闲着也是闲着。
其实我就是不拉网约车，我的车依然是在北京路上跑，就是把这些闲置的车给利用起来，改善大家的出行。所以如果把这块限制起来的话，对改善整个北京的出行是不利的。
据我了解很多公司的老板和上班族，他们现在已经习惯于用网约车了。因为用网约车很方便，不用我自己开车。
他们可以在车上完成很多办公，在去公司的路上接电话，安排工作上的事儿。他自己不开车了，也减少了路上的车辆，从这点上，是可以缓解北京交通压力的。
我遇到过坐我车的乘客跟我说，突然觉得我们家的车没用了，上班打滴滴挺好，又方便还省钱。自己不用开车，因为到公司楼下，像国贸地区，又堵车停车又贵。
我原来在国贸招商局大厦，停车第一小时 10 块，第二小时起每小时 15，一天停车费 100 多。有这钱完全够打车的了。互联网 + 是很好的方式，把大家的车利用起来，其实也减少了很多人开车了。
这个政策如果限制得很严，路上的网约车一定会少，他们打不着车的情况下，肯定又开始开自己的车了，这样对北京的发展是不利的。
叁
博望志：如果政策落地，下一步有什么打算？
王师傅：如果政策落地的话，第一我在（滴滴）公司肯定是干不了了。但我个人有车，我是京牌的车呀，你说我在北京干不了，我是回老家干？
回老家干我是京牌车，如果老家也限制外地车的话。因为北京出台的政策，外地是效仿的，包括限购啊、摇号啊各地不是都效仿么。
我要开着北京的车回去也不能干对吧？这样的话我就处于尴尬的状态了。车是北京的牌，人是外地的户口，回到原籍也被限呢？
更多访谈内容：语音
&nbsp;
题图来源：South China Morning Post
#欢迎关注爱范儿认证微信公众号：AppSolution（微信号：appsolution），发现新酷精华应用。
爱范儿 |
原文链接 ·
查看评论 ·
新浪微博




 </content>
</doc><doc>
    <docid>207</docid>
    <url>https://coolshell.cn/articles/18094.html</url>
    <title>如何免费的让网站启用HTTPS</title>
    <content>今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。
我用的是 Let&#8217;s Encrypt这个免费的解决方案。Let&#8217;s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由互联网安全研究小组（ISRG &#8211; Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及Cisco等公司（赞助商列表）。
2015年6月，Let&#8217;s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let&#8217;s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。

以上介绍文字来自 Wikipedia 的 Let&#8217;s Encrypt 词条。
为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 Certbot，就可以完成。
1）首先，打开 https://certbot.eff.org 网页。
2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的，nginx 和 Ubuntu 14.04
3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。
以Coolshell.cn为例 &#8211; Nginx + Ubuntu
首先先安装相应的环境：

$ sudo apt-get update
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:certbot/certbot
$ sudo apt-get update
$ sudo apt-get install python-certbot-nginx

然后，运行如下命令：

$ sudo certbot --nginx

certbot 会自动检查到你的 nginx.conf 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 nginx.conf 了。
你打开你的 nginx.conf 文件 ，你可以发现你的文件中的 server 配置中可能被做了如下的修改：
listen 443 ssl; # managed by Certbot
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
和
 # Redirect non-https traffic to https
if ($scheme != &quot;https&quot;) {
  return 301 https://$host$request_uri;
} # managed by Certbot
&nbsp;
这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（关于性能你可以看一下这篇文章）。需要开启HTTP/2其实很简单，只需要在 nginx.conf 的 listen 443 ssl; 后面加上 http2 就好了。如下所示：
listen 443 ssl http2; # managed by Certbot 
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot 
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot 
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
然后，就 nginx -s reload 就好了。
但是，Let&#8217;s Encrypt 的证书90天就过期了，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 crontab 了。使用 crontab -e 命令加入如下的定时作业（每个月都强制更新一下）：
0 0 1 * * /usr/bin/certbot renew --force-renewal
5 0 1 * * /usr/sbin/service nginx restart
当然，你也可以每天凌晨1点检查一下：
0 1 * * * certbot renew 
注：crontab 中有六个字段，其含义如下：

第1个字段：分钟 (0-59)
第2个字段：小时 (0-23)
第3个字段：日期 (1-31)
第4个字段：月份 (1-12 [12 代表 December])
第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天])
/path/to/command &#8211; 计划执行的脚本或命令的名称

这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……
当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。
启用HTTPS后，你的网页中的所有的使用 http:// 的方式的地方都要改成 https:// 不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉。所以，你还需要修改你的网页中那些 hard code http:// 的地方。
对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。
1）首先是 wordpress的 常规设置中的 “WordPress 地址” 和 “站点地址” 需要变更为 https 的方式。
2）然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “Search Regex” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 http://coolshell.cn 替换成了 https://coolshell.cn
3）如果你像我一样启用了文章缓存（我用的是WP-SuperCache插件），你还要去设置一下 “CDN” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。
基本上就是这些事。希望大家都来把自己的网站更新成 https 的。
嗯，12306，你什么时候按照这个教程做一下你的证书？
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章从“黑掉Github”学Web安全开发关于移动端的钓鱼式攻击HTTP API 认证授权术你会做Web上的用户登录功能吗？Web工程师的工具箱bash代码注入的安全漏洞
</content>
</doc><doc>
    <docid>211</docid>
    <url>https://coolshell.cn/articles/19464.html</url>
    <title>如何超过大多数人</title>
    <content>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！
P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿
相关技巧和最佳实践
要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。
在信息获取上，你要不断地向大众鼓吹下面的这些事：

让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。
让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。
把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。
让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……
利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。

然后，在知识学习和技能训练上，让他们不得要领并产生幻觉

让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……
培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……
不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……
让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……
玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……
让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……
告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……
让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……
让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……

最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。

让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……
宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……
告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……
多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……
多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……
让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……
让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……
告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……
当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）
告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……
每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……

最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。
相关原理和思维模型
对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。
一般来说，超过别人一般来说就是两个维度：

在认知、知识和技能上。这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》）
在领导力上。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》）

首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。
认知
要在认知上超过别人，就要在下面几个方面上做足功夫：
1）信息渠道。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）
2）信息质量。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。
3）信息密度。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章。
知识
要在知识上超过别人，你就需要在下面几个方面上做足功夫：
1）知识树（图）。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！
2）知识缘由。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。
3）方法套路。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。
技能
要在技能上超过别人，你就需要在下面几个方面做足功夫：
1）精益求精。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。
2）让自己犯错。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！
3）找高手切磋。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！
领导力
最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。
1）识别自己的特长和天赋。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。
2）识别自己的兴趣和事业。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。
3）建立高级的习惯和方法。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。
4）勤奋努力执着坚持。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。
好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章技术人员的发展之路什么是工程师文化？这多年来我一直在钻研的技术关于高可用的系统「我只是认真」聊聊工匠情怀互联网之子 &#8211; Aaron Swartz
</content>
</doc><doc>
    <docid>212</docid>
    <url>https://coolshell.cn/articles/19395.html</url>
    <title>HTTP API 认证授权术</title>
    <content>我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。
但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。注意，这是一篇长文！
本篇文章会覆盖如下技术：

HTTP Basic
Digest Access
App Secret Key + HMAC
JWT &#8211; JSON Web Tokens
OAuth 1.0 &#8211; 3 legged &amp; 2 legged
OAuth 2.0 &#8211; Authentication Code &amp; Client Credential


HTTP Basic
HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication
其技术原理如下：

把 username和 password 做成  username:password 的样子（用冒号分隔）
进行Base64编码。Base64("username:password") 得到一个字符串（如：把 haoel:coolshell 进行base64 后可以得到 aGFvZW86Y29vbHNoZWxsCg ）
把 aGFvZW86Y29vbHNoZWxsCg放到HTTP头中 Authorization 字段中，形成 Authorization: Basic aGFvZW86Y29vbHNoZWxsCg，然后发送到服务端。
服务端如果没有在头里看到认证字段，则返回401错，以及一个个WWW-Authenticate: Basic Realm='HelloWorld' 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。

我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 JIRA Cloud 的API认证支持HTTP Basic 这样的方式。
但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。
Digest Access
中文称“HTTP 摘要认证”，最初被定义在了 RFC 2069 文档中（后来被 RFC 2617 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。
其基本思路是，请求方把用户名口令和域做一个MD5 &#8211;  MD5(username:realm:password) 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 nonce 另一个是 qop

首先，调用方发起一个普通的HTTP请求。比如：GET /coolshell/admin/ HTTP/1.1
服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 WWW-Authenticate 包含如下信息：

 WWW-Authenticate: Digest realm="testrealm@host.com",
                        qop="auth,auth-int",
                        nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                        opaque="5ccc069c403ebaf9f0171e9517f40e41"

其中的 nonce 为服务器端生成的随机数，然后，客户端做 HASH1=MD5(MD5(username:realm:password):nonce:cnonce) ，其中的 cnonce 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。
如果 qop 中包含了 auth ，那么还得做  HASH2=MD5(method:digestURI) 其中的 method 就是HTTP的请求方法（GET/POST&#8230;），digestURI 是请求的URL。
如果 qop 中包含了 auth-init ，那么，得做  HASH2=MD5(method:digestURI:MD5(entityBody)) 其中的 entityBody 就是HTTP请求的整个数据体。
然后，得到 response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2) 如果没有 qop则 response = MD5(HA1:nonce:HA2)
最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 Authorization: Digest ...

GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username="Mufasa",
                     realm="testrealm@host.com",
                     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                     uri="%2Fcoolshell%2Fadmin",
                     qop=auth,
                     nc=00000001,
                     cnonce="0a4f113b",
                     response="6629fae49393a05397450978507c4ef1",
                     opaque="5ccc069c403ebaf9f0171e9517f40e41"
维基百科上的 Wikipedia: Digest access authentication 词条非常详细地描述了这个细节。
摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是，别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。
App Secret Key + HMAC
先说HMAC技术，这个东西来自于MAC &#8211; Message Authentication Code，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC &#8211; Hash-based Authenticsation Code，指的是利用Hash技术完成这一工作，比如：SHA-256算法。
&nbsp;

（图片来自 Wikipedia &#8211; MAC 词条 ）
我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。
把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过S3的API请求签名文档看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤：

把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 CanonicalRequest，作个SHA-256的签名，然后再做一个base16的编码
把上面的这个签名和签名算法 AWS4-HMAC-SHA256、时间戳、Scop，再打一个包，叫 StringToSign。
准备签名，用 AWSSecretAccessKey来对日期签一个 DataKey，再用 DataKey 对要操作的Region签一个 DataRegionKey ，再对相关的服务签一个DataRegionServiceKey ，最后得到 SigningKey.
用第三步的 SigningKey来对第二步的 StringToSign 签名。


&nbsp;
最后，发出HTTP Request时，在HTTP头的 Authorization字段中放入如下的信息：
Authorization: AWS4-HMAC-SHA256 
               Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, 
               SignedHeaders=content-type;host;x-amz-date, 
               Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7

&nbsp;
其中的  AKIDEXAMPLE 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《Amazon S3 Rest API with curl》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。
这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： Acquia 的 HMAC，微信的签名算法 （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 Authorization 里，而是放在body里）
JWT &#8211; JSON Web Tokens
JWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（Message Authentication Code）的方法。JWT的签名流程一般是下面这个样子：

用户使用用户名和口令到认证服务器上请求认证。
认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下：

认证服务器还会生成一个 Secret Key（密钥）
对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。
用密钥对JWT签名 HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+'.'+Base64UrlEncode(JWT-Payload));


然后把 base64(header).base64(payload).signature 作为 JWT token返回客户端。
客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。

当应用服务器收到请求后：

应用服务会检查 JWT  Token，确认签名是正确的。
然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。
认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。
认证服务器检查通过后，应用服务就可以认为这是合法请求了。

我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC-SHA256的算法外，还支持RSA的非对称加密的算法。
使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。
最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。
这里强烈建议全文阅读 Anglar 大学的 《JSW：The Complete Guide to JSON Web Tokens》
OAuth 1.0
OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：RFC 5849 （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 OAuth Core 1.0 Revision A ，我在下面做个大概的描述。
根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。

这个协议有三个角色：

User（照片所有者-用户）
Consumer（第三方照片打印服务）
Service Provider（照片存储服务）


这个协义有三个阶段：

Consumer获取Request Token
Service Provider 认证用户并授权Consumer
Consumer获取Access Token调用API访问用户的照片



整个授权过程是这样的：

Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret
当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）
Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）
Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。
Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （oauth_token）和 Verification Code（oauth_verifier）
接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)
最后使用Access Token 访问用户授权访问的资源。

下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。

因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示：

Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret
Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）
Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）
Consumer 收到 Request Token 后，直接换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)
最后使用Access Token 访问用户授权访问的资源。

最后，再来说一说OAuth中的签名。

我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。
签名密钥就是由这两具密钥拼接而成的，其中用 &amp;作连接符。假设 Consumer Secret 为 j49sk3j29djd 而 Token Secret 为dh893hdasih9那个，签名密钥为：j49sk3j29djd&amp;dh893hdasih9
在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如：

Consumer Key ： 也就是所谓的AppID
Token： Request Token 或 Access Token
Signature Method ：签名算法比如：HMAC-SHA1
Timestamp：过期时间
Nonce：随机字符串
Call Back：回调URL



下图是整个签名的示意图：

图片还是比较直观的，我就不多解释了。
OAuth 2.0
在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求，这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。
这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 RFC 6749 正式放出。
OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的。目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。
下面，我们来重点看一下OAuth 2.0的两个主要的Flow：

一个是Authorization Code Flow， 这个是 3 legged 的
一个是Client Credential Flow，这个是 2 legged 的。

Authorization Code Flow
Authorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。

&nbsp;
下面是对这个流程的一个细节上的解释：
1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 /authorize API，其中的请求方式如下所示。
https://login.authorization-server.com/authorize?
        client_id=6731de76-14a6-49ae-97bc-6eba6914391e
        &amp;response_type=code
        &amp;redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F
        &amp;scope=read
        &amp;state=xcoiv98CoolShell3kch
其中：



client_id为第三方应用的App ID
response_type=code为告诉认证服务器，我要走Authorization Code Flow。
redirect_uri意思是我跳转回第三方应用的URL
scope意是相关的权限
state 是一个随机的字符串，主要用于防CSRF攻击。



2）当Authorization Server收到这个URL请求后，其会通过 client_id来检查 redirect_uri和 scope是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。
3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示：
https://example-client.com/callback?
        code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
        &amp;state=xcoiv98CoolShell3kch
我们可以看到，



请流动的链接是第 1）步中的 redirect_uri
其中的 state 的值也和第 1）步的 state一样。



4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。
POST /oauth/token HTTP/1.1
Host: authorization-server.com
 
code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&amp;grant_type=code
&amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F
&amp;client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&amp;client_secret=JqQX2PNo9bpM0uEihUPzyrh
5）如果没什么问题，Authorization 会返回如下信息。
{
  "access_token": "iJKV1QiLCJhbGciOiJSUzI1NiI",
  "refresh_token": "1KaPlrEqdFSBzjqfTGAMxZGU",
  "token_type": "bearer",
  "expires": 3600,
  "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM..."
}
其中，



access_token就是访问请求令牌了
refresh_token用于刷新 access_token
id_token 是JWT的token，其中一般会包含用户的OpenID



6）接下来就是用 Access Token 请求用户的资源了。
GET /v1/user/pictures
Host: https://example.resource.com

Authorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI
&nbsp;
 Client Credential Flow
Client Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。

这个过程非常简单，本质上就是Client用自己的 client_id和 client_secret向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。
请求示例
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&amp;client_id=czZCaGRSa3F0Mzpn
&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
返回示例
{
  "access_token":"MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk",
  "scope":"create"
}
这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“微信公众号获取access token”），我截了个图如下所谓。我们可以看到，微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret……

&nbsp;
小结
讲了这么多，我们来小结一下（下面的小结可能会有点散）
两个概念和三个术语

区分两个概念：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。
区分三个概念：编码Base64Encode、签名HMAC、加密RSA。编码是为了更的传输，等同于明文，签名是为了信息不能被篡改，加密是为了不让别人看到是什么信息。

明白一些初衷

使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。
JWT把 uid 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。
OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。
用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。
OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。

相关的注意事项

无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 Authorization HTTP 头中。
不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。
密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。
HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。
最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。
使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。
密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。
认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。

(全文完)

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章从“黑掉Github”学Web安全开发如何免费的让网站启用HTTPS关于移动端的钓鱼式攻击从 MongoDB “赎金事件” 看安全问题C语言的整型溢出问题bash代码注入的安全漏洞
</content>
</doc><doc>
    <docid>213</docid>
    <url>https://coolshell.cn/articles/19307.html</url>
    <title>StackOverflow 2019 程序员调查</title>
    <content>前些天，StackOverflow 发布了 2019年的年度程序员调查，这个调查报查有90000名程序员参与，这份调度报告平均花了20分钟，可见，这份报告有很多的问题，也是很详细的。这份报告有一些地方，让我有了一些思考。
首先，我们先来看一下之份报告的 Key Results：

Python 成为了过去一年中成长最快的语言，把Java挤到了第二位，排在后面的是Rust语言。
有半数以上的被访者在是在16岁写下自己的第一行代码。
DevOps Specialists 和 Site Reliability Engineers 是程序员中最有经验，技术最牛，薪资最好的职位。（这对应于国内的——系统架构师）
在几个头部的程序员大国中，中国的程序员最乐观的，他们相信在今天出生的人会有比他们父母更好的人生。对于欧洲的程序员来说，比较法国和德国的程序员，他们对未来并不太乐观。
对于最影响程序员生产力的事，不同的程序员有不同的想法。


第一部分，Developer Profile
在第一部分中，我们可以看到，中国程序员参与这个调查的并不多，程序员主要集中在美国、欧洲、印度这三个地方。所以，这份报告更偏国际上一些。这对于我们中国程序员也有很大的帮助，因为一方面可以看到世界发展的趋势，另一方面也可以了解我们和世界有什么不一样。
对于技术职业来说，整个世界的程序员开始趋于全栈和后端，有51.9%的人是全栈，50%的人是后端，32.8%的人是前端……在这些人中，很多程序员都选了多项，中位数是3项，最常见是前端、后端和全栈全选的。然后，接下来是选两项的，选两项目的包括：数据库管理员和系统管理员，DevOps Specialist 和 Site Reliablility Engineer， 学术研究者和科学家，设计师和前端工程师。
从这些数据中我们可以看见：前后端的界限越来越不明显，设计师和前端的界限也开始模糊。这应该说明，工具和框架的成熟，让后端程序员和设计师也可以进入到前端工程师的领域，或是前端工程师开始进入后端和设计的领域。总之，复合型人才越来越越成为主流，而前后端也趋于一个相互融合的态势。
在接下来的图表中，我们可以看到有80%以上的人是把编程当成自己的爱好（包括相关的女性）。
真是应了那句话——“Programmers who don’t code in their spare time for fun will never become as good as those that do”，是的，如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的兴趣爱好方式去面对，那么，无论是编程，还是运动，还是去旅游，都不会有太多成效的。
在接下来的编程经验上，有两组如下的数据：



学习编程的年限
编程的年限









我们可以看到无论是学习还是编程，随着时间的拉长，其人数占比越来越少。
下面我们再来看一个年龄图：

调查报告从20岁开始每隔5年划分一个年龄段，我们不难发现从25-29岁开始每个年龄段都比前一个年龄段人数急剧减少大约30-50%，比如25-29年龄段占总人数27.6%，而30-34则只有19.3%。以此类推，到60岁以上，就只剩1%。可以看出5年是大多数程序员的转型周期。这是合理的，因为5年时间足够一个人积累足够的经验技能为职业转型做准备。
我们也可以看到50岁以上的程序员只有4.2%，大约是参与调查人员的300多人，如果这些人20岁左右参加工作，那么说明他们在1990左右就开始写代码，事实上那个时间点别说是程序员了，连电脑用户都不多。电脑和互联网真正暴发的时间还是在1995年 &#8211; 2000年之间，不过，那个时间点程序员的总体人数也不多，而行业越来越火才会导致大量的人进入到这个行业中，这个转换过程基本上去需要3-5年，也就是从2000年后才开始有大量的人拥入程序员这个行业，程序员的人数在过去30年间也是呈增涨态势的，所以，我个人认为，所谓的“众多老程序员”的比例会被2005年以后大量拥入程序员行业的年青人所“稀释”。所以，上图的比例不能完全说明程序员是个青春饭。
但是，我们还是要正视老牌资深的程序员越来越少的这个事实，在这份报告第三部分中说了一些和程序员职业生涯相关的调查，如下：

在被问到有多少人对自己的职业满意的时。有40%的人觉得很满意，而有34.3%的人觉得一般满意，有10%的人说不清，还有15%的人是不满意的。可以看到有不少人是对这个职业生涯是有想法的。
在被问到有多少人想转管理而可以挣得更多时。有30%的人是说想转的，有51%的人是明确不转的，还有20%的人是说不知道。可见，想转管理的人最多可能会有一半的人。
在被问到有多少人想转管理时。有1/3的人是明确不想转的，而有1/4的人是明确是想转，而有36%的人则是不说，观望中。可见，的确是有很多想想转管理的。

我们可以看到，程序员中并不是所有的人都是可以坚持这么长时间的，这也挺正常的，对很大一部分人来说，对这个职业是有或多或少的不满意的，也有一部分人可能会随着技术的更新被淘汰，还有另外很大一部分人是想转管理的。所以，能够长时间地跟上形势长时间地喜欢写代码，并且对程序员这个的职业长期满意，不想转管理的，的确是为随时年龄的越大也越来越少。
但我们完全可以看出来，程序员的主力军在20-40岁这个区间，而30岁左右的程序员是年富力强（经验和能力都很好）的黄金时间。
老程序员在国外似乎不会存在多大的问题，但在国内会有一些问题，所以，对于像我一样喜欢写代码、打算长久做程序员的兄弟，这里分享一些相关的经验。

持续高效地学习。软件行业的新技术层出不穷，旧的技术淘汰很快，所以我们更要多多学习基础技术和原理，那些都是很难改变的，并且基础扎实了后，学习新的技术也才会更快速。其间我们也不要乱学新技术，我们要关注那些有潜力的技术，也就看准了再学（参看酷壳的《Go语言、Docker和新技术》）。注意，而是跟上大时代已经比较不容易，引领时代的人还是少数，所以，还是要更为高效地学习。
积极面对他人的不解。 很多时候，总是会有人说：“到了你这个年纪怎么还在做程序员？”，这句话感觉就是对程序员这个职业的一种羞辱，社会的价值观感觉容不下大龄程序员。这个时候，我一般会跟他们解释到，我40来岁了，我觉得自己的状态还很好，工作完成没什么问题，偶尔加班到凌晨也行，新知识和技术我学起来不比年轻人慢，我在这个年纪有的经验比他们都多，而且，我这个年纪还在写代码，说明我真的喜欢这个事，像我这样的人能够长时间坚持做一个职业的人这个世界已经不多了，你们应该珍惜……
找到自己的定位。我们需要做好职业规划、财务和心理方面的准备。40岁的程序员，所能竞争的一定是自己的认识和经验，所以，40岁以后如果你还是很喜欢这一行业，你的社会阅历和经历以及对这个社会的理解，可以让你做一些有创新的事，除此之外，你还可以做一个教练、老师、咨询、专家……，用你的经验和能力帮助下一代和一些中小型的公司，这不但是他们的刚需，同时也会让重新焕发的。

第二部分，技术
首先，在这部分，主要是了解一些技术，这部分的技术可以给于程序员们一些指导。



最流行的语言
最热门的语言









我们可以看到，

Javascript/HTML/CSS是很多人都会用到的，后面的是SQL，这个也没什么问题，无论前后端的人，或多或少都会要用到的，这些技术感觉已经成为了基础必会的技术了，就像数中的加减乘除一样。
Python/Java/Shell 是后端开发主流语言的前三强，Python在今年超过了Java。这里让我比较好奇的是居然还有很多人用Shell，这估计跟运维有关，所以，Python的热可能也是通过运维和大数据相关。
流行语言后，第二梯队的是 C# / PHP / C++ / TypeScript / C ，接下来的是： Ruby / Go / Swift / Kotlin /WebAssembly / Rust&#8230; 。但在最被程序员喜欢的编程语言中：Rust / Python / TypeScript / Koltin / WebAssembly / Swift / Go&#8230; 都是排在前几名的。程序语言每隔一段时间就会整出一些新的语言来，我们一定要明白新出来的东西主要是为了解决什么样的问题，不然很容易迷失。
在后面还有一个编程语言的薪资图，我们可以看到，在上面被提过的这些个编程语言中，Go语言的薪资是最高的（这可能是因为Go语言写关键的系统级的中件间——因为Go语言正在成为云计算的第一编程语言），然后是Scala、Ruby、WebAssembly、Rust、Erlang、Shell、Python、Typescript……

通过这些个信息，我们可以看出主流技术、有潜力的技术，传统过气技术，以及相关薪资，对我们在选择编程语言上有一定的启示。
在后面，我们可以看到:

在 Web 开发框架上，主流使用还是 jQuery, React.js，Angular.js 为最前面的三个前端开发框架。而被程序员所喜欢的则是 React.js，Vue.js，Express, Spring，程序员非常不喜欢 Drupal，jQuery，Ruby on Rails 和Angular.js……
在其它开发框架/库/工具上，主流是Node.js、.NET、Pandas、Unity 3D、Tensorflow、Ansible、Cordova、Xamarin……而程序员比较喜欢的是.NET、Torch/PyTorch、Flutter、Pandas、Tensorflow、Node.js &#8230;
在操作系统上，主流使用Linux、Windows、Docker、Android、AWS……，而程序员最喜欢的是Linux、Docker、Kubernetes、Raspberry Pi、AWS、MacOS、iOS……
在数据库上，MySQL、PostgreSQL、MSSQL、SQLite、MongoDB、Redis、Elasticsearch是比较主流的，而程序员非常喜欢的是，Redis、PostgreSQL、Elasticsearch、Firebase、MongoDB……，程序员比较讨厌的是 Couchbase、Oracle、Cassandra、MySQL。

从这些个图表中，我们可以看到主流和有潜力的技术是什么，我们可以看到 Windows 的技术并没有过时，感觉似乎都有可能会卷土重来，但是，开源的技术来势凶凶，正在吞食整个软件业，不容小觑，Docker/Kubernetes无论是在主流应用上还是被程序员的喜好上都是非常猛的，而云平台的AWS开始成为标准平台技术……
接下来的开发工具中，我们可以看到：

Visual Studio Code 成为了最流行的开发工具。让我没有想到的是跟在后面的是 Notepad++（好久没用这个工具了，我得找回来用用了），而IntelliJ、Vim、Sublime Text排以后面。 Eclipse 和 Atom 动力不足，Emacs 开始变得小众了。
程序员主要的开发平台还是Windows占了近1/2， MacOS和Linux随后，各占1/4。
有38%的人使用容器技术做开发，30%的人使用容器做测试，在生产线上使用容器的有26%

看样子编程开发工具还是Visual Studio 和 IntelliJ的天下，MacOS/Linux正在抢Windows的开发市场
接下来，StackOverflow给了一个技术圈的图

从上面这个图中，我们可以看以技术的几圈子：

Microsoft圈 &#8211; Windows、.NET、ASP.NET、C#、Azure、SQL Server
Java圈 &#8211; Java、Spring
手机圈 &#8211; Android、 iOS、Kotlin、Swift、Firebase
前端圈 &#8211; Javascript、React.js、Angular.js、PHP
大数据圈 &#8211; Python、TensorFlow、Torch/PyTorch
基础平台圈 &#8211; Linux、Shell、Vim、Docker、Kubernetes、Elasticsearch、Redis……
其它圈子 &#8211; C/C++/汇编圈子、Ruby圈子、Hadoop/Spark圈子、……

看到谁的圈子大了吧，圈子大的并不代表技术实力强或是有前途，不过可以代表在那个圈子相关的关联技术，一方面，可以给你一些相关的参考，另一方面，整体可以让你看到全部的目前比较主流的技术。
第三部份 工作
在第三部份工作中，我们可以看到如下的一些数据：

有3/4的程序员是全职的，10%左右的程序员是自由职业，6%左右的程序员是失业的，这个比例在北美、印度和欧洲都差不多。
有1/3的人在过去一年内换过工作，1/4的人在过去1-2年间换过工作，1/3的人在2-4年换过工作。
程序员找工作时，影响程序员的几个主要因素是：技术（编程语言、框架和使用的技术）、办公环境和公司文化、灵活的时间和安排、更专业的机会、远程工作……
影响程序员工作的几大因素是：有干扰的工作环境、开会、要干一些和开发无关的事、人手不够、管理不够、工具不够、通勤时间……
对于工程质量，有近70%的人有Code Review，而30%的则没有；有60%多的人有Unit Test，而不到40%的没有……

从工作中我们可以看到，程序员还是比较关心技术和公司文化的，换工作也是这个职业很正常的特性，他们并不喜欢被打扰，希望有足够的时间，而对于工程质量还是很有追求的。
最后用一张程序员的“每周工作时间” 来结束本文！

祝大家快乐！
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章关于高可用的系统技术人员的发展之路什么是工程师文化？这多年来我一直在钻研的技术Leetcode 编程训练从Gitlab误删除数据库想到的
</content>
</doc><doc>
    <docid>214</docid>
    <url>https://coolshell.cn/articles/19271.html</url>
    <title>“努力就会成功”</title>
    <content> 那一年，我加入了某知名公司的某知名部门，在办公室中，我看到了到处都挂着——“努力就会成功”的条幅，这个部门中大多数员工的邮件签名都会有“努力就会成功”，我感到一种热血沸腾的气氛，这是我在多年工作来都没有感受到的，当时挺高兴地能和这样一群人工作，也没多想。直到有一天，我看到这些高级的软件工程师们把自己关在又挤又吵的会议室中，拼命地加班，真是拼命，周一到周日，每天早上10点到凌晨3点甚至凌晨5点，连国庆节都来上班，就在这样的环境和状态下，连续干了三个多月……上线前，QA找到了1000多个bug（你没看错，就是一千多个），最后这个项目用了1年多的时间来返工，本来一个6-8个月的项目，团队被打了鸡血想在3个月内完成，最终却花了近两年的时间来返工……（要知道，我以前在外国公司工作，外国老板看到团队在长时间加班会感到焦虑的，因为加班通常代表着有不好的事情正在发生……）
所以对此，我是有点看不懂的，看不懂的是，为什么这么一群聪明的人，放着明亮宽敞的办公桌不用，硬要挤在一个又窄又小又吵又热的小空间里工作，而且要这么透支地写那么重要的很关键的系统级的代码……这就好像，一架在一个小作坊里被人加班加点赶工出来的飞机，谁敢坐啊？！老实说，这群工程师真是很优秀的工程师，他们完全是可以做得更好的……但是却做出了如此蹩脚和糟糕的系统……他们说，这样坐在一起可以做到快速沟通，然而，我觉得这恰恰是一种没有章法的表现。
也是在这家公司，在这个项目烂尾一年前，公司感到了危机，CEO号召全体996，举全公司之力从董事长到下面基层员工对抗外部所谓的威胁，有的部门为了表现，甚至997，然而，在一年后，做出了一个烂得不能再烂的软件，最终以失败告终，很多人包括CEO也因此下课……

这是最让我看不懂的一个事了，为什么这么如此成功的公司的高级管理层会做出这样的事情，而且还制定这样的政策……把这么优秀的员工以及公司大把把数以亿计的钞票投入到这种错误的路线上来，而且还拼命地加班…… 他们脑子里在想什么呢？难道他们真的以为，有足够多的钱，足够多的人，然后拼命加班，就能打败对手吗？……
你喜欢这句话吗？
“努力就会成功”，“加班就会有成就”，“勤劳就会致富”……是这样吗？仔细思考一些，这些话存在严重的逻辑问题，我们在高中的时候学过“充分条件”，“必要条件”和“充要条件”！“努力就会成功”这句话，把“努力”说成了“成功”的充要条件，这不就是错的吗？努力只是成功的必要条件之一。你在错误的方向或是格局很小的方向上努力，能有用么？你努力地要饭，你努力地当搬运工，你努力地打骚扰电话销卖保险…… 在错误和小格局的方向上努力，你还觉得努力还有用吗？
但是很多人是很喜欢“努力就会成功”这句话，这类人也很喜欢看很多小人物通过自己的努力变成成功人士的励志的故事，为什么这种故事会被很多人喜欢甚至感动。因为这很符合大众的心理诉求，这种诉求其实就是一种只要使力只要拼命了就可以成功的心理诉求，因为这类人基本上都是能力有限，不知道怎么提升自己的人，当他们看到只要拼命使力就可以成功的观点时，他们就会有共鸣，就会感到，不用学习那些晦涩难懂高级的知识，不用掌握和练习哪些高级技能，自己只需要在低级的事情上拼命和努力，加更多的班和干更多活，自己就会像电影中的那些小人物一样，总有一天会成功的……
“努力就会成功，勤劳就会致富”，不但符合那些低级管理者的利益诉求，同样符合那些能力不足不愿意学习和成长的人的诉求。因为，他们混淆了行动与进展，忙碌与多产，他们以为能靠蛮力可以弥补思维上的惰性，靠拼命可以弥补能力上的不足……
喜欢或认同这句话的人基本是能力上有问题的人，这类适合做劳动密集型的事。不信你可以试试看，当一件事的难度超过一定程度的时候，那些聪明的人会找到更省力的方法，而能力上有问题的，还是在那使蛮力。
我成长的过程
回想我的过去，我在2001年那年被外包到了某银行做开发，标准的9/10/6，封闭开发，就是用C语言在AIX系统里堆一些银行的交易逻辑，老实说，这个过程并没有让我学到什么东西，也没有什么成长，我每天想的就是我要离开这个地方，所以，我在晚上10点以后开始看书学习到11点半，并使用工作环境动手实践书上的代码，一年后，我精读了《TCP/IP详解》《Windows核心编程》《Java编程思想》等书。然后，我找到一份外企业的工作，月薪一下翻了三倍。
在外企不加班，但是当时的外企压力也很大，对代码的质量要求的也很高，来的第二个月，就因为代码写的太差，差点被开掉，所以，为了能够达到更高的标准，我自然也是很努力的，在周末甚至黄金周节假日我哪里都不去，我就去公司，但我不是在公司上班，因为我没有自己的电脑，所以，我只能蹭公司的电脑，这导致办公楼的管理人员经常打电话给我让我帮他在周末的时候管理物业…… 在这家公司是我成长最快的时候，然而，并不是因为我的努力，而是因为有很多比我牛逼的人在Code Review上给我大量的帮助，在项目上帮助我，我的努力学习虽然也有作用，但更多的是高手对我的帮助。
再回想一下我以前在职场上的很多关键点，不是因为我加班了，而是因为在某些关键问题上，我跳出来解决了其它人都解决不了的问题，我解决了一个网络通信莫名其妙的断掉的问题，我把性能优化了很多倍，我解决了一个不能重现的一个困扰团队3个星期的问题（其实就是大家没有认真读文档），我在入职一个公司的第一天里就为这个公司解决了一个历史遗留问题……在Platform，我每周解决了bug数是全公司的其它人的总和还要多（从不加班），在路透，我带团队优化的系统的性能是全球所有研发中心最高的，在亚马逊，两周打通美国和德国的订单和商品列表系统……我也有失败的时候，而我失败的时候，总是因为我搞不定事，即便是加班拼命努力也无济于事！是的，我的职业生涯的成长，最根本的不是你有多努力，有多勤奋，而是你能搞定很多人搞不定的事！
你不信你可以看看你们公司那些不用加班，就算什么也不干，公司也要花钱养的技术人员，他们的成功一定不是努力和加班加出来的，你会发现这些人拼的不是谁干的多，而是谁解决的问题更有难。
我加班996的时候，从来都不是我成长最快的时候，而我和一群牛人在解决难题的时才是我成长最快的时候。
Work Smart
2015年因为父亲病危要动手术，所以我不能工作在家照顾父亲。于是我就成为了一个自由职业者，帮很多公司解决一些技术问题，好多都是高并发和系统稳定性的问题，有一些是分布式架构的运维的问题，还有一些是工程管理和企业文化问题……有一些小公司的单体架构在业务上一推广就宕机了，于是把我叫过去，我在生产线上直接re-arch，用一些非常规的手段，1-2天就把性能救过来了…… 还有就是解决一些点状的技术问题，还帮用户做一些design/code review……，有70%工作是真正的按劳取酬，也就是先把问题解决了再谈要收多少钱，那段时间我出卖的不是我的劳动力，而是我的技能，所以，反而比打工挣得多多了，而且还比较轻闲……
有时候，我还调侃到，你在大公司里一天写上万行代码，拼命地加班，你信不信，我只用写几百行代码就挣得比你多？同样是一个简单的 for-loop 语句，有人写的就值1万元一行，而你写的则一文不值。关键不在于谁写的代码多，关键在于我们解决了什么样的问题。你千万不要以为只要付你足够的钱，你就可以996，让你干什么都可以，然而当你自己把自己当成劳动力的时候，你也就只是一个像牲口一样的行事了！

这就好像算法一样，你那个O(n^2)的递归穷举算法，再怎么样也干不过我的O(n)的动态规划的算法。
现在我拿了投资在创业，一开始帮助各大企业建高并发高可用云化架构的公司，现在还给企业提供金融和营销能力，我跟客户谈业务的时候，基本不是因为我有多加班多努力地做方案，而是我能一针见血地指出用户的问题，帮用户解决问题。我在很多地方都见到阿里、蚂蚁、华为、HP……，一个小创业公司跟他们竞争真的很难，但我知道，要能竞争过这些大公司，这根本就不是能够通过加班996或是拼命努力就能搞定的，我必需要使用更好的方式，所以，除了更好地站在用户的立场，能够给用户制定更符合用户的技术方案之外，我必需做到我的技术方案不比这些大公司的差，而这一点，完全不是加班、努力或是勤奋能出来的，这是需要靠自己的经验、学习能力、归纳思考、和与更多牛人交流才出的来的……当我给某银行CIO介绍完我的分布式系统的方案后，CIO给我微微鞠躬说：“过去一两年，我听过几乎所有国内外产商跟我讲的分布式的方案，你的是我听过的最好的方案！谢谢你！”，当我给某省电信行业公司讲了一下DevOps的方案后，老总对我说：“你们真的是做事的人！”，当用户来问我：“你们的API网关是怎么写的？为什么运行的这么稳定？”……这些话都是让我很心里很暖的话……当然，我也有被骂的时候，也有失败的时候，但基本上来说，我无法通过努力工作改善我思维的不足……
我们学计算机当程序员最大的福气不是可以到大公司里加班和996，而是我们生活在了第三次工业革命的信息化时代，这才是最大的福气，所以，我们应该努力地提升自己，而不是把自己当劳动力一样的卖了！在这样的一个时代，你要做的不是通过加班和拼命来跪着挣钱，而是通过技能来躺着挣钱……
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章什么是工程师文化？从Code Review 谈如何做技术关于高可用的系统技术人员的发展之路让我们来谈谈分工互联网之子 &#8211; Aaron Swartz
</content>
</doc><doc>
    <docid>215</docid>
    <url>https://coolshell.cn/articles/19219.html</url>
    <title>打造高效的工作环境 – Shell 篇</title>
    <content>注：本文由雷俊(Javaer/Emacser)和我一起编辑，所以文章版权归雷俊与我共同所有，转载者必需注明出处和我们两位作者。原文最早发于酷壳微信公众号，后来我又做了一些修改，再发到博客这边。
程序员是一个很懒的群体，总想着能够让代码为自己干活，他们不断地把工作生活中的一些事情用代码自动化了，从而让整个社会的效率运作地越来越高。所以，程序员在准备去优化这个世界的时候，都会先要优化自己的工作环境，是所谓“工欲善其事，必先利其器”。
我们每个程序员都应该打造一套让自己更为高效的工作环境。那怕就是让你少输入一次命令，少按一次键，少在鼠标和键盘间切换一次，都会让程序员的工作变得更为的高效。所以，程序员一般需要一台性能比较好，不会因为开了太多的网页或程序就卡得不行的电脑，还要配备多个显示器，一个显示器写代码，一个查文档，一个测试运行结果，而不必在各种窗口来来回回的切换……在大量的窗口间切换经常会迷路，而且也容易出错（分不清线上或测试环境）……
除了硬件上的装备，软件上也是能够提升程序员生产力的地方，在软件层面提升程序员生产力的东西有一个很重要的事就是命令行和脚本，使用鼠标和图形界面则会大大降低程序员的生产力。酷壳以前也写过一些，如《你可能不知道的Shell》和《 应该知道的Linux技巧》，但是Unix/Linux Shell就是一个大宝库，怎么写也写不完，不然，怎么会有“Where is the Shell, there is a way”。

命令行
在不同的操作系统下，都有着很不错的命令行工具，比如 Mac 下的 Iterm2，Linux 下的原生命令行，如果你是在 Windows 下工作，问题也不大，因为 Windows 下现在有了 WSL。WSL 提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如 Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含 Bash shell 和命令语言，使用本机 GNU/Linux 命令行工具（sed，awk 等），编程语言解释器（Ruby，Python 等），甚至是图形应用程序（使用主机端的X窗口系统）。
使用命令行可以完成所有日常的操作，新建文件夹（mkdir）、新建文件（touch）、移动（mv）、复制（cp）、删除（rm）等等。而且使用 Linux/Unix 命令行最好的方式是可以用 awk、sed、grep、xargs、find、sort 等等这样的命令，然后用管道把其串起来，就可以完成一个你想要的功能，尤其是一些简单的数据统计功能。这是Linux命令行不可比拟的优势。比如：

查看连接你服务器 top10 用户端的 IP 地址：

netstat -nat | awk '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -rn | head -n 10

查看一下你最常用的10个命令：

cat .bash_history | sort | uniq -c | sort -rn | head -n 10 (or cat .zhistory | sort | uniq -c | sort -rn | head -n 10
（注：awk 和 sed 是两大神器，所以，我以前的也有两篇文章来介绍它们——《awk简明教程》和《sed简明教程》，你可以前往一读）
在命令行中使用 alias 可以将使用频率很高命令或者比较复杂的命令合并成一个命令，或者修改原生的命令。
下面这几个命令，可能是你天天都在敲的。所以，你应该设置成 alias 来提高效率

alias nis=&quot;npm install --save &quot;
alias svim='sudo vim'
alias mkcd='foo(){ mkdir -p &quot;$1&quot;; cd &quot;$1&quot; }; foo '
alias install='sudo apt get install'
alias update='sudo apt-get update; sudo apt-get upgrade'
alias ..=&quot;cd ..&quot;
alias ...=&quot;cd ..; cd ..&quot;
alias www='python -m SimpleHTTPServer 8000'
alias sock5='ssh -D 8080 -q -C -N -f user@your.server'

你还可以参考如下的一些文章，看看别人是怎么用好 alias 的

30 Handy Bash Shell Aliases For Linux / Unix / Mac OS X
What are your favorite bash aliases?
23 Handy Bash Shell Aliases For Unix, Linux, and Mac OS X
A few more of my favorite Bash aliases

命令行中除了原生的命令之外，还有很多可以提升使用体验的工具。下面罗列一些很不错的命令，把原生的命令增强地很厉害:

fasd 增强了 cd 命令 。
bat 增强了 cat 命令 。如果你想要有语法高亮的 cat，可以试试 ccat 命令。
exa 增强了 ls 命令，如果你需要在很多目录上浏览各种文件 ，ranger 命令可以比 cd 和 cat 更有效率，甚至可以在你的终端预览图片。
fd 是一个比 find 更简单更快的命令，他还会自动地忽略掉一些你配置在 .gitignore 中的文件，以及 .git 下的文件。
fzf 会是一个很好用的文件搜索神器，其主要是搜索当前目录以下的文件，还可以使用 fzf --preview 'cat {}'边搜索文件边浏览内容。
grep 是一个上古神器，然而，ack、ag 和 rg 是更好的grep，和上面的 fd一样，在递归目录匹配的时候，会使用你配置在 .gitignore 中的规则。
rm 是一个危险的命令，尤其是各种 rm -rf …，所以，trash 是一个更好的删除命令。
man 命令是好读文档的命令，但是man的文档有时候太长了，所以，你可以试试 tldr 命令，把文档上的一些示例整出来给你看。
如果你想要一个图示化的ping，你可以试试 prettyping 。
如果你想搜索以前打过的命令，不要再用 Ctrl +R 了，你可以使用加强版的 hstr  。
htop  是 top 的一个加强版。然而，还有很多的各式各样的top，比如：用于看IO负载的 iotop，网络负载的 iftop, 以及把这些top都集成在一起的 atop。
ncdu  比 du 好用多了用。另一个选择是 nnn。
如果你想把你的命令行操作建录制成一个 SVG 动图，那么你可以尝试使用 asciinema 和 svg-trem 。
httpie 是一个可以用来替代 curl 和 wget 的 http 客户端，httpie 支持 json 和语法高亮，可以使用简单的语法进行 http 访问: http -v github.com。
tmux 在需要经常登录远程服务器工作的时候会很有用，可以保持远程登录的会话，还可以在一个窗口中查看多个 shell 的状态。
Taskbook 是可以完全在命令行中使用的任务管理器 ，支持 ToDo 管理，还可以为每个任务加上优先级。
sshrc 是个神器，在你登录远程服务器的时候也能使用本机的 shell 的 rc 文件中的配置。
goaccess  这个是一个轻量级的分析统计日志文件的工具，主要是分析各种各样的 access log。

关于这些增加命令，主要是参考自下面的这些文章

10 Tools To Power Up Your Command Line
5 More Tools To Power Up Your Command Line (Part 2 Of Series)
Power Up Your Command Line, Part 3
Power Up Your Command Line
Hacker Tools

Shell 和脚本
shell 是可以与计算机进行高效交互的文本接口。shell 提供了一套交互式的编程语言（脚本），shell的种类很多，比如 sh、bash、zsh 等。
shell 的生命力很强，在各种高级编程语言大行其道的今天，很多的任务依然离不开 shell。比如可以使用 shell 来执行一些编译任务，或者做一些批处理任务，初始化数据、打包程序等等。
现在比较流行的是 zsh + oh-my-zsh + zsh-autosuggestions 的组合，你也可以试试看。其中 zsh 和 oh-my-zsh 算是常规操作了，但是 zsh-autosuggestions 特别有用，可以超级快速的帮你补全你输入过的命令，让命令行的操作更加高效。
另外，fish 也是另外一个牛逼的shell，比如：命令行自动完成（根据历史记录），命令行命令高亮，当你要输入命令行参数的时候，自动提示有哪些参数…… fish在很多地方也是用起来很爽的。和上面的 oh-my-zsh 有点不分伯仲了。
你也许会说，用 Python 脚本或 PHP 来写脚本会比 Shell 更好更没有 bug，但我要申辩一下:

其一，如果你有一天要维护线上机器的时候，或是到了银行用户的系统（与外网完全隔离，而且服务器上没有安装 Python/PHP 或是他们的的高级库，那么，你只有 Shell 可以用了）。
其二，而且，如果要跟命令行交互很多的话，Shell 是不二之选，试想一下，如果你要去 100 台远程的机器上查access.log 日志中有没有某个错误，完成这个工作你是用 PHP/Python 写脚本快还是用 Shell 写脚本快呢？

所以，我们还要学会只使用传统的grep/awk/sed等等这些POSIX的原生的系统默认安装的命令。
当然，要写好一个脚本并不容易，下面有一些小模板供你参考：
处理命令行参数的一个样例
while [ &quot;$1&quot; != &quot;&quot; ]; do
    case $1 in
        -s  )   shift	
		SERVER=$1 ;;  
        -d  )   shift
		DATE=$1 ;;
	--paramter|p ) shift
		PARAMETER=$1;;
        -h|help  )   usage # function call
                exit ;;
        * )     usage # All other parameters
                exit 1
    esac
    shift
done 
命令行菜单的一个样例

#!/bin/bash
# Bash Menu Script Example

PS3='Please enter your choice: '
options=(&quot;Option 1&quot; &quot;Option 2&quot; &quot;Option 3&quot; &quot;Quit&quot;)
select opt in &quot;${options[@]}&quot;
do
    case $opt in
        &quot;Option 1&quot;)
            echo &quot;you chose choice 1&quot;
            ;;
        &quot;Option 2&quot;)
            echo &quot;you chose choice 2&quot;
            ;;
        &quot;Option 3&quot;)
            echo &quot;you chose choice $REPLY which is $opt&quot;
            ;;
        &quot;Quit&quot;)
            break
            ;;
        *) echo &quot;invalid option $REPLY&quot;;;
    esac
done

颜色定义，你可以使用 echo -e "${Blu}blue ${Red}red ${RCol}etc...." 进行有颜色文本的输出

RCol='\e[0m'    # Text Reset

# Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds
Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';
Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';
Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';
Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';
Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';
Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';
Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';
Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';

取当前运行脚本绝对路径的示例：（注：Linux下可以用 dirname $(readlink -f $0) ）

FILE=&quot;$0&quot;
while [[ -h ${FILE} ]]; do
    FILE=&quot;`readlink &quot;${FILE}&quot;`&quot;
done
pushd &quot;`dirname &quot;${FILE}&quot;`&quot; &gt; /dev/null
DIR=`pwd -P`
popd &gt; /dev/null

如何在远程服务器运行一个本地脚本
#无参数
ssh user@server 'bash -s' &lt; local.script.sh

#有参数
ssh user@server ARG1=&quot;arg1&quot; ARG2=&quot;arg2&quot; 'bash -s' &lt; local_script.sh

如何检查一个命令是否存在，用 which 吗？最好不要用，因为很多操作系统的 which 命令没有设置退出状态码，这样你不知道是否是有那个命令。所以，你应该使用下面的方式。

# POSIX 兼容:
command -v [the_command]

# bash 环境:
hash [the_command]
type [the_command]

# 示例：
gnudate() {
    if hash gdate 2&gt; /dev/null; then
        gdate &quot;$@&quot;
    else
        date &quot;$@&quot;
    fi
}

然后，如果要写出健壮性更好的脚本，下面是一些相关的技巧：

使用 -e 参数，如：set -e 或是 #!/bin/sh -e，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。
使用 -u 参数，如： set -eu，这意味着，如果你代码中有变量没有定义，就会退出。
对一些变理，你可以使用默认值。如：${FOO:-'default'}
处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。
尽量不要使用 ; 来执行多个命令，而是使用 &amp;&amp;，这样会在出错的时候停止运行后续的命令。
对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。
如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。
为你的脚本设置 -h 和 --help 来显示帮助信息。千万不要把这两个参数用做为的功能。
使用 $() 而不是 &#8220; 来获得命令行的输出，主要原因是易读。
小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。
对于 rm -rf 这样的高危操作，需要检查后面的变量名是否为空，比如：rm -rf $MYDIDR/* 如果 $MYDIR为空，结果是灾难性的。
考虑使用 &#8220;find/while&#8221; 而不是 “for/find”。如：for F in $(find . -type f) ; do echo $F; done 写成 find . -type f | while read F ; do echo $F ; done 不但可以容忍空格，而且还更快。
防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。

你还可以使用ShellCheck 来帮助你检查你的脚本。

https://www.shellcheck.net/

最后推荐一些 Shell 和脚本的参考资料。
各种有意思的命令拼装，一行命令走天涯:

http://www.bashoneliners.com/
http://www.shell-fu.org/
http://www.commandlinefu.com/

下面是一些脚本集中营，你可以在里面淘到各种牛X的脚本：

http://www.shelldorado.com/scripts/
https://snippets.siftie.com/public/tag/bash/
https://bash.cyberciti.biz/
https://github.com/alexanderepstein/Bash-Snippets
https://github.com/miguelgfierro/scripts
https://github.com/epety/100-shell-script-examples
https://github.com/ruanyf/simple-bash-scripts

甚至写脚本都可以使用框架:

写bash脚本的框架 https://github.com/Bash-it/bash-it

Google的Shell脚本的代码规范：

https://google.github.io/styleguide/shell.xml

最后，别忘了几个和shell有关的索引资源：

https://github.com/alebcay/awesome-shell
https://github.com/awesome-lists/awesome-bash
https://terminalsare.sexy/

最后，如果你还有什么别的更好的玩的东西，欢迎在评论区留言，或是到 coolshellx/ariticles @ github 修改本文。
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章应该知道的Linux技巧你可能不知道的ShellDocker基础技术：AUFSbash代码注入的安全漏洞Docker基础技术：DeviceMapperDocker基础技术：Linux Namespace（下）
</content>
</doc><doc>
    <docid>216</docid>
    <url>https://coolshell.cn/articles/19085.html</url>
    <title>谈谈我的“三观”</title>
    <content>也许是人到了四十多了，敢写这么大的命题，我也醉了，不过，我还是想把我的想法记录下来，算是对我思考的一个snapshot，给未来的我看看，要么被未来的我打脸，要么打未来我的脸。无论怎么样，我觉得对我自己都很有意义。注意，这篇文章是长篇大论。
三观是世界观、人生观和价值观，

世界观代表你是怎么看这个世界的。是左还是右，是激进还是保守，是理想还是现实，是乐观还是悲观……
人生观代表你要想成为什么样的人。是成为有钱人，还是成为人生的体验者，是成为老师，还是成为行业专家，是成为有思想的人，还是成为有创造力的人……
价值观则是你觉得什么对你来说更重要。是名是利，是过程还是结果，是付出还是索取，是国家还是自己，是家庭还是职业……

人的三观其实是会变的，回顾一下我的过去，我感觉我的三观至少有这么几比较明显的变化，学生时代、刚走上社会的年轻时代，三十岁后的时代，还有现在。估计人都差不多吧……

学生时代的三观更多的是学校给的，用各种标准答案给的，是又红又专的
刚走上社会后发现完全不是这么一回事，但学生时代的三观根深蒂固，三观开始分裂，内心开始挣扎
三十岁后，不如意的事越来越多，对社会越来越了解，有些人屈从现实，有些人不服输继续奋斗，而有些人展露才能开始影响社会，而分裂的三观开始收敛，我属于还在继续奋斗的人。
四十岁时，经历过的事太多，发现留给自己的时间不多，世界太复杂，而还有好多事没做，从而变得与世无争，也变得更为地自我。


面对世界
年轻的时候，抵制过日货，虽然没上过街，但是也激动过，一次是1999南斯拉夫大使馆被炸，一次是2005反日示威，以前，我也是一个爱国愤青。但是后来，有过各种机会出国长时间生活工作，加拿大、英国、美国、日本……随着自己的经历和眼界的开阔，自己的三观自己也随着有了很多的变化，发现有些事并不是自己一开始所认识的那样，而且还是截然相反的。我深深感觉到，要有一个好的世界观，你需要亲身去经历和体会这个世界，而不是听别人说。所以，当我看到身边的人情绪激动地要抵制这个国家，搞死那个民族的时候，我都会建议他去趟那个国家最好在在那个国家呆上一段时间，亲自感受一下。
再后来发现，要抵制的越来越多，小时候的美英帝国主义，然后是日本，再后面是法国、韩国、菲利宾、印度、德国、瑞典、加拿大……从小时候的台独到现在的港独、藏独、疆独……发现再这样下去，基本上来说，自己的人生也不用干别的事了……另外，随着自己的成长，越来越明白，抵制这个抵制那个只不过是幼稚和狭隘的爱国主义，真想强国，想别让他人看得起，就应该把时间和精力放在努力学习放在精益求精上，做出比他们更好的东西来。另外，感觉用对内的爱国主义解决对外的外交问题也有点驴唇不对马嘴，无非也就是转移一下内部的注意力罢了，另外还发现爱国主义还可以成为消费营销手段……不是我不爱国，是我觉得世道变复杂了，我只是一个普通的老百姓，能力有限，请不要赋予我那么大的使命，我只想在我的专业上精进，能力所能及地帮助身边的人，过一个简单纯粹安静友善的生活……
另外，为什么国与国之间硬要比个你高我低，硬要分个高下，硬要争出个输赢，我也不是太理解，世界都已经发展到全球化的阶段了，很多产品早就是你中有我，我中有你的情况了。举个例子，一部手机中的元件，可能来自全世界数十个国家，我们已经说不清楚一部手机是究竟是哪个国家生产的了。即然，整个世界都在以一种合作共赢全球化的姿态下运作，认准自己的位置，拥抱世界，持续向先进国家学习，互惠互利，不好吗？你可能会说，不是我们不想这样，是别人不容我们发展……老实说，大的层面我也感受不到，但就我在的互联网计算机行业方面，我觉得整个世界的开放性越来越好，开源项目空前地繁荣，世界上互联网文化也空前的开放，在计算机和互联网行业，我们享受了太多的开源和开放的红利，人家不开放，我们可能在很多领域还落后数十年。然而现在很多资源我们都访问不了，用个VPN也非法，你说是谁阻碍了发展？我只想能够流畅地访问互联网，让我的工作能够更有效率，然而，我在自己的家里却像做贼一样去学习新知识新技术，随时都有可能被抓进监狱……
随着自己的经历越多，发现这个世界越复杂，也发现自己越渺小，很多国家大事并不是我不关心，是我觉得那根本不是我这个平头老百姓可以操心的事，这个世界有这个世界运作的规律和方法，而还有很多事情超出了我能理解的范围，也超出了我能控制的范围，我关心不关心都一个样，这些大事都不会由我的意志所决定的。而所谓的关心，无非就是喊喊口号，跟人争论一下，试图改变其它老百姓的想法，然而，对事情的本身的帮助却没有多大意义。过上几天，生活照旧，人家该搞你还不是继续搞你，而你自己并不因为做这些事而过得更好。
我对国与国之间的关系的态度是，有礼有节，不卑不亢，对待外国人，有礼貌但也要有节气，既不卑躬屈膝，也不趾高气昂，整体上，我并不觉得我们比国外有多差，但我也不觉得我们比国外有多好，我们还在成长，还需要帮助和协作，四海之内皆兄弟，无论在哪个国家，在老百姓的世界里，哪有那么多矛盾。有机会多出去走走，多结交几个其它民族的朋友，你会觉得，在友善和包容的环境下，你的心情和生活可以更好。
我现在更多关心的是和我生活相关的东西，比如：上网、教育、医疗、食品、治安、税务、旅游、收入、物价、个人权益、个人隐私……这些东西对我的影响会更大一些，也更值得关注，可以看到过去的几十年，我们国家已经有了长足的进步，这点也让我让感到很开心和自豪的，在一些地方也不输别人。但是，依然有好些事的仍然没有达到我的预期，而且还很糟糕，这个也要承认。而对，未来的变数谁也不好说，我在这个国度里的安全感似乎还不足够，所以，我还是要继续努力，以便我可以有更多的选项。有选项总比没得选要好。所以，我想尽一切办法，努力让选项多起来，无法改变无法影响，那就只能提高自己有可选择的可能性。
面对社会
另外，在网上与别人对一些事或观点的争论，我觉得越来越无聊，以前被怼了，一定要怼回去，现在不会了，视而不见，不是怕了，是因为，网络上的争论在我看来大多数都是些没有章法，逻辑混乱的争论。

很多讨论不是说事，直接就是怼人骂人。随意就给人扣个帽子。
非黑即白的划分，你说这个不是黑的，他们就把你划到白的那边。
飘移观点，复杂化问题。东拉西扯，牵强附会，还扯出其它不相关的事来混淆。
杠精很多，不关心你的整体观点，抓住一个小辫子大作文章。

很明显，与其花时间教育这些人，不如花时间提升自己，让自己变得更优秀，这样就有更高的可能性去接触更聪明更成功更高层次的人。因为，一方面，你改变不了他们，另外，改变他们对你自己也没什么意义，改变自己，提升自己，让自己成长才有意义。时间是宝贵的，那些人根本不值得花时间，应该花时间去结交更有素质更聪明的人，做更有价值的事。
美国总统富兰克林·罗斯福妻子埃莉诺·罗斯福（Eleanor Roosevelt）说过下面的一句话。
Great minds discuss ideas;
Average minds discuss events;
Small minds discuss people
把时间多放在一些想法上，对自己对社会都是有意义的，把时间放在八卦别人，说长到短，你也不可能改善自己的生活，你批评这个批评那个，看不上这个看不起那个，不会让你有成长，也不会提升你的影响力，你的影响力不是你对别人说长道短的能力，而是别人信赖你并希望得到你的帮助的现象。多交一些有想法的朋友，多把自己的想法付诸实践，那怕没有成功，你的人生也会比别人过得有意义。
如果你看过我以前的文章，你会看到一些吐槽性质的文章，而后面就再也没有了。另外，我也不再没有针对具体的某个人做出评价，因为人太复杂的了，经历的越多，你就会发现你很难评价人，与其花时间在评论人和事上，不如把时间花在做一些力所能及的事来改善自己或身边的环境。所以，我建议大家少一些对人的指责和批评，通过对一件事来引发你的思考，想一想有什么可以改善，有什么方法可以做得更好，有哪些是自己可以添砖加瓦的？你会发现，只要你坚持这么做，你个人的提升和对社会的价值会越来越大，而你的影响力也会越来越大。
面对人生
现在的我，即不是左派也不是右派，我不喜欢爱国主义，我也不喜欢崇洋媚外，我更多的时候是一个自由派，哪边我都不站，我站我自己。因为，生活在这样的一个时代，能让自己过好都是一些比较奢望的事了。
《教父》里有这样的人生观：第一步要努力实现自我价值，第二步要全力照顾好家人，第三步要尽可能帮助善良的人，第四步为族群发声，第五步为国家争荣誉。事实上作为男人，前两步成功，人生已算得上圆满，做到第三步堪称伟大，而随意颠倒次序的那些人，一般不值得信任。这也是古人的“修身齐家治国平天下”！所以，在你我准备要开始要“平天下”的时候，也得先想想，自己的生活有没有过好了，家人照顾好了么，身边有哪些力所能及的事是可以去改善的……
穷则独善其身，达则兼济天下。提升自己，实现自我，照顾好自己的家人，帮助身边的人。这已经很不错了！
什么样的人干什么样的事，什么样的阶段做什么样的选择，有人的说，选择比努力更重要的，我深以为然，而且，我觉得选择和决定，比努力更难，努力是认准了一个事后不停地发力，而决定要去认准哪个事是自己该坚持努力的，则是令人彷徨和焦虑的（半途而废的人也很多）。面对人生，你每天都在作一个一个的决定，在做一个又一个的选择，有的决定大，有的决定小，你的人生的轨迹就是被这一个一个的决定和选择所走走出来的。
我在24岁放弃了一房子离开银行到小公司的时候，我就知道，人生的选择就是一个翘翘板，你要一头就没有另一头，选择是有代价的，你不选择的代价更大；选择是要冒险的，你不敢冒险的风险更大；选择是需要放弃的，因为无论怎么选你都会要放弃。想想你老了以后，回头一看，好多事情在年轻的时候都不敢做，而你再也没有机会，你就知道不敢选择不敢冒险的代价有多大了。选择就是一种 trade-off，这世上根本不会有什么完美，只要你想做事，你有雄心壮志，你的人生就是一个坑接着一个坑，你所能做的就是找到你喜欢的方向跳坑。
所以， 你要想清楚你要什么，不要什么，而且还不能要得太多，这样你才好做选择。否则，你影响你的因子太多，决定不好做，也做不好。
就像最前面说的一样，你是激进派还是保守派，你是喜欢领导还是喜欢跟从，你是注重长期还是注重短期，你是注重过程还是注重结果……等等，你对这些东西的坚持和守护，成为了你的“三观”，而你的三观则影响着你的选择，而你的选择影响着你的人生。
价值取向
下面是一些大家经常在说，可能也是大多数人关心的问题，就这些问题，我也谈谈我的价值取向。
挣钱。挣钱是一个大家都想做的事，但你得解决一个很核心的问题，那就是为什么别人愿意给你钱？对于挣钱的价值观从我大学毕业到现我就没怎么变过，那就是我更多关注的是怎么提高自己的能力，让自己值那个价钱，让别人愿意付钱。另外一方面，我发现，越是有能力的人，就越不计较一些短期得失，越计较短期得失的人往往都是很平庸的人。有能力的人不会关心自己的年终奖得拿多少，会不会晋升，他们更多的关心自己真正的实力有没有超过更多的人，更多的关注的是自己长远的成长，而不是一时的利益。聪明的人从来不关心眼前的得失，不会关心表面上的东西，他们更多关心的是长期利益，关心长期利益的人一定不是投机者，一定是投资者，投资会把自己的时间精力金钱投资在能让自己成长和提升的地方，那些让自己可以操更大的盘的地方，他们培养自己的领导力和影响力。而投机者在职场上会通过溜须拍马讨好领导，在学习上追求速成，在投资上使用跟随策略，在创业上甚至会不择手段，当风险来临时，投机者是几乎完全没有抗风险能力的，他们所谓的能力只不过因为形势好。
&nbsp;
技术。对于计算机技术来说，要学的东西实在是太多，我并不害怕要学的东西很多，因为学习能力是一个好的工程师必需具备的事，我不惧怕困难和挑战。我觉得在语言和技术争论谁好谁坏是一种幼稚的表现， 没有完美的技术，Engineering 玩的是 Tradeoff。所以，我对没有完美的技术并不担心，但是我反而担心的是，当我们进入到一些公司后，这些公司会有一些技术上的沉淀也就是针对公司自己的专用技术，比如一些中间件，一些编程框架，lib库什么的。老实说，我比较害怕公司的专用技术，因为一旦失业，我建立在这些专用技术上的技能也会随之瓦解，有时候，我甚至害怕把我的技术建立在某一个平台上，小众的不用说了，大众的我也比较担扰，比如Windows或Unix/Linux上，因为一旦这个平台不流行或是被取代，那么我也会随之淘汰（过去的这20年已经发生过太多这样的事了）。为了应对这样的焦虑，我更愿意花时间在技术的原理和技术的本质上，这导致我需要了解各种各样的技术的设计方法，以及内在原理。所以，当国内的绝大多数程序员们更多的关注架构性能的今天，我则花更多的时间去了解编程范式，代码重构，软件设计，计算机系统原理，领域设计，工程方法……因为只有原理、本质和设计思想才可能让我不会被绑在某个专用技术或平台上，除非，我们人类的计算机这条路没走对。
&nbsp;
职业。在过去20多年的职业生涯中，我从基层工程师做到管理，很多做技术的人都会转管理，但我却还是扎根技术，就算是在今天，还是会抠很多技术细节，包括写代码。因为我心里觉得，不写代码的人一定是做不好技术管理的，因为做技术管理有人要做技术决定，从不上手技术的人是做不好技术决定的，另一方面，我觉得管理是支持性的工作，不是产出性的工作，大多数的管理者无非是因为组织大了，所以需要管人管事，所以，必然要花大量的时间和精力处理各种问题，甚至办公室政治，然而，如果有一天失业了，大环境变得不好了，一个管理者和一个程序员要出去找工作，程序员会比管理者更能自食其力。所以，我并不觉得管理者这个职业有意思，我还是觉得程序员这个有创造性的职业更有趣。通常来说，管理者的技能力需要到公司和组织里才能展现，而有创造力的技能的人是可以自己独立的能力，所以，我觉得程序员的技能比管理者的技能能让我更稳定更自地活着。所以，我更喜欢“电影工作组”那样的团队和组织形式。
&nbsp;
打工。对于打工，也就是加入一家公司工作，无论是在一家小公司还是一家大公司工作，都会有好的和不好的，任何公司都有其不完美的地方，这个需要承认。首先第一的肯定是完成公司交给你的任务（但我也不会是傻傻地完成工作，对于一些有问题的任务我也会提出我的看法），然后我会尽我所能在工作找到可以提高效率的地方进行改善。在推动公司/部门/团队在一技术和工程方面进步并不是一件很容易的事，因为进步是需要成本的，有时候，这种成本并不一定是公司和团队愿意接受的，而另外，从客观规律上来说，一件事的进步一定是会有和现状有一些摩擦的。有的人害怕有摩擦而忍了，而我则不是，我觉得与别人的摩擦并不可怕，因为大家的目标都是基本一致的，只是做事的标准和方式不一样，这是可能沟通的，始终是会相互理解的。而如果你没有去推动一个事，我觉得对于公司对于我个人来说，都是一种对人生的浪费，敬业也好，激情也好，其就是体现在你是否愿意冒险去推动一件于公于私都有利的事，而不是成为一个“听话”、“随大流”、“懒政”的人，即耽误了公司也耽误了自己。所以，我更信仰的是《做正确的事情，等着被开除》，这些东西，可参看《我看绩效考核》，以及我在Gitchat上的一些问答。
&nbsp;
创业。前两天，有个小伙来跟我说，说他要离开BAT要去创业公司了，说在那些更自由一些，没有大公司的种种问题。我毫不犹豫地教育了他一下，我说，你选择这个创业公司的动机不对啊，你无非就是在逃避一些东西罢了，你把创业公司当做是一个避风港，这是不对的，创业公司的问题可能会更多，去创业公司的更好的心态是，这个创业公司在干的事业是不是你的事业？说白了，如果你是为了你的事业，为了解决个什么，为了改进个什么，那么，创业是适合你的，也只有在做自己事业的时候，你才能不惧困难，才会勇敢地面对一切。那种想找一个安稳的避风港呆着的心态是不会让你平静地，你要知道世界本来就是不平静的，找了自己的归宿和目标才可能让你真正的平静。所以，在我现的创业团队，我不要求大家加班，我也不鸡汤洗脑，对于想要加入的人，我会跟他讲我现在遇到的各种问题以及各种机遇，并一直在让他自己思考，我们在做的事是不是自己的事业诉求？还可不可以更好？每个人都应该为自己的事业为自己的理想去活一次，追逐自己的事业和理想并不容易，需要有很大的付出，而也只有你心底里的那个理想值得这么大的付出……
&nbsp;
客户。基于上述的价值观，在我现在创业的时候，我在面对客户的时候，也是一样的，我并不会完全的迁就于客户，我的一些银行客户和互联网客户应该体会到我的做的方式了，我并不觉得迁就用户，用户要什么我就应该给什么，用户想听什么，我就说什么，虽然这样可以省着精力，更圆滑，但这都不是我喜欢的，我更愿意鲜明地表达我的观点，并拉着用户跟我一起成长，因为我并不觉得完成客户的项目有成就感，我的成就感来自客户的成长。所以，面对客户有些做得不对有问题有隐患的地方，或是有什么做错的事，我基本上都是直言不讳地说出来，因为我觉得把真实的相法说出来是对客户和对自己最基本的尊重，不管客户最终的选择是什么，我都要把利弊跟客户讲清楚。我并不是在这里装，因为，我也想做一些更高级更有技术含量的事，所以，对于一些还达到的客户，我如果不把他们拉上来，我也对不起自己。
&nbsp;
在我“不惑之年”形成了这些价值观体系，也许未来还会变，也许还不成熟，总之，我不愿跟大多数人一样，因为大多数人都是随遇而安随大流的，因为这样风险最小，而我想走一条属于自己的路，做真正的自己，就像我24岁从银行里出来时想的那样，我选择对了一个正确的专业（计算机科学），呆在了一个正确的年代（信息化革命），这样的“狗屎运”几百年不遇，如果我还患得患失，那我岂不辜负活在这样一个刺激的时代？！我所要做的就是在这个时代中做有价值的事就好了！这个时代真的是太好了！
(全文完)

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章技术人员的发展之路什么是工程师文化？这多年来我一直在钻研的技术关于高可用的系统Leetcode 编程训练「我只是认真」聊聊工匠情怀
</content>
</doc><doc>
    <docid>217</docid>
    <url>https://coolshell.cn/articles/18654.html</url>
    <title>记一次Kubernetes/Docker网络排障</title>
    <content>昨天周五晚上，临下班的时候，用户给我们报了一个比较怪异的Kubernetes集群下的网络不能正常访问的问题，让我们帮助查看一下，我们从下午5点半左右一直跟进到晚上十点左右，在远程不能访问用户机器只能远程遥控用户的情况找到了的问题。这个问题比较有意思，我个人觉得其中的调查用到的的命令以及排障的一些方法可以分享一下，所以写下了这篇文章。
问题的症状
用户直接在微信里说，他们发现在Kuberbnetes下的某个pod被重启了几百次甚至上千次，于是开启调查这个pod，发现上面的服务时而能够访问，时而不能访问，也就是有一定概率不能访问，不知道是什么原因。而且并不是所有的pod出问题，而只是特定的一两个pod出了网络访问的问题。用户说这个pod运行着Java程序，为了排除是Java的问题，用户用 docker exec -it 命令直接到容器内启了一个 Python的 SimpleHttpServer来测试发现也是一样的问题。
我们大概知道用户的集群是这样的版本，Kuberbnetes 是1.7，网络用的是flannel的gw模式，Docker版本未知，操作系统CentOS 7.4，直接在物理机上跑docker，物理的配置很高，512GB内存，若干CPU核，上面运行着几百个Docker容器。

问题的排查
问题初查
首先，我们排除了flannel的问题，因为整个集群的网络通信都正常，只有特定的某一两个pod有问题。而用 telnet ip port 的命令手工测试网络连接时有很大的概率出现 connection refused 错误，大约 1/4的概率，而3/4的情况下是可以正常连接的。
当时，我们让用户抓个包看看，然后，用户抓到了有问题的TCP连接是收到了 SYN 后，立即返回了 RST, ACK

我问一下用户这两个IP所在的位置，知道了，10.233.14.129 是 docker0，10.233.14.145 是容器内的IP。所以，这基本上可以排除了所有和kubernets或是flannel的问题，这就是本地的Docker上的网络的问题。
对于这样被直接 Reset 的情况，在 telnet 上会显示 connection refused 的错误信息，对于我个人的经验，这种 SYN完直接返回 RST, ACK的情况只会有三种情况：

 TCP链接不能建立，不能建立连接的原因基本上是标识一条TCP链接的那五元组不能完成，绝大多数情况都是服务端没有相关的端口号。
TCP链接建错误，有可能是因为修改了一些TCP参数，尤其是那些默认是关闭的参数，因为这些参数会导致TCP协议不完整。
有防火墙iptables的设置，其中有 REJECT 规则。

因为当时还在开车，在等红灯的时候，我感觉到有点像 NAT 的网络中服务端开启了 tcp_tw_recycle 和 tcp_tw_reuse 的症况（详细参看《TCP的那些事（上）》），所以，让用户查看了一上TCP参数，发现用户一个TCP的参数都没有改，全是默认的，于是我们排除了TCP参数的问题。
然后，我也不觉得容器内还会设置上iptables，而且如果有那就是100%的问题，不会时好时坏。所以，我怀疑容器内的端口号没有侦听上，但是马上又好了，这可能会是应用的问题。于是我让用户那边看一下，应用的日志，并用 kublet describe看一下运行的情况，并把宿主机的 iptables 看一下。
然而，我们发现并没有任何的问题。这时，我们失去了所有的调查线索，感觉不能继续下去了……
重新梳理
这个时候，回到家，大家吃完饭，和用户通了一个电话，把所有的细节再重新梳理了一遍，这个时候，用户提供了一个比较关键的信息—— “抓包这个事，在 docker0 上可以抓到，然而到了容器内抓不到容器返回 RST, ACK ” ！然而，根据我的知识，我知道在 docker0 和容器内的 veth 网卡上，中间再也没有什么网络设备了（参看《Docker基础技术：LINUX NAMESPACE（下）》）!
于是这个事把我们逼到了最后一种情况 —— IP地址冲突了！
Linux下看IP地址冲突还不是一件比较简单事的，而在用户的生产环境下没有办法安装一些其它的命令，所以只能用已有的命令，这个时候，我们发现用户的机器上有 arping 于是我们用这个命令来检测有没有冲突的IP地址。使用了下面的命令：

$ arping -D -I docker0 -c 2 10.233.14.145
$ echo $?

根据文档，-D 参数是检测IP地址冲突模式，如果这个命令的退状态是 0 那么就有冲突。结果返回了 1 。而且，我们用 arping IP的时候，没有发现不同的mac地址。 这个时候，似乎问题的线索又断了。
因为客户那边还在处理一些别的事情，所以，我们在时断时续的情况下工作，而还一些工作都需要用户完成，所以，进展有点缓慢，但是也给我们一些时间思考问题。
柳暗花明
现在我们知道，IP冲突的可能性是非常大的，但是我们找不出来是和谁的IP冲突了。而且，我们知道只要把这台机器重启一下，问题一定就解决掉了，但是我们觉得这并不是解决问题的方式，因为重启机器可以暂时的解决掉到这个问题，而如果我们不知道这个问题怎么发生的，那么未来这个问题还会再来。而重启线上机器这个成本太高了。
于是，我们的好奇心驱使我们继续调查。我让用户 kubectl delete 其中两个有问题的pod，因为本来就服务不断重启，所以，删掉也没有什么问题。删掉这两个pod后（一个是IP为 10.233.14.145 另一个是 10.233.14.137），我们发现，kubernetes在其它机器上重新启动了这两个服务的新的实例。然而，在问题机器上，这两个IP地址居然还可以ping得通。
好了，IP地址冲突的问题可以确认了。因为10.233.14.xxx 这个网段是 docker 的，所以，这个IP地址一定是在这台机器上。所以，我们想看看所有的 network namespace 下的 veth 网卡上的IP。
在这个事上，我们费了点时间，因为对相关的命令也 很熟悉，所以花了点时间Google，以及看相关的man。

首先，我们到 /var/run/netns目录下查看系统的network namespace，发现什么也没有。
然后，我们到 /var/run/docker/netns 目录下查看Docker的namespace，发现有好些。
于是，我们用指定位置的方式查看Docker的network namespace里的IP地址

这里要动用 nsenter 命令，这个命令可以进入到namespace里执行一些命令。比如

$ nsenter --net=/var/run/docker/netns/421bdb2accf1 ifconfig -a

上述的命令，到 var/run/docker/netns/421bdb2accf1 这个network namespace里执行了 ifconfig -a 命令。于是我们可以用下面 命令来遍历所有的network namespace。

$ ls /var/run/docker/netns | xargs -I {} nsenter --net=/var/run/docker/netns/{} ip addr 

然后，我们发现了比较诡异的事情。

10.233.14.145 我们查到了这个IP，说明，docker的namespace下还有这个IP。
10.233.14.137，这个IP没有在docker的network namespace下查到。

有namespace leaking？于是我上网查了一下，发现了一个docker的bug &#8211; 在docker remove/stop 一个容器的时候，没有清除相应的network namespace，这个问题被报告到了 Issue#31597 然后被fix在了 PR#31996，并Merge到了 Docker的 17.05版中。而用户的版本是 17.09，应该包含了这个fix。不应该是这个问题，感觉又走不下去了。
不过， 10.233.14.137 这个IP可以ping得通，说明这个IP一定被绑在某个网卡，而且被隐藏到了某个network namespace下。
到这里，要查看所有network namespace，只有最后一条路了，那就是到 /proc/ 目录下，把所有的pid下的 /proc/&lt;pid&gt;/ns 目录给穷举出来。好在这里有一个比较方便的命令可以干这个事 ： lsns
于是我写下了如下的命令：

$ lsns -t net | awk ‘{print $4}' | xargs -t -I {} nsenter -t {}&amp;nbsp;-n ip addr | grep -C 4 &quot;10.233.14.137&quot;

解释一下。

lsns -t net 列出所有开了network namespace的进程，其第4列是进程PID
把所有开过network namespace的进程PID拿出来，转给 xargs 命令
由 xargs 命令把这些PID 依次传给 nsenter 命令，

xargs -t 的意思是会把相关的执行命令打出来，这样我知道是那个PID。
xargs -I {}  是声明一个占位符来替换相关的PID



最后，我们发现，虽然在 /var/run/docker/netns 下没有找到 10.233.14.137 ，但是在 lsns 中找到了三个进程，他们都用了10.233.14.137 这个IP（冲突了这么多），而且他们的MAC地址全是一样的！（怪不得arping找不到）。通过ps 命令，可以查到这三个进程，有两个是java的，还有一个是/pause （这个应该是kubernetes的沙盒）。
我们继续乘胜追击，穷追猛打，用pstree命令把整个进程树打出来。发现上述的三个进程的父进程都在多个同样叫 docker-contiane 的进程下！
这明显还是docker的，但是在docker ps 中却找不道相应的容器，什么鬼！快崩溃了……
继续看进程树，发现，这些 docker-contiane 的进程的父进程不在 dockerd 下面，而是在 systemd 这个超级父进程PID 1下，我靠！进而发现了一堆这样的野进程（这种野进程或是僵尸进程对系统是有害的，至少也是会让系统进入亚健康的状态，因为他们还在占着资源）。
docker-contiane 应该是 dockerd 的子进程，被挂到了 pid 1 只有一个原因，那就是父进程“飞”掉了，只能找 pid 1 当养父。这说明，这台机器上出现了比较严重的 dockerd 进程退出的问题，而且是非常规的，因为 systemd 之所以要成为 pid 1，其就是要监管所有进程的子子孙孙，居然也没有管理好，说明是个非常规的问题。（注，关于 systemd，请参看《Linux PID 1 和 Systemd 》，关于父子进程的事，请参看《Unix高级环境编程》一书）
接下来就要看看 systemd 为 dockerd 记录的日志了…… （然而日志只有3天的了，这3天dockerd没有任何异常）
总结
通过这个调查，可以总结一下，
1） 对于问题调查，需要比较扎实的基础知识，知道问题的成因和范围。
2）如果走不下去了，要重新梳理一下，回头仔细看一下一些蛛丝马迹，认真推敲每一个细节。
3） 各种诊断工具要比较熟悉，这会让你事半功倍。
4）系统维护和做清洁比较类似，需要经常看看系统中是否有一些僵尸进程或是一些垃圾东西，这些东西要及时清理掉。
最后，多说一下，很多人都说，Docker适合放在物理机内运行，这并不完全对，因为他们只考虑到了性能成本，没有考虑到运维成本，在这样512GB中启动几百个容器的玩法，其实并不好，因为这本质上是个大单体，因为你一理要重启某些关键进程或是机器，你的影响面是巨大的。
&nbsp;
———————— 更新 2018/12/10 —————————
问题原因
这两天在自己的环境下测试了一下，发现，只要是通过 systemctl start/stop docker 这样的命令来启停 Docker， 是可以把所有的进程和资源全部干掉的。这个是没有什么问题的。我唯一能重现用户问题的的操作就是直接 kill -9 &lt;dockerd pid&gt; 但是这个事用户应该不会干。而 Docker 如果有 crash 事件时，Systemd 是可以通过 journalctl -u docker 这样的命令查看相关的系统日志的。
于是，我找用户了解一下他们在Docker在启停时的问题，用户说，他们的执行 systemctl stop docker 这个命令的时候，发现这个命令不响应了，有可能就直接按了 Ctrl +C 了！
这个应该就是导致大量的 docker-containe 进程挂到 PID 1 下的原因了。前面说过，用户的一台物理机上运行着上百个容器，所以，那个进程树也是非常庞大的，我想，停服的时候，系统一定是要遍历所有的docker子进程来一个一个发退出信号的，这个过程可能会非常的长。导致操作员以为命令假死，而直接按了 Ctrl + C ，最后导致很多容器进程并没有终止……
&nbsp;
其它事宜
有同学问，为什么我在这个文章里写的是 docker-containe 而不是 containd 进程？这是因为被 pstree 给截断了，用 ps 命令可以看全，只是进程名的名字有一个 docker-的前缀。
下面是这两种不同安装包的进程树的差别（其中 sleep 是我用 buybox 镜像启动的）

systemd───dockerd─┬─docker-contained─┬─3*[docker-contained-shim─┬─sleep]
                  │                 │                    └─9*[{docker-containe}]]
                  │                 ├─docker-contained-shim─┬─sleep
                  │                 │                 └─10*[{docker-containe}]
                  │                 └─14*[{docker-contained-shim}]
                  └─17*[{dockerd}]


systemd───dockerd─┬─containerd─┬─3*[containerd-shim─┬─sleep]
                  │            │                 └─9*[{containerd-shim}]
                  │            ├─2*[containerd-shim─┬─sleep]
                  │            │                    └─9*[{containerd-shim}]]
                  │            └─11*[{containerd}]
                  └─10*[{dockerd}]


顺便说一下，自从 Docker 1.11版以后，Docker进程组模型就改成上面这个样子了.

dockerd 是 Docker Engine守护进程，直接面向操作用户。dockerd 启动时会启动 containerd 子进程，他们之前通过RPC进行通信。
containerd 是dockerd和runc之间的一个中间交流组件。他与 dockerd 的解耦是为了让Docker变得更为的中立，而支持OCI 的标准 。
containerd-shim  是用来真正运行的容器的，每启动一个容器都会起一个新的shim进程， 它主要通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID）， 和运行命令（默认为 runc）来创建一个容器。
docker-proxy 你有可能还会在新版本的Docker中见到这个进程，这个进程是用户级的代理路由。只要你用 ps -elf 这样的命令把其命令行打出来，你就可以看到其就是做端口映射的。如果你不想要这个代理的话，你可以在 dockerd 启动命令行参数上加上：  --userland-proxy=false 这个参数。

更多的细节，大家可以自行Google。这里推荐两篇文章：

Docker, Containerd &amp; Standalone Runtimes — Here’s What You Should Know
Docker components explained

（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章Docker基础技术：Linux CGroupDocker基础技术：DeviceMapperDocker基础技术：AUFSDocker基础技术：Linux Namespace（下）Docker基础技术：Linux Namespace（上）Linux PID 1 和 Systemd
</content>
</doc><doc>
    <docid>218</docid>
    <url>https://coolshell.cn/articles/18360.html</url>
    <title>程序员练级攻略（2018)  与我的专栏</title>
    <content>写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自信向大家推荐我的这个专栏了。推荐就从最新的这一系统的文章开始。
2011年，我在 CoolShell 上发表了 《程序员技术练级攻略》一文，得到了很多人的好评（转载的不算，在我的网站上都有近1000W的访问量了）。并且陆续收到了一些人的反馈，说跟着这篇文章找到了不错的工作。几年过去，也收到了好些邮件和私信，希望我把这篇文章更新一下，因为他们觉得有点落伍了。是的，老实说，抛开这几年技术的更新迭代不说，那篇文章写得也不算特别系统，同时标准也有点低，当时是给一个想要入门的朋友写的，所以，非常有必要从头更新一下《程序员练级攻略》这一主题。
目前，我在我极客时间的专栏上更新《程序员练级攻略（2018版）》。升级版的《程序员练级攻略》会比Coolshell上的内容更多，也更专业。这篇文章有【入门篇】、【修养篇】、【专业基础篇】、【软件设计篇】、【高手成长篇】五大篇章，它们会帮助你从零开始，一步步地，系统地，从陌生到熟悉，到理解掌握，从编码到设计再到架构，从码农到程序员再到工程师再到架构师的一步一步进阶，完成从普通到精通到卓越的完美转身……
这篇文章是我写得最累也是最痛苦的文章，原因如下：

 学习路径的梳理。这是一份计算编程相关知识地图，也是一份成长和学习路径。所以有太多的推敲了，知识的路径，体，地图……这让我费了很多工夫，感觉像在编写一本教材一样，即不能太高大上，也不能误人子弟。
新旧知识的取舍。另外，因为我的成长经历中很多技术都成了过去时，所以对于新时代的程序员应该学习新的技术，然后，很多基础技术在今天依然管用，所以，在这点上，哪些要那些不要，也花了我很多的工夫。
文章书籍的推荐。为了推荐最好的学习资料和资源，老实说，我几乎翻遍了整个互联网，进行了大量的阅读和比较。这个过程让我也受益非浅。一开始，这篇文章的大小居然在500K左右，太多的信息就是没有信息，所以在信息的筛选上我花费了很多的工夫，删掉了60%的内容。但是，依然很宠大。

总之，你一定会被这篇文章的内容所吓到的，是的，我就是故意这样做的，因为，这本来就没有什么捷径，也不可能速成，很多知识都是硬骨头，你只能一口一口的啃，我故意这样做就是为了让你不要有“速成”的幻想，也可以轻而一举的吓退那些不想用功不想努力的人。
但是，我们也要知道《易经》有云：“取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也”。所以，我这里会给你立个比较高标准，你要努力达到，相信我，就算是达不到，也会比你一开始期望的要高很多……
下面是这份练级攻略的目录，目前只在极客时间上发布，你需要付费阅读（在本文最后有相关的二维码）。


&nbsp;
那么，除程序员练级攻略外，我还写了哪些内容？下面是迄今为止我所有的文章的目录。你可以在下面看一下相关的目录。这也算是我开收费专栏来8个月给大家的一份答卷吧。我也没有想到，我居然写了这么多的文章，而且对很多人都很有用。
首先是个人成长和经验之谈的东西，在这里的文章还没有完全更新完，未来要更新什么我也不清楚，但是可以呈现出来的内容和方向如下所示，供你参考。对于个人成长中的内容，都是我多年来的心得和体会，从读者的反馈来看是非常不错的，你一定要要阅读的。

分布式系统架构，我一共出了两个系列，一个是分布式系统架构的本质，另一个是设计模式。前者偏概念，后者偏技术。这里旨在让你看到整个分布式系统设计的一个非常系统的蓝图，但是因为在手机端上，不可能写得非常细，所以，会缺失一些细节，这些细节我是故意缺失的，主要是有几方面的原因，

一方面，这是为了阅读的效果，手机上的文章不过长，所以，不能有太多的细节。
另一方面，也是是想留给大家自行学习，而不是一定要我把饭喂到你的嘴里，你才能吃得着。学习不只是为要答案，而是学方法
最后是我的私心，因为我也在创业，所以，技术细节上东西正是我在做的产品，所以，如果你想了解得更细，你需要和我有更商业合作。


&nbsp;



区块链的技术专栏本来不在我的写作计划中的，但是因为来问我这方面的技术人太多了，所以，就被问了一系列的文章，这里的文章除了一些技术上的科普，同样有有很多我的观点，你不但可以学到技术，还可以了解一些金融知识和相关的逻辑，我个人觉得这篇文章是让你有独立思考的文章。

我的专栏还在继续，接下来还有一个系列的文章——《从技术到管理》，欢迎关注，也欢迎扫码订阅。
最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！
&nbsp;

（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章关于高可用的系统程序员技术练级攻略从Gitlab误删除数据库想到的对技术的态度如何学好C语言Leetcode 编程训练
</content>
</doc><doc>
    <docid>219</docid>
    <url>https://coolshell.cn/articles/18246.html</url>
    <title>关于我”极客时间“的专栏</title>
    <content>不少朋友都知道我在“极客时间”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，也就是差不多两个半月的时间。新的一年开始了，写专栏这个事对我来说是第一次，在这个过程中有一些感想，所以，我想在这里说一下这些感受和一些相关的故事，算是一个记录，也算是对我专栏的正式介绍，还希望能得到、大家的喜欢和指点。（当然，CoolShell这边还是会持续更新的）
为什么要开设一个收费专栏
首先，说一下，为什么要开这个收费专栏。
老实说，我一开始根本就不想开收费专栏的，是的，完全不想！主要是有两个原因，一方面是我在创业中，我自然是没有太多的时间，另一方面是，我以前在《为什么我不在微信公众号上写文章》也说过，我觉得知识最好的方式是被检索、讨论、引用、整理、补充和更新。所以，收费这种模式，我感觉并不利于很好的传播。但是，我为什么还干了这么一件事？这事还得从2017年6月份开始说起。
这个月，一共有三家技术社区来找我，都是希望我能去他们那边开收费专栏，其中一家就是“极客邦科技”。对于这三家来说，从一开始我就是以婉拒的姿态回应的。而“极客邦科技”来找我的时候和我说，一周写五篇，写一年，一共260篇。我当时心想，“去你的，当我啥呢，你们真以为技术文章好写啊&#8221;？然后，他们问我可以写多少，我说，我现在也就一个月一篇的节奏……

然后，就开始了时间漫长的拉锯战。极客邦这边一直从6月份和我谈到9月份，完全就是不达目的不罢休的玩法，其间，每当我说一个问题，他们就会想出一个解，我这边不断地制造不能写下去的问题，他们就不断的给出相应的解。我其实是想让他们知难而退，另外，我也不确定这帮人对于这个事有多上心，因为写技术文章是需要非常认真的态度的，所以，我提出了很多比较苛刻的条件，甚至也很直白的直接拒绝，但是他们完全就跟没有听见似的，不断的想新的方法来让我&#8221;上床&#8221;（对！就是上床，不是上船）。

我说，我最多一个月写2-3篇。他们和我说，我们看过了，你写的都是长文，都在5000字左右，一篇可以拆成上下篇，这样就有6篇左右了，然后，你每个月再来两篇文章，一篇是推荐一些资料或资源，一篇是回答读者的问题。这样就有8篇了，一周就可以发2篇了。


我说，就算是这样，我也没有时间写，我现在创业中，事多得去了，完全没精力投入。然后，他们说，不用你写，我们来帮你写。你去客户那边，叫上我们，你到大会上做分享，叫上我们，你和别人分享，也叫让我们，我们全程录音，然后帮你你整理。然后每周末的时候来找你，和你聊上2个小时。我们把内容做出来，你再精编一下就好了。而且，我们也会帮你分担创业的精力的，我们极客邦/QCon/ArchSummit会帮你的产品做推广、做市场和BD客户……


我说，就算是这样，我也没时间。他们说，我们还会给你配个编辑，一个不够就配两个，他们会帮你上网查资料，他们都是计算机专业的，一定是懂技术的。不会让你一个人写的。专栏这种事一定是会需要一个小的编辑团队的。

他们还甚至在晚上10点左右跑到我家门口来和我谈。这还没完，我继续刁难他们……

我说，技术文章相当专业，你们来试试看，于是，我给了一篇极其难读的英文论文，还有一篇技术细节非常晦涩的英文文章，我让他们不要翻译，而是读懂后理解完用自己的话，能够让一般人读懂的话写一下。这两篇文章，就算是对于有多年经验的程序员来说，也是很难读的。结果他们一周后，就搞好了，我读了一下，不算特别好，但是对于他们来说，已经很不错了。


我又说，我的文章中会有好些代码，有数学公式，在手机上怎么排版？阅读体验不行吧。你们还要做音频，我的文章中如果有代码，有图片，有数据公式，你让音频时怎么读？这不行吧。他们说，数学公式可以用LaTeX搞，代码排版会努力排好，同时也提供网页端的浏览。音频会这样搞，会让编辑把代码、数学公式、图片理解完后用别外的话说出来。也就是说，文章要有两个版本，一个是阅读的版本，一个是给音频师的版本。

就这样，这几个月的过程中，我心里面有了一些不一样的感觉。

一方面，我觉得这种“不达目的不罢休”的做法让我欣赏。因为我也在创业，创业的过程中有很多难题，也会遇到很多困难和艰辛。而极客邦他们这样的作法我是非常认可，也是非常佩服的，因为，要是换作我，我可能早放弃去寻找其它人了。但是他们没有，他们一直不断地在穷尽一切方法来说服我写专栏。能这样做的人，我觉得这个社会上少之又少，绝大多数人都是畏难和容易退缩的，所以，感觉可以深入交往和合作。


另外一方面，在整个过程中，我问他们，为什么你们要把这个事做得这么“重”？为什么不做得“轻”一点呢？还要录音频，音频对于技术型的文章里面有一堆坑啊，对于技术文章还有很多无法翻译的英文单词，在计算机的世界里，好多英文单词都是造出来的，音频师怎么读？(后来的确也是这样，我的音频师就把J2EE读成了“J二EE”)，他们的编辑也不知道怎么读，就上Youtube上找相关视频看老外是怎么发音的，然后标注好。而且，我的文章有时候写得太快，经常会有一些小错误，文字好改，但是还要改语音。对于这些，我都觉得好重啊，结果他们说，就是要做个“重的”，就是要做一个别人达不到的标杆，让竞争对手望而却步！

对于这两点，是让我很赞的。这样的做事精神和态度让我很佩服，是啊，在Amazon里也常说，要不断地提高标准。而且这让我深入思考了一下，一个事如果想要做好，做到极致，就算再简单的事，也会变成复杂，这个世界上可能并不存在“轻模式”，只要你想做好，再“轻”的事都会变“重”。他们的这些做法，让我有了一种同道中人的感觉，人总是会向比自己强的人或是跟自己比较像的人靠近的。我感觉我在创业路上，就是要和这样的人在一起，面对再难的事，都要想尽一切办法解决之，面对再轻的事，都要花心思用重的模式去做好。
而其它两个来找我做同样的事的公司，却没有让我看到他们有这样把事做成的不服输的决心和态度，真是形成了强烈的反差和对比。
于是，我就这样“从”了！这里要点名一下极客邦的两个人——我叫他们作“双蕾”：司巧蕾 和 郭蕾。（池大大也为极客时间付出了好多，因为大家都认识他了，我就弱化他一下了，嘿嘿）
这个专栏主要会写什么样的内容
这是一个收费专栏，一旦收费了，我的压力也大了，因为你要写的内容就一定要能达到可以收费的价值了，不以再像个人博客一样，想写什么就什么。好在我从2003年开始我就在给好多企业做一些商业化的讲座和培训，也给一些公司做过一些商业的咨询和技术方案，包括在过去两年内帮助过一些公司打单。另外，在过去的10年内，我也在技术、职业和成长上帮助过很多年轻人。这些内容，我都没有完整或是具体地写在CoolShell中，所以，我觉得这些内容是可以放在这个收费专栏的。
此外，我在CoolShell上的文章都是不系统的，是碎片式的，还有一些只是知识，还不是认识。而我过去成长的20年，我的经验和知识已经在某些方面形成了比较完整的体系，而且有一些技术也能看到本质上的东西。所以，我觉得这些东西是可以呈现在这个专栏内的，都是非常有商业价值的，一定是可以帮助到大家的。当然，其中的一些东西，不是初级入门的程序员能够看懂的，需要有一定的工作经验和基础知识。
而在我入行的这20年来，我觉得对于一个企业，一个团队，一个个体的程序员来说，有三件事是密不可分，也是相辅相成的，这三件事就是：技术、发展和管理。每个人，每个团队，每个企业，都需要认真地面对技术，不断地挑战新的技术，并且还要非常认真地发展个人和团队，而这些都需要对自我的管理或是对团队和公司的管理才能更高效的达成。
所以，我的专栏会由这三部份构成:

技术。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点大家可以自行Google可以RTFM。我要写就一定是以体系化的，而且要能直达技术的本质。我入行这20年来，我最擅长的是针对各种大规模的系统，所以，我会有2-3个和分布式系统相关的系列文章，然后，我学过也用过好多编程语言，所以，我也会有一系列的关于编程本质的文章，而我对一些基础知识研究的也比较多，所以，还会有一系列的和基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括，我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让大家有醍醐灌顶的感觉。


成长。在过去这20年中，我感觉得到，很多人都会非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的一定和个人发展相关的文章。比如，像技术变现啊、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个Leader……这些东西一定会对大家有用。但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。


管理。这20年，我觉得做好技术工作，得做好技术的管理工作，只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术都是管理上的问题。所以，我会写上一系列的和管理相关的文章，管理三个要素，团队、项目和管理者自己。所以，我会从这三个方面写一系列包括，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任何排期、会议、远程管理……等等一系列的文章。这些东西都是我在外企时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给大家。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。

现在，我这个专栏写了快三个月了，第一部分和第二部分已经有一些呈现了。我周末和假期的时间也完全都搭进去了 ;-)。后面的文章还在和我的编辑一起在整理和书写中，我感觉这个专栏只收199一年简直是太便宜了，我有点想涨价的冲动了。哈哈。
幕后团队
最后说一下我的专栏编辑——她叫杨爽！以前是CSDN的程序员杂志的编辑，后来去了七牛，现在和我一起做我的这个专栏。她对我的这个专栏上的投入非常大，除了帮助我编辑文章，还要帮音频师标注语气，英文发音，以及音频版的文章，还要深度参与写作，有的文章我只给了一个大纲，甚至只是一个方向，或是一系列的素材，然后都是她来操刀的，比如“推荐阅读”的文章、还有技术领导力的下篇，基本上是由杨爽来出第一版，然后我再上面再做修改和补充。她说，写技术文章真是太累了，尤其是帮你编辑你的分布式系列的文章，我基本都把这些技术都看了个大概了。我调侃到，如果你完全搞懂了，你就不用做编辑了，你可以做技术去了，嗯，而且，可以变成架构师了。
另外，她会深度的编辑我的文章，尤其是每篇文章最后的一些总结或是一些问题都是她写的。在我的一篇答疑的文章中，她自己加入了一个观点——“很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题出发点、思维方式、格局观、价值观等因素的影响”，这个观点被读者当成是我的观点，其实，这是杨爽的观点，当然我也很同意。
所以，我的这个专栏离不开杨爽的付出，我和她一般都是在晚上或是周末沟通，因为平时我的时候都被创业的事给占据了。所以，她也只能适配我的时间，但她真的很努力，我能感觉得到她想把文章的质量不断提高的迫切。
关于专栏的音频师，他叫柴巍，是天津广播电台的主持人，一个89年的小伙子，网上他的个人信息在这里。他跨界来读这些技术文章的确对他来说非常不容易，因为一方面这文章里讲的这些东西他都看不懂，另外，他也不认识我，我脾气和性格他不知道，所以，他读我的文章里，并不能完全准确地把握相关的语气。这就需要杨爽来帮他标注和调整，有些地方，不断地修改，不断地录，大家知道，录音和写文章不一样，文章要修改很简单，语音要修改就非常麻烦，得把上下文全都一并重新再读一篇，这个过程的确难，杨爽在其中也花费了大量的时间和这个小伙子沟通和调整。
在一开始，有播音腔，也被读者吐槽了，他自己后来一直在调整，目前越来越符合咱们的要求。这个小哥是非常努力和有挑战精神的，他在这个过程中，也是非常信守承诺的。去年12月6日，录分布式系统冰与火那篇文章时，他上午有自己的工作，下午要开会，晚上又有单位活动，他还是活动的主持人，他实在是没有时间了。我也和我的编辑说，算了，先发文章，后面再补音频。但是他还是挤时间把音频录出来了，期间，我还不知情地又修改了一下文章，他又配合修改，直到完全改好。打车去参加活动，还好提前20分钟赶到，没有耽误主持活动。
唠唠叨叨写这么多，也没什么干货！算是一份记录吧。也希望大家能够从我的专栏中看到这个团队的确是在用心做事的，是的，能认识这些人，还能一起合作，在我的人生经历上是非常有价值的事了。
希望大家在新的一年里也能遇到这样的人。我们一起加油！

图片来自：电影《速度与激情》——Ride or Die
&nbsp;
（全文完）
&nbsp;

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章DHH 谈混合移动应用开发Google Inbox如何跨平台重用代码？HTML6 展望两本电子书一些文章资源和趣闻一些非常有意思的杂项资源
</content>
</doc><doc>
    <docid>220</docid>
    <url>https://coolshell.cn/articles/18190.html</url>
    <title>Go语言、Docker 和新技术</title>
    <content>上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章“Go: Ten years and climbing”中，回顾了一下 Go 语言的发展过程。其中提到，Go 语言这十年的迅猛发展大到连他们自己都没有想到，并且还成为了云计算领域中新一代的开发语言。还提到了，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。
这让我想起，我在 2015 年 5 月份拜访 Docker 公司在湾区的总部时，Docker 负责人也和我表达了相似的感叹：他们完全没有想到居然中国有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外。此外，还跟我说，中国是除了美国本土之外的另一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。
的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到其发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到非常高兴的事，因为中国在跟随时代潮流这件事上已经做得非常不错了。
然而，从 2014-2015 年我在阿里推动 Docker 和 Go 语言的痛苦和失败过程中，以及这许多年来，有很多很多人问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 是否能用在生产线上，这些问题看来，对于 Go 语言和 Docker 这两种技术，在国内的技术圈中有相当大的一部分人和群体还在执观望或是不信任的态度。
所以，我想写这篇文章，从两个方面来论述一下我的观点和看法。

一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。
另一个方面，作为技术人员，我们如何识别什么样的新技术会是未来的趋势。

这两个问题是相辅相成的，所以我会把这两个问题揉在一起谈。

虽然 Go 语言是在 2009 年底开源的，但我是从 2012 年才开始接触和学习 Go 语言的。我只花了一个周末两天的时间就学完了，而且在这两天，我还很快地写出了一个能工作很好的网页爬虫程序，以及一个简单的高并发文件处理服务，用于提取前面抓取的网页的关键内容。这两个程序都很简单，总共才写了不到 500 行代码。
我当时对 Go 语言有几点体会。
第一，语言简单，上手快。Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。
第二，并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的我来说，完全就是让我眼前一亮的感觉。

（图片来自 Medium：Why should you learn Go?）
第三，Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。
第四，C 语言的理念和 Python 的姿态。C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

（图片来自 Medium：Why should you learn Go?）
所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。
当然，一个技术能不能发展起来，关键还要看三点。

有没有一个比较好的社区。像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。
有没有一个工业化的标准。像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。
有没有一个或多个杀手级应用。C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。

上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：

学习曲线是否低，上手是否快。这点非常重要，C++ 在这点上越做越不好了。
有没有一个不错的提高开发效率的开发框架。如：Java 的 Spring 框架，C++ 的 STL 等。
是否有一个或多个巨型的技术公司作为后盾。如：Java 和 Linux 后面的 IBM、Sun……
有没有解决软件开发中的痛点。如：Java 解决了 C 和 C++ 的内存管理问题。

用这些标尺来量一下 Go 语言，我们可以清楚地看到：

Go 语言容易上手；
Go 语言解决了并发编程和写底层应用开发效率的痛点；
Go 语言有 Google 这个世界一流的技术公司在后面；
Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。

所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。
也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。
好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。

Docker 上手很容易。
Docker 解决了运维中的环境问题以及服务调度的痛点。
Docker 的生态圈中有大公司在后面助力。比如 Google。
Docker 产出了工业界标准 OCI。
Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。
……

所以，早在 3、4 年前我就觉得 Docker 一定会是未来的技术。虽然当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。
同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。这点我在去年初就能够很明显地感觉到了。
关于 Docker 我还想多说几句，这是云计算中 PaaS 的关键技术，虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。但我还是想说，PaaS 是一个被世界或是被产业界严重低估的平台。
PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司。因为 PaaS 层的技术主要能解决下面这些问题。

软件生产线的问题。持续集成和持续发布，以及 DevOps 中的技术必需通过 PaaS。
分布式服务化的问题。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。
提高服务的可用性 SLA。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。
软件能力的复用。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。

老实说，这些问题的关键程度已经到了能判断一家依托技术的公司的研发能力是否靠谱的程度。没有这些技术，依托技术拓展业务的公司几乎没有可能发展得规模很大。
在后面，我会在“极客时间”我的付费专栏里另外写几篇文章详细地讲一下分布式服务化和 PaaS 平台的重要程度。
最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。
技术的发展过程非常重要。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，到 2013 年学习 Docker 到今天，我清楚地看到了这两种技术的生态圈发展过程。让我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。
从中，我看到了非常具体的各种思潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。我不但有了技术优势，而且这些知识还让我的技术生涯多了很多的可能性。
这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。
一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。
近期，在与中国移动、中国电信以及一些股份制银行进行交流的过程中，我已看到通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司，而我近 3 年来在这些技术上的研究让我也从中受益非浅。
所以，Go 语和 Docker 作为 PaaS 平台的关键技术前途是无限的，我很庆幸赶上了这个浪潮，也很庆幸在 3 年前我就看到了这个趋势，现在我也在用这些技术开发相关的技术产品，助力于为高速成长的公司提供这些关键技术。
&nbsp;
最后注明一下：
这篇文章于上周发布于“极客时间”的我的付费专栏中。极客时间中的付费是我受Geekbang邀请写的一个付费专栏，因为过去10多年给企业有过很多内训，过去2年又给好多企业做过一些咨询工作，所以，我会把一些商业化的内容写在极客时间里，当然，也会有一些我的新文章。关于这个事，我后面我专门开一篇文章说一下。（大家可以到 Apple的App Store上搜极客时间，Android版本等到12月初吧）

（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章Go语言的修饰器编程Go 语言简介（上）— 语法Go 语言简介（下）— 特性Docker基础技术：Linux Namespace（上）Docker基础技术：DeviceMapperDocker基础技术：Linux Namespace（下）
</content>
</doc><doc>
    <docid>221</docid>
    <url>https://coolshell.cn/articles/18140.html</url>
    <title>关于Facebook 的 React 专利许可证</title>
    <content>随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《React, Facebook, and the Revocable Patent License, Why It&#8217;s a Paper》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)
这篇文章的作者叫Dennis Walsh，他自称是亚历桑那和加利福尼亚州的律师，主要针对版权法和专利诉论的法律领域。但是这个律师不一样，他更很喜欢商业和软件多一些。现在他用React/GraphQL/Elixir在写一个汽车代理销售相关的软件，而且已经发布到第2版了。
首先，作者表明，专利法经常被人误解，因为其实充满了各种晦涩难懂的法律术语，所以，作者用个例子来讲述专利的一个原则 —— 专利并不是授于让你制造或开发的权利，而是授予你可以排他的权利。（事实上似乎也是这样，申请专利很多时候都不是为了制作相关的产品，而是为了防止别人使用类似的技术制作相关的产品）

如果有公司X为铅笔申请了专利，而另一家公司Y为把用于铅笔的橡皮擦申请了专利。那么，公司X可以阻止公司Y来生产铅笔，而对带橡皮擦的铅笔没办法，但是公司Y的专利可以让公司X不能生产带有橡皮擦的铅笔。
所以，公司Y的橡皮擦专利又被广泛地叫作“Blocking Patent”。公司Y不能说他发明了铅笔，因为这是公司X的专利，但是，他们可以让公司X无法对铅笔做出某些改进。
于是，因为这种 Blocking Patent 存在，对于开源的公司是不利的，因为根据上面的那个例子来说，开源公司就是公司X，他们做了一个基础的软件，而公司Y在上面做了些改进，并注册成了专利，从而导致开源的公司X无法对它基础开源软件作出被公司Y专利阻止的改进，开源的公司X希望能够自由地使用公司Y的橡皮擦专利，因为毕竟是它发明了铅笔并放弃了铅笔的专利。
于是就出来了“专利反击条款”（Patent Retaliation Clauses）。一般来说有两种专利条款，一种是弱条款，一种是强条款。
Weak Patent Retaliation Clauses &#8211; 这种条款声明，如果许可证持有者用某个专利来打击许可证颁布者，那么专利就视为终止。用人话来表达就是，公司X做了一个开源铅笔，而公司Y注册了橡皮檫专利。此时，公司X做了一支带像皮擦的铅笔，而公司Y马上对公司X提起专利侵权诉讼。那么，公司Y就失去了对底层铅笔的专利控制。（正如前面所说的，公司Y的橡皮擦专利因为在起诉公司X的开源铅笔，而失去了对开源铅笔的专利排他权利）
Strong Patent Retailiation Clauses &#8211; 这种条款声明比“弱条款”要的更多。具体来说就是，任何专利声明终结许可证，而不管这个专利有没有和你基础的软件有关系。用人话来说就是，公司Y使用他们的热气球专利来起诉公司X，那么公司Y就失去了他们对铅笔的专利限制。
我个人理解起来，这两种条款看上去是防御性质的。
Facebook的React的Patent License如下：
The license granted hereunder will terminate, automatically and without notice,if you (or any of your subsidiaries, corporate affiliates or agents) initiatedirectly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporateaffiliates, (ii) against any party if such Patent Assertion arises in whole orin part from any software, technology, product or service of Facebook or any ofits subsidiaries or corporate affiliates, or (iii) against any party relating to the Software. Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section (i) of this paragraph due to such counterclaim.
这些条款中和基础软件没有任何关系，所以，这个条款是“强专利反击条款”。
在后面，本文的作者又解解释了，为什么React的“强专利反击条款”就跟没有似的。他在文中针对一些歇斯底里的言论，如：“Facebook不用害怕专利诉讼了，而且他可以随时偷袭你家的专利仓库”，也作出了一些解释来分析这个事。
Contractural Liability &#8211; 意思是说，专利方面的东西只会影响专利上的事，而不会影响和专利无关的事，React底层协议是BSD-3许可证还是会被保留。换句话说，React的“强专利反击条款”只生效于专利层面，而不会对非常专利的软件使用产生问题，如果和专利无关，React还是走BSD-3的许可协议。
Copyright Liability &#8211; 这个和Contractural Liablitity 一样。作者说，如果有人有特别的案例或是有说服力的论据来说明Facebook的这个条款会作用于非专利的地方，那么，请告诉他。
Patent Liability &#8211; 专利的责任和损害是两件事，非专业人士总是会把其搞混。
第一个问题是Liability， 要搞清这个事，得搞清“Patent&#8217;s Claims”，而不是这个技术的技术规格说明，技术规格说明和权力主张是两码事。作者说，现在的很多专利都是一些想法，很多投机份子随便一拍脑袋就发明出一个想法，然后就去注册专利了。但是可以被用来法律执行的只有“Patent&#8217;s Claims”（专利的权利主张），而不是那些想法。这些权利主张相当相当的晦涩难读，而且是会故意被模糊掉的，因为，当你清楚的定义了你的发明是什么，那么，就可以清楚的定义出来什么不是你的发明。比如：一个铅笔专利权利主张里说，“这一个用石墨和木头组合起来的写字工具”，那么，只要我不用木头和石墨来做组合，而是用塑料来做组合，那么我就不是专利侵权。所以，一般来说，专利主张是会更为通用一些，比如，“这是一个用于涂画表面的装置，其包括：与涂画端相连的握持端”。作者这里给了一个苹果公司的滑动解锁专利的示例。可以感受一下产品规格说明和专利权利主张完全是两码事。
专利这些事，在法律界里是非常非常困难作出评估的。所以，这个社会每年都会给律师们几十亿美金来一遍又一遍地回答这些问题，而且律师还经常回答错了。而对于美国的法律，对于专利诉讼会有一个叫Markman hearing的审前听证会（马克曼听证会），自从1996年美国最高法的“马克曼诉威斯幽仪器公司案”这个听证会就变成了一个惯例，美国联邦法院用这个听证会来向决定专利权利主张的解释，而且，上诉法院还经常性的推翻审判法院的裁决。（对于美国法律来说，一般是法官认证法律，陪审团认定事实，然而，对于专利而言，1996年的那个案件认为专利术语是一个需要法官决定的法律问题，而不是陪审团决定的事实问题。关于马克曼听证会的事，可以参看本文未尾的附录）
所以，要决定Facebook的专利责任，我们需要评估Facebook的专利及其权利主张，而不是技术规格说明。具体来说，要明确Facebook对于React这个底层技术的专利权利主张是什么？但是作者搜了一下，发现什么也没有找到。也就是说，对于USPTO（美国专利商标局）或法院来说，他们没办法对Facebook的这样没有为React申请专利的方式来执行任何和专利的诉讼，也就是说，Facebook的这个React License的条款，美国政府是无法在法律上支持的。
第二个问题是专利损害。就算是Facebook可以评估出来一个合法可执行的专利来保护React，对于专利损害也是很有问题的。作者说他到目前还没有发现一个开源软件被专利侵权的事，就算有这样的案例，也不会是这里说的这个事。作者觉得在这个事上操作起来就是一个笑话。
另外，作者认为，React 专利许可证这个事就是个纸老虎。因为，一方面，这个专利不像电信通讯里的那些专利，你拿不掉。作者认为要从你的代码中把React去掉虽然难，但是也不是什么很难的事，另外，要打这样的专利官司，一般来说，在美国至少要花100-200万美金的费用才能发起诉讼，而要胜诉则需要需要200多万到2000万美金的费用，你觉得你要花多钱才能把React从你的代码库中剔除？肯定比这钱少。
作者还认为，Facebook玩这个事虽然出发点不错，但是感觉并不聪明，从目前的情况看下来，就像他想咬你一口，但却没有牙。
后面，作者还说了一下，转成别的框架会不会有问题？比如：你用Preact/Vue或是你自研的东西？作者说，未必，如果Facebook真的为React注册了专利，比如：React里的组件技术、虚拟DOM渲染技术等等。那么，你用Preact/Vue或是带这样技术的自研的框架，那么，从你使用的第一天就在侵犯Facebook的专利权了。然而，使用React反而不会有这么大的风险，因为Facebook让你免费的用React。作者说，用别的框架的法律风险比用其它替代品的风险更高。
后面，作者也更新了一篇文章 《Using GraphQL? Why Facebook Now Owns You》，意思是，用React可能还好，但是用GraphQL就有问题了。因为找到了GraphQL的专利—— “Graph Query Logic”。
后来我查了一下，我发现，React也有个相关的专利—— “Efficient event delegation in browser scripts ”，看上去和虚拟DOM渲染有关。Holy Shit!
好了，用还是不用React我也不知道，总之，这个世界比较复杂，我只是想借这篇文章来学习一下法律上的相关东西，欢迎听到大家的观点。
最后，请允许我调侃一下来结束本文——“不用担心React的许可证问题，因为前端不是一年半就用新的框架重写一次么？”哈哈。
更新：Facebook官方于20017年9月23日在其官方blog上发贴《Relicensing React, Jest, Flow, and Immutable.js》决定取消之前的带专利的许可证。
延伸阅读
马克曼听证会 &#8211; Markman Hearing
马克曼听证会的一些背景知识，下面的文字来源于《&#8220;马克曼听证&#8221;制度的由来及启示》
与美国专利诉讼的悠长历史相比，1996年才经美国最高法院确立的“马克曼听证”（Markman Hearing，也称为Claim Construction，即权利要求书的解释）无疑是一项年轻的制度。但由于几乎所有的专利侵权诉讼中都会遇到涉案专利权利要求书的解释这一核心问题，且因“马克曼听证”结果往往清楚地预示了案件结果，经“马克曼听证”获得有利结论的一方一旦据此向法庭提起不审即判的动议，专利侵权诉讼往往可就此快速了结，因此该制度的确立成为美国专利诉讼历史上的一件大事。
“马克曼听证”制度的由来
“马克曼听证”制度确立之前，在专利侵权诉讼中的权利要求书解释，通常交由陪审团在对案件事实进行裁决时一并做出，且并不会在诉讼文件上单独就陪审团这一问题的判断进行记录。1991年，马克曼（Markman）先生因认为其拥有的专利号为RE33054的“干洗衣物贮存及追踪控制装置”专利权被Westview公司所侵犯，遂向宾夕法尼亚州东区联邦地方法院提起了专利侵权诉讼。
该专利是用扫描的方式，将客户的衣物编号扫描后输入电脑中做分类标示，并在衣物干洗过程中追踪衣物位置，干洗完成后自动将衣物放回客户固定的存贮位置。被告的产品则是同时运用扫描器和电脑两种方式，将客户干洗衣物的资料存入电脑并显示费用、日期等相关信息。本案陪审团的裁决认为被告装置构成对原告专利权利的侵犯，但该地方法院认为系争专利与被告装置在功能实施上并不一致，遂推翻陪审团的裁决，判决被告不构成侵权。
马克曼不服，于1995年向联邦上诉法院提起上诉，但其上诉理由仅为联邦地方法院错误地解释了陪审团关于专利权利要求书解释中某个词语的涵义。联邦上诉法院在审理该案时，将案件的核心问题定为两个：一是原告对于请求项解释有无权利请求陪审团裁决;二是联邦地方法院是否正确地解释了“Inventory”一词。该院多数法官经审理后认为，权利要求书范围的解释与确定，属于法律问题而非事实问题，因而属于法院权限，而不应交由陪审团决定，且此前将此问题交由陪审团确定并不妥当。同时，由于认为原告专利与被告装置存在实质功能上的差异，联邦上诉法院亦不认为被告构成专利侵权。少数持不同意见的该院法官主要是质疑这一结论违反了美国第七宪法修正案（即所有根据美国法律进行的普通法诉讼，只要争议金额超过20美元，即有要求陪审团审判的权利）。
马克曼不服，向最高法院提出上诉。1996年4月23日，美国最高法院就马克曼诉Westview器械公司案（Markman v. Westview Instruments, Inc. 517 U.S. 370 （1996））做出终审裁决，裁决认定：权利要求书的解释是联邦地区法院法官应当处理的法律问题，而不是应当由陪审团来认定的事实问题，尽管在解释权利要求书的过程中可能会包含一些对于事实问题的解释，且这样做并不违反第七修正案赋予给陪审团的权利。这一裁决标志着“马克曼听证”制度的正式确立。
“马克曼听证”制度的不足
该案判决是美国专利诉讼史上的一个重大转折。“马克曼听证”成为法官专门用于解释专利权利要求的一个经常性听证程序，用以解决专利侵权诉讼的核心问题。由于该听证并非普遍适用，因此，十几年来，联邦民事诉讼规则并未正式对其有任何规定，而是给予法院绝对的自由裁量权。但是，何时可以进行“马克曼听证”?如何进行?是否有必要进行?类似问题在一定程度上困扰了审理专利侵权案件较多的法院。
2001年，加州北区联邦地区法院率先制定了供本法院使用的专利审判专属规则（Patent Local Rules），其中第四部分即为权利要求书的解释程序（Claim Construction Proceddings），对“马克曼听证”的时间、流程、限制及当事人的义务均进行了规定。此后，各州纷纷效仿。目前，乔治亚州北区联邦法院、得克萨斯州东区联邦法院、得克萨斯州南区联邦法院、宾夕法尼亚州西区联邦法院等都制订了书面的“马克曼听证”程序指南。近年来，不断有新的案例在解释与细化着“马克曼听证”，如2006年的Wilson Sporting Goods Co.诉Hillerich &amp; Bradsby Co.案，2005年的Phillips诉AWH Corp.案，2008年的Howmedica Osteonics Corp.诉Wright Medical Technology, Inc.案，这些司法实践大大拓展与丰富了“马克曼听证”使用的实体和程序规则，使之日渐成为美国专利诉讼中一个复杂、完备的司法程序。以至于竟然有人开发了模拟“马克曼听证”程序，只要你愿意，可以下载并训练，以熟悉和确保有真正的权利要求书解释时不会出现不利于自己的问题。
但是，该听证带来的问题也逐渐受到重视。有人质疑说该程序导致专利诉讼费用增加，因为“马克曼听证”通常会单独进行，且程序复杂，因此导致当事人花费大量的时间与精力，更为重要的是，由于40%至60%的联邦地区法院案件会在联邦巡回上诉法院被推翻，因此，花费巨大的“马克曼听证”似乎价值有限。同时，权利要求书的解释要求是不多不少，忠实于技术发明思想与发明事实，但由于地区法院分散，法官的相关技术知识不十分专业，将权利要求书解释这样的问题交给他们，难免会带来一些无法克服的问题。
“马克曼听证”制度的启示
我国民事诉讼中并无陪审团制度，案件的事实问题与法律问题均由法官审理与确定。在专利侵权诉讼中，对于案件中涉及到的技术问题可以通过专家鉴定等方式解决，但并不因此免除法官审理案件的义务，即法律问题的判断归于法官，事实的法律属性判断仍然归于法官。同时，权利要求书的解释在我国的专利侵权诉讼中并不是一个单独的程序，而是合并在案件审理过程中。因此，仅就我国的司法审判而言，“马克曼听证”制度并无直接的借鉴意义。
但是，对于那些已经走出和正在走出国门的企业来说，了解与掌握这一重要的专利诉讼程序却是极其重要的。通领科技集团的积极尝试充分证明了这一点，而且随着这一程序的不断成熟，美国国际贸易法院（ITC）也开始在审理时适用“马克曼听证”制度。所以，知道“马克曼听证”意味着什么，确保所提交的用于解释权利要求的文件确实充分，学会利用“马克曼听证”，无论是对于破解美国的专利诉讼威胁，还是为未来准备有效的法律武器，无疑都非常重要。（知识产权报　作者　魏玮）
&nbsp;
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章扎克伯格的一封信：关于Facebook IPOQuora使用到的技术程序员练级攻略（2018)  与我的专栏Facebook 的系统架构Facebook全球关系网AWS 的 S3 故障回顾和思考
</content>
</doc><doc>
    <docid>223</docid>
    <url>https://coolshell.cn/articles/18024.html</url>
    <title>API设计原则 – Qt官网的设计实践总结</title>
    <content>（感谢好友 @李鼎 翻译此文）
原文链接：API Design Principles &#8211; Qt Wiki
基于Gary的影响力上 Gary Gao 的译文稿：C++的API设计指导
译序

Qt的设计水准在业界很有口碑，一致、易于掌握和强大的API是Qt最著名的优点之一。此文既是Qt官网上的API设计指导准则，也是Qt在API设计上的实践总结。虽然Qt用的是C++，但其中设计原则和思考是具有普适性的（如果你对C++还不精通，可以忽略与C++强相关或是过于细节的部分，仍然可以学习或梳理关于API设计最有价值的内容）。整个篇幅中有很多示例，是关于API设计一篇难得的好文章。
需要注意的是，这篇Wiki有一些内容并不完整，所以，可能会有一些阅读上的问题，我们对此做了一些相关的注释。
PS：翻译中肯定会有不足和不对之处，欢迎评论&amp;交流；另译文源码在GitHub的这个仓库中，可以提交Issue/Fork后提交代码来建议/指正。
API设计原则
一致、易于掌握和强大的API是Qt最著名的优点之一。此文总结了我们在设计Qt风格API的过程中所积累的诀窍（know-how）。其中许多是通用准则；而其他的则更偏向于约定，遵循这些约定主要是为了与已有的API保持一致。
虽然这些准则主要用于对外的API（public API），但在设计对内的API（private API）时也推荐遵循相同的技巧（techniques），作为开发者之间协作的礼仪（courtesy）。

如有兴趣也可以读一下 Jasmin Blanchette 的Little Manual of API Design (PDF) 或是本文的前身 Matthias Ettrich 的Designing Qt-Style C++ APIs。
1. 好API的6个特质
API之于程序员就如同图形界面之于普通用户（end-user）。API中的『P』实际上指的是『程序员』（Programmer），而不是『程序』（Program），强调的是API是给程序员使用的这一事实。
在第13期Qt季刊，Matthias 的关于API设计的文章中提出了观点：API应该极简（minimal）且完备（complete）、语义清晰简单（have clear and simple semantics）、符合直觉（be intuitive）、易于记忆（be easy to memorize）和引导API使用者写出可读代码（lead to readable code）。
1.1 极简
极简的API是指每个class的public成员尽可能少，public的class也尽可能少。这样的API更易理解、记忆、调试和变更。
1.2 完备
完备的API是指期望有的功能都包含了。这点会和保持API极简有些冲突。如果一个成员函数放在错误的类中，那么这个函数的潜在用户就会找不到，这也是违反完备性的。
1.3 语义清晰简单
就像其他的设计一样，我们应该遵守最少意外原则（the principle of least surprise）。好的API应该可以让常见的事完成的更简单，并有可以完成不常见的事的可能性，但是却不会关注于那些不常见的事。解决的是具体问题；当没有需求时不要过度通用化解决方案。（举个例子，在Qt 3中，QMimeSourceFactory不应命名成QImageLoader并有不一样的API。）
1.4 符合直觉
就像计算机里的其他事物一样，API应该符合直觉。对于什么是符合直觉的什么不符合，不同经验和背景的人会有不同的看法。API符合直觉的测试方法：经验不很丰富的用户不用阅读API文档就能搞懂API，而且程序员不用了解API就能看明白使用API的代码。
1.5 易于记忆
为使API易于记忆，API的命名约定应该具有一致性和精确性。使用易于识别的模式和概念，并且避免用缩写。
1.6 引导API使用者写出可读代码
代码只写一次，却要多次的阅读（还有调试和修改）。写出可读性好的代码有时候要花费更多的时间，但对于产品的整个生命周期来说是节省了时间的。
最后，要记住的是，不同的用户会使用API的不同部分。尽管简单使用单个Qt类的实例应该符合直觉，但如果是要继承一个类，让用户事先看好文档是个合理的要求。
2. 静态多态
相似的类应该有相似的API。在继承（inheritance）合适时可以用继承达到这个效果，即运行时多态。然而多态也发生在设计阶段。例如，如果你用QProgressBar替换QSlider，或是用QString替换QByteArray，你会发现API的相似性使的替换很容易。这即是所谓的『静态多态』（static polymorphism）。
静态多态也使记忆API和编程模式更加容易。因此，一组相关的类有相似的API有时候比每个类都有各自的一套API更好。
一般来说，在Qt中，如果没有足够的理由要使用继承，我们更倾向于用静态多态。这样可以减少Qt public类的个数，也使刚学习Qt的用户在翻看文档时更有方向感。
2.1 好的案例
QDialogButtonBox与QMessageBox，在处理按钮（addButton()、setStandardButtons()等等）上有相似的API，不需要继承某个QAbstractButtonBox类。
2.2 差的案例
QTcpSocket与QUdpSocket都继承了QAbstractSocket，这两个类的交互行为的模式（mode of interaction）非常不同。似乎没有什么人以通用和有意义的方式用过QAbstractSocket指针（或者 能 以通用和有意义的方式使用QAbstractSocket指针）。
2.3 值得斟酌的案例
QBoxLayout是QHBoxLayout与QVBoxLayout的父类。好处：可以在工具栏上使用QBoxLayout，调用setOrientation()使其变为水平/垂直。坏处：要多一个类，并且有可能导致用户写出这样没什么意义的代码，((QBoxLayout *)hbox)-&gt;setOrientation(Qt::Vertical)。
3. 基于属性的API
新的Qt类倾向于用『基于属性（property）的API』，例如：

QTimer timer;
timer.setInterval(1000);
timer.setSingleShot(true);
timer.start();

这里的 属性 是指任何的概念特征（conceptual attribute），是对象状态的一部分 —— 无论它是不是Q_PROPERTY。在说得通的情况下，用户应该可以以任何顺序设置属性，也就是说，属性之间应该是正交的（orthogonal）。例如，上面的代码可以写成：

QTimer timer;
timer.setSingleShot(true);
timer.setInterval(1000);
timer.start();

【译注】：正交性是指改变某个特性而不会影响到其他的特性。《程序员修炼之道》中讲了关于正交性的一个直升飞机坠毁的例子，讲得深入浅出很有画面感。
为了方便，也写成：

timer.start(1000)；

类似地，对于QRegExp会是这样的代码：

QRegExp regExp;
regExp.setCaseSensitive(Qt::CaseInsensitive);
regExp.setPattern(&quot;.&quot;);
regExp.setPatternSyntax(Qt::WildcardSyntax);

为实现这种类型的API，需要借助底层对象的懒创建。例如，对于QRegExp的例子，在不知道模式语法（pattern syntax）的情况下，在setPattern()中去解释"."就为时过早了。
属性之间常常有关联的；在这种情况下，我们必须小心处理。思考下面的问题：当前的风格（style）提供了『默认的图标尺寸』属性 vs. QToolButton的『iconSize』属性：

toolButton-&gt;setStyle(otherStyle);
toolButton-&gt;iconSize();    // returns the default for otherStyle
toolButton-&gt;setIconSize(QSize(52, 52));
toolButton-&gt;iconSize();    // returns (52, 52)
toolButton-&gt;setStyle(yetAnotherStyle);
toolButton-&gt;iconSize();    // returns (52, 52)

提醒一下，一旦设置了iconSize，设置就会一直保持，即使改变当前的风格。这 很好。但有的时候需要能重置属性。有两种方法：

传入一个特殊值（如QSize()、-1或者Qt::Alignment(0)）来表示『重置』
提供一个明确的重置方法，如resetFoo()和unsetFoo()

对于iconSize，使用QSize()（比如 QSize(–1, -1)）来表示『重置』就够用了。
在某些情况下，getter方法返回的结果与所设置的值不同。例如，虽然调用了widget-&gt;setEnabled(true)，但如果它的父widget处于disabled状态，那么widget-&gt;isEnabled()仍然返回的是false。这样是OK的，因为一般来说就是我们想要的检查结果（父widget处于disabled状态，里面的子widget也应该变为灰的不响应用户操作，就好像子widget自身处于disabled状态一样；与此同时，因为子widget记得在自己的内心深处是enabled状态的，只是一直等待着它的父widget变为enabled）。当然诸如这些都必须在文档中妥善地说明清楚。
4. C++相关
4.1 值 vs. 对象
4.1.1 指针 vs. 引用
指针（pointer）还是引用（reference）哪个是最好的输出参数（out-parameters）？

void getHsv(int *h, int *s, int *v) const;
void getHsv(int &amp;h, int &amp;s, int &amp;v) const;

大多数C++书籍推荐尽可能使用引用，基于一个普遍的观点：引用比指针『更加安全和优雅』。与此相反，我们在开发Qt时倾向于指针，因为指针让用户代码可读性更好。比较下面例子：

color.getHsv(&amp;h, &amp;s, &amp;v);
color.getHsv(h, s, v);

只有第一行代码清楚表达出h、s、v参数在函数调用中非常有可能会被修改。
这也就是说，编译器并不喜欢『出参』，所你应该在新的API中避免使用『出参』，而是返回一个结构体，如下所示：

struct Hsv { int hue, saturation, value };
Hsv getHsv() const;

【译注】：函数的『入参』和『出参』的混用会导致 API 接口语义的混乱，所以，使用指针，在调用的时候，实参需要加上“&amp;”，这样在代码阅读的时候，可以看到是一个『出参』，有利于代码阅读。（但是这样做，在函数内就需要判断指针是否为空的情况，因为引用是不需要判断的，所以，这是一种 trade-off）
另外，如果这样的参数过多的话，最好使用一个结构体来把数据打包，一方面，为一组返回值取个名字，另一方面，这样有利用接口的简单。
4.1.2 按常量引用传参 vs. 按值传参
如果类型大于16字节，按常量引用传参。
如果类型有重型的（non-trivial）拷贝构造函数（copy-constructor）或是重型的析构函数（destructor），按常量引用传参以避免执行这些函数。
对于其它的类型通常应该按值传参。
示例：

void setAge(int age);
void setCategory(QChar cat);
void setName(QLatin1String name);

// const-ref is much faster than running copy-constructor and destructor
void setAlarm(const QSharedPointer&lt;Alarm&gt; &amp;alarm);

// QDate, QTime, QPoint, QPointF, QSize, QSizeF, QRect
// are good examples of other classes you should pass by value.

【译注】：这是传引用和传值的差别了，因为传值会有对像拷贝，传引用则不会。所以，如果对像的构造比较重的话（换句话说，就是对像里的成员变量需要的内存比较大），这就会影响很多性能。所以，为了提高性能，最好是传引用。但是如果传入引用的话，会导致这个对象可能会被改变。所以传入const reference。
4.2 虚函数
在C++中，当类的成员函数声明为virtual，主要是为了通过在子类重载此函数能够定制函数的行为。将函数声明为virtual的目的是为了让对这个函数已有的调用变成执行实际实例的代码路径。对于没有在类外部调用的函数声明成virtual，你应该事先非常慎重地思考过。

// QTextEdit in Qt 3: member functions that have no reason for being virtual
virtual void resetFormat();
virtual void setUndoDepth( int d );
virtual void setFormat( QTextFormat *f, int flags );
virtual void ensureCursorVisible();
virtual void placeCursor( const QPoint &amp;pos;, QTextCursor **c = 0 );
virtual void moveCursor( CursorAction action, bool select );
virtual void doKeyboardAction( KeyboardAction action );
virtual void removeSelectedText( int selNum = 0 );
virtual void removeSelection( int selNum = 0 );
virtual void setCurrentFont( const QFont &amp;f );
virtual void setOverwriteMode( bool b ) { overWrite = b; }

QTextEdit从Qt 3移植到Qt 4的时候，几乎所有的虚函数都被移除了。有趣的是（但在预料之中），并没有人对此有大的抱怨，为什么？因为Qt 3没用到QTextEdit的多态行为 —— 只有你会；简单地说，没有理由去继承QTextEdit并重写这些函数，除非你自己调用了这些方法。如果在Qt在外部你的应用程序你需要多态，你可以自己添加多态。
【译注】：『多态』的目的只不过是为了实践 —— 『依赖于接口而不是实现』，也就是说，接口是代码抽像的一个非常重要的方式（在Java/Go中都有专门的接口声明语法）。所以，如果没有接口抽像，使用『多态』的意义也就不大了，因为也就没有必要使用『虚函数』了。
4.2.1 避免虚函数
在Qt中，我们有很多理由尽量减少虚函数的数量。每一次对虚函数的调用会在函数调用链路中插入一个未掌控的节点（某种程度上使结果更无法预测），使得bug修复变得更复杂。用户在重写的虚函数中可以做很多疯狂的事：

发送事件
发送信号
重新进入事件循环（例如，通过打开一个模态文件对话框）
删除对象（即触发『delete this』）

还有其他很多原因要避免过度使用虚函数：

添加、移动或是删除虚函数都带来二进制兼容问题（binary compatibility/BC）
重载虚函数并不容易
编译器几乎不能优化或内联（inline）对虚函数的调用
虚函数调用需要查找虚函数表（v-table），这比普通函数调用慢了2到3倍
虚函数使得类很难按值拷贝（尽管也可以按值拷贝，但是非常混乱并且不建议这样做）

经验告诉我们，没有虚函数的类一般bug更少、维护成本也更低。
一般的经验法则是，除非我们以这个类作为工具集提供而且有很多用户来调用某个类的虚函数，否则这个函数九成不应该设计成虚函数。
【译注】：

使用虚函数时，你需要对编译器的内部行为非常清楚，否则，你会在使用虚函数时，觉得有好些『古怪』的问题发生。比如在创建数组对象的时候。
在C++中，会有一个基础类，这个基础类中已经实现好了很多功能，然后把其中的一些函数放给子类去修改和实现。这种方法在父类和子类都是一组开发人员维护时没有什么问题，但是如果这是两组开发人员，这就会带来很多问题了，就像Qt这样，子类完全无法控制，全世界的开发人员想干什么就干什么。所以，子类的代码和父类的代码在兼容上就会出现很多很多问题。所以，还是上面所说，其实，虚函数应该声明在接口的语义里（这就是设计模式的两个宗旨——依赖于接口，而不是实现；钟爱于组合，而不是继承。也是为什么Java和Go语言使用interface关键字的原因，C++在多态的语义上非常容易滥用）


4.2.2 虚函数 vs. 拷贝
多态对象（polymorphic objects）和值类型的类（value-type classes）两者很难协作好。
包含虚函数的类必须把析构函数声明为虚函数，以防止父类析构时没有清理子类的数据，导致内存泄漏。
如果要使一个类能够拷贝、赋值或按值比较，往往需要拷贝构造函数、赋值操作符（operator =）和相等操作符（operator ==）。

class CopyClass {
public:
    CopyClass();
    CopyClass(const CopyClass &amp;other);
    ~CopyClass();
    CopyClass &amp;operator =(const CopyClass &amp;other);
    bool operator ==(const CopyClass &amp;other) const;
    bool operator !=(const CopyClass &amp;other) const;

    virtual void setValue(int v);
};

如果继承CopyClass这个类，预料之外的事就已经在代码时酝酿了。一般情况下，如果没有虚成员函数和虚析构函数，就不能创建出可以多态的子类。然而，如果存在虚成员函数和虚析构函数，这突然变成了要有子类去继承的理由，而且开始变得复杂了。起初认为只要简单声明上虚操作符重载函数（virtual operators）。 但其实是走上了一条混乱和毁灭之路（破坏了代码的可读性）。看看下面的这个例子：

class OtherClass {
public:
    const CopyClass &amp;instance() const; // 这个方法返回的是什么？可以赋值什么？
};

（这部份还未完成）
【译注】：因为原文上说，这部份并没有完成，所以，我也没有搞懂原文具体也是想表达什么。不过，就标题而言，原文是想说，在多态的情况下拷贝对象所带来的问题？？
4.3 关于const
C++的关键词const表明了内容不会改变或是没有副作用。可以应用于简单的值、指针及指针所指的内容，也可以作为一个特别的属性应用于类的成员函数上，表示成员函数不能修改对象的状态。
然而，const本身并没有提供太大的价值 —— 很多编程语言甚至没有类似const的关键词，但是却并没有因此产生问题。实际上，如果你不用函数重载，并在C++源代码用搜索并删除所有的const，几乎总能编译通过并且正常运行。尽量让使用的const保持实用有效，这点很重要。
让我们看一下在Qt的API设计中与const相关的场景。
4.3.1 输入参数：const指针
有输入指针参数的const成员函数，几乎总是const指针参数。
如果函数声明为const，意味着既没有副作用，也不会改变对象的可见状态。那为什么它需要一个没有const限定的输入参数呢？记住const类型的函数通常被其他const类型的函数调用，接收到的一般都是const指针（只要不主动const_cast，我们推荐尽量避免使用const_cast）
以前：

bool QWidget::isVisibleTo(QWidget *ancestor) const;
bool QWidget::isEnabledTo(QWidget *ancestor) const;
QPoint QWidget::mapFrom(QWidget *ancestor, const QPoint &amp;pos) const;

QWidget声明了许多非const指针输入参数的const成员函数。注意，这些函数可以修改传入的参数，不能修改对象自己。使用这样的函数常常要借助const_cast转换。如果是const指针输入参数，就可以避免这样的转换了。
之后：

bool QWidget::isVisibleTo(const QWidget *ancestor) const;
bool QWidget::isEnabledTo(const QWidget *ancestor) const;
QPoint QWidget::mapFrom(const QWidget *ancestor, const QPoint &amp;pos) const;

注意，我们在QGraphicsItem中对此做了修正，但是QWidget要等到Qt 5:

bool isVisibleTo(const QGraphicsItem *parent) const;
QPointF mapFromItem (const QGraphicsItem *item, const QPointF &amp;point) const;

4.3.2 返回值：const值
调用函数返回的非引用类型的结果，称之为右值（R-value）。
非类（non-class）的右值总是无cv限定类型（cv-unqualified type）。虽然从语法上讲，加上const也可以，但是没什么意义，因为鉴于访问权限这些值是不能改变的。多数现代编译器在编译这样的代码时会提示警告信息。
【译注】：cv-qualified的类型（与cv-unqualified相反）是由const或者volatile或者volatile const限定的类型。详见cv (const and volatile) type qualifiers &#8211; C++语言参考
当在类类型（class type）右值上添加const关键字，则禁止访问非const成员函数以及对成员的直接操作。
不加const则没有以上的限制，但几乎没有必要加上const，因为右值对象生存时间（life time）的结束一般在C++清理的时候（通俗的说，下一个分号地方），而对右值对象的修改随着右值对象的生存时间也一起结束了（也就是本条语句的执行完成的时候）。
示例：

struct Foo {
    void setValue(int v) { value = v; }
    int value;
};

Foo foo() {
    return Foo();
}

const Foo cfoo() {
    return Foo();
}

int main() {
    // The following does compile, foo() is non-const R-value which
    // can't be assigned to (this generally requires an L-value)
    // but member access leads to a L-value:
    foo().value = 1; // Ok, but temporary will be thrown away at the end of the full-expression.

    // The following does compile, foo() is non-const R-value which
    // can't be assigned to, but calling (even non-const) member
    // function is fine:
    foo().setValue(1); // Ok, but temporary will be thrown away at the end of the full-expression.

    // The following does _not_compile, foo() is ''const'' R-value
    // with const member which member access can't be assigned to:
    cfoo().value = 1; // Not ok.

    // The following does _not_compile, foo() is ''const'' R-value,
    // one cannot call non-const member functions:
    cfoo().setValue(1); // Not ok
}

【译注】：上述的代码说明，如果返回值不是const的，代码可以顺利编译通过，然而并没有什么卵用，因为那个临时对像马上就被抛弃了。所以，这样的无用的代码最好还是在编译时报个错，以免当时头脑发热想错了，写了一段没用但还以为有用的代码。
4.3.3 返回值：非const的指针还是有const的指针
谈到const函数应该返回非const的指针还是const指针这个话题时，多数人发现在C++中关于『const正确性』（const correctness）在概念上产生了分歧。 问题起源是：const函数本身不能修改对象自身的状态，却可以返回成员的非const指针。返回指针这个简单动作本身既不会影响整个对象的可见状态，当然也不会改变这个函数职责范围内涉及的状态。但是，这却使得程序员可以间接访问并修改对象的状态。
下面的例子演示了通过返回非const指针的const函数绕开const约定（constness）的诸多方式中的一种：

QVariant CustomWidget::inputMethodQuery(Qt::InputMethodQuery query) const {
    moveBy(10, 10); // doesn't compile!
    window()-&gt;childAt(mapTo(window(), rect().center()))-&gt;moveBy(10, 10); // compiles!
}

返回const指针的函数正是保护以避免这些（可能是不期望的/没有预料到的）副作用，至少是在一定程度上。但哪个函数你会觉得更想返回const指针，或是不止一个函数？
若采用const正确（const-correct）的方法，每个返回某个成员的指针（或多个指向成员的指针）的const函数必须返回const指针。在实践中，很不幸这样的做法将导致无法使用的API：

QGraphicsScene scene;
// … populate scene

foreach (const QGraphicsItem *item, scene.items()) {
    item-&gt;setPos(qrand() % 500, qrand() % 500); // doesn't compile! item is a const pointer
}

QGraphicsScene::items()是一个const函数，顺着思考看起来这个函数只应该返回const指针。
在Qt中，我们几乎只有非const的使用模式。我们选择的是实用路子： 相比滥用非const指针返回类型带来的问题，返回const指针更可能招致过分使用const_cast的问题。
4.3.4 返回值：按值返回 还是 按const引用返回？
若返回的是对象的拷贝，那么返回const引用是更直接的方案； 然而，这样的做法限制了后面想要对这个类的重构（refactor）。 （以d-point的典型做法（idiom）为例，我们可以在任何时候改变Qt类在内存表示（memory representation）；但却不能在不破坏二进制兼容性的情况下把改变函数的签名，返回值从const QFoo &amp;变为QFoo。） 基于这个原因，除去对运行速度敏感（speed is critical）而重构不是问题的个别情形（例如，QList::at()），我们一般返回QFoo而不是const QFoo &amp;。
【译注】：参看《Effective C++》中条款23：Don&#8217;t try to return a reference when you must return an object
4.4.5 const vs. 对象的状态
const正确性（Const correctness）的问题就像C圈子中vi与emacs的讨论，因为这个话题在很多地方都存在分歧（比如基于指针的函数）。
但通用准则是const函数不能改变类的可见状态。『状态』的意思是『自身以及涉及的职责』。这并不是指非const函数能够改变自身的私有成员，也不是指const函数改变不了。而是指函数是活跃的并存在可见的副作用（visible side effects）。const函数一般没有任何可见的副作用，比如：

QSize size = widget-&gt;sizeHint(); // const
widget-&gt;move(10, 10); // not const

代理（delegate）负责在其它对象上绘制内容。 它的状态包括它的职责，因此包括在哪个对象做绘制这样的状态。 调用它的绘画行为必然会有副作用； 它改变了它绘制所在设备的外观（及其所关联的状态）。鉴于这些，paint()作为const函数并不合理。 进一步说，任何paint()或QIcon的paint()的视图函数是const函数也不合理。 没有人会从内部的const函数去调用QIcon::paint()，除非他想显式地绕开const这个特性。 如果是这种情况，使用const_cast会更好。

// QAbstractItemDelegate::paint is const
void QAbstractItemDelegate::paint(QPainter **painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const

// QGraphicsItem::paint is not const
void QGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem option, QWidget *widget)

const关键字并不能按你期望的样子起作用。应该考虑将其移除而不是去重载const/非const函数。
5. API的语义和文档
当传值为-1的参数给函数，函数会是什么行为？有很多类似的问题……
是警告、致命错误还是其它？
API需要的是质量保证。API第一个版本一定是不对的；必须对其进行测试。 以阅读使用API的代码的方式编写用例，且验证这样代码是可读的。
还有其他的验证方法，比如

让别人使用API（看了文档或是先不看文档都可以）
给类写文档（包含类的概述和每个函数）

6. 命名的艺术
命名很可能是API设计中最重要的一个问题。类应该叫什么名字？成员函数应该叫什么名字？
6.1 通用的命名规则
有几个规则对于所有类型的命名都等同适用。第一个，之前已经提到过，不要使用缩写。即使是明显的缩写，比如把previous缩写成prev，从长远来看是回报是负的，因为用户必须要记住缩写词的含义。
如果API本身没有一致性，之后事情自然就会越来越糟；例如，Qt 3 中同时存在activatePreviousWindow()与fetchPrev()。恪守『不缩写』规则更容易地创建一致性的API。
另一个时重要但更微妙的准则是在设计类时应该保持子类名称空间的干净。在Qt 3中，此项准则并没有一直遵循。以QToolButton为例对此进行说明。如果调用QToolButton的 name()、caption()、text()或者textLabel()，你觉得会返回什么？用Qt设计器在QToolButton上自己先试试吧：

name属性是继承自QObject，返回内部的对象名称，用于调试和测试。
caption属性继承自QWidget，返回窗口标题，对QToolButton来说毫无意义，因为它在创建的时候parent就存在了。
text函数继承自QButton，一般用于按钮。当useTextLabel不为true，才用这个属性。
textLabel属性在QToolButton内声明，当useTextLabel为true时显示在按钮上。

为了可读性，在Qt 4中QToolButton的name属性改成了objectName，caption改成了windowTitle，删除了textLabel属性因为和text属性相同。
当你找不到好的命名时，写文档也是个很好方法：要做的就是尝试为各个条目（item）（如类、方法、枚举值等等）写文档，并用写下的第一句话作为启发。如果找不到一个确切的命名，往往说明这个条目是不该有的。如果所有尝试都失败了，并且你坚信这个概念是合理的，那么就发明一个新名字。像widget、event、focus和buddy这些命名就是在这一步诞生的。
【译注】：写文档是一个非常好的习惯。写文档的过程其实就是在帮你梳理你的编程思路。很多时候，文档写着写着你就会发现要去改代码去了。除了上述的好处多，写文档还有更多的好处。比如，在写文档的过程中，你发现文字描述过于复杂了，这表明着你的代码或逻辑是复杂的，这就倒逼你去重构你的代码。所以 —— 写文档其实就是写代码。
6.2 类的命名
识别出类所在的分组，而不是为每个类都去找个完美的命名。例如，所有Qt 4的能感知模型（model-aware）的item view，类后缀都是View（QListView、QTableView、QTreeView），而相应的基于item（item-based）的类后缀是Widget（QListWidget、QTableWidget、QTreeWidget）。
6.3 枚举类型及其值的命名
声明枚举类型时，需要记住在C++中枚举值在使用时不会带上类型（与Java、C#不同）。下面的例子演示了枚举值命名得过于通用的危害：

namespace Qt
{
    enum Corner { TopLeft, BottomRight, ... };
    enum CaseSensitivity { Insensitive, Sensitive };
    ...
};

tabWidget-&gt;setCornerWidget(widget, Qt::TopLeft);
str.indexOf(&quot;$(QTDIR)&quot;, Qt::Insensitive);

在最后一行，Insensitive是什么意思？命名枚举类型的一个准则是在枚举值中至少重复此枚举类型名中的一个元素：

namespace Qt
{
    enum Corner { TopLeftCorner, BottomRightCorner, ... };
    enum CaseSensitivity { CaseInsensitive, CaseSensitive };
    ...
};

tabWidget-&gt;setCornerWidget(widget, Qt::TopLeftCorner);
str.indexOf(&quot;$(QTDIR)&quot;, Qt::CaseInsensitive);

当对枚举值进行或运算并作为某种标志（flag）时，传统的做法是把或运算的结果保存在int型的值中，但这不是类型安全的。Qt 4提供了一个模板类QFlags，其中的T是枚举类型。为了方便使用，Qt用typedef重新定义了QFlag类型，所以可以用Qt::Alignment代替QFlags。
习惯上，枚举类型命名用单数形式（因为它一次只能『持有』一个flag），而持有多个『flag』的类型用复数形式，例如：

enum RectangleEdge { LeftEdge, RightEdge, ... };
typedef QFlags&lt;RectangleEdge&gt; RectangleEdges;

在某些情形下，持有多个『flag』的类型命名用单数形式。对于这种情况，持有的枚举类型名称要求是以Flag为后缀：

enum AlignmentFlag { AlignLeft, AlignTop, ... };
typedef QFlags&lt;AlignmentFlag&gt; Alignment;

6.4 函数和参数的命名
函数命名的第一准则是可以从函数名看出来此函数是否有副作用。在Qt 3中，const函数QString::simplifyWhiteSpace()违反了此准则，因为它返回了一个QString而不是按名称暗示的那样，改变调用它的QString对象。在Qt 4中，此函数重命名为QString::simplified()。
虽然参数名不会出现在使用API的代码中，但是它们给程序员提供了重要信息。因为现代的IDE都会在写代码时显示参数名称，所以值得在头文件中给参数起一个恰当的名字并在文档中使用相同的名字。
6.5 布尔类型的getter与setter方法的命名
为bool属性的getter和setter方法命名总是很痛苦。getter应该叫做checked()还是isChecked()？scrollBarsEnabled()还是areScrollBarEnabled()？
Qt 4中，我们套用以下准则为getter命名：

形容词以is为前缀，例子：

isChecked()
isDown()
isEmpty()
isMovingEnabled()


然而，修饰名词的形容词没有前缀：

scrollBarsEnabled()，而不是areScrollBarsEnabled()


动词没有前缀，也不使用第三人称(-s)：

acceptDrops()，而不是acceptsDrops()
allColumnsShowFocus()


名词一般没有前缀：

autoCompletion()，而不是isAutoCompletion()
boundaryChecking()


有的时候，没有前缀容易产生误导，这种情况下会加上is前缀：

isOpenGLAvailable()，而不是openGL()
isDialog()，而不是dialog()
（一个叫做dialog()的函数，一般会被认为是返回QDialog。）



setter的名字由getter衍生，去掉了前缀后在前面加上了set；例如，setDown()与setScrollBarsEnabled()。
7. 避免常见陷阱
7.1 简化的陷阱
一个常见的误解是：实现需要写的代码越少，API就设计得越好。应该记住：代码只会写上几次，却要被反复阅读并理解。例如：

QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &quot;volume&quot;);

这段代码比下面的读起来要难得多（甚至写起来也更难）：

QSlider *slider = new QSlider(Qt::Vertical);
slider-&gt;setRange(12, 18);
slider-&gt;setPageStep(3);
slider-&gt;setValue(13);
slider-&gt;setObjectName(&quot;volume&quot;);

【译注】：在有IDE的自动提示的支持下，后者写起来非常方便，而前者还需要看相应的文档。
7.2 布尔参数的陷阱
布尔类型的参数总是带来无法阅读的代码。给现有的函数增加一个bool型的参数几乎永远是一种错误的行为。仍以Qt为例，repaint()有一个bool类型的可选参数用于指定背景是否被擦除。可以写出这样的代码：

widget-&gt;repaint(false);

初学者很可能是这样理解的，『不要重新绘制！』，能有多少Qt用户真心知道下面3行是什么意思：

widget-&gt;repaint();
widget-&gt;repaint(true);
widget-&gt;repaint(false);

更好的API设计应该是这样的：

widget-&gt;repaint();
widget-&gt;repaintWithoutErasing();

在Qt 4中，我们通过移除了重新绘制（repaint）而不擦除widget的能力来解决了此问题。Qt 4的双缓冲使这种特性被废弃。
还有更多的例子：

widget-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding, true);
textEdit-&gt;insert(&quot;Where's Waldo?&quot;, true, true, false);
QRegExp rx(&quot;moc_***.c??&quot;, false, true);

一个明显的解决方案是bool类型改成枚举类型。我们在Qt 4的QString中就是这么做的。对比效果如下：

str.replace(&quot;%USER%&quot;, user, false);               // Qt 3
str.replace(&quot;%USER%&quot;, user, Qt::CaseInsensitive); // Qt 4

【译注】：关于这个条目可以看看 CoolShell 这篇文章一些展开的讨论： 千万不要把 BOOL 设计成函数参数。
8. 案例研究
8.1 QProgressBar
为了展示上文各种准则的实际应用。我们来研究一下Qt 3中QProgressBar的API，并与Qt 4中对应的API作比较。在Qt 3中：

class QProgressBar : public QWidget
{
    ...
public:
    int totalSteps() const;
    int progress() const;

    const QString &amp;progressString() const;
    bool percentageVisible() const;
    void setPercentageVisible(bool);

    void setCenterIndicator(bool on);
    bool centerIndicator() const;

    void setIndicatorFollowsStyle(bool);
    bool indicatorFollowsStyle() const;

public slots:
    void reset();
    virtual void setTotalSteps(int totalSteps);
    virtual void setProgress(int progress);
    void setProgress(int progress, int totalSteps);

protected:
    virtual bool setIndicator(QString &amp;progressStr,
                              int progress,
                              int totalSteps);
    ...
};

该API相当的复杂和不一致；例如，reset()、setTotalSteps()、setProgress()是紧密联系的，但方法的命名并没明确地表达出来。
改善此API的关键是抓住QProgressBar与Qt 4的QAbstractSpinBox及其子类QSpinBox、QSlider、QDail之间的相似性。怎么做？把progress、totalSteps替换为minimum、maximum和value。增加一个valueChanged()消息，再增加一个setRange()函数。
进一步可以观察到progressString、percentage与indicator其实是一回事，即是显示在进度条上的文本。通常这个文本是个百分比，但是可通过setIndicator()设置为任何内容。以下是新的API：

virtual QString text() const;
void setTextVisible(bool visible);
bool isTextVisible() const;

默认情况下，显示文本是百分比指示器（percentage indicator），通过重写text()方法来定制行为。
Qt 3的setCenterIndicator()与setIndicatorFollowsStyle()是两个影响对齐方式的函数。他们可被一个setAlignment()函数代替：

void setAlignment(Qt::Alignment alignment);

如果开发者未调用setAlignment()，那么对齐方式由风格决定。对于基于Motif的风格，文字内容在中间显示；对于其他风格，在右侧显示。
下面是改善后的QProgressBar API:

class QProgressBar : public QWidget
{
    ...
public:
    void setMinimum(int minimum);
    int minimum() const;
    void setMaximum(int maximum);
    int maximum() const;
    void setRange(int minimum, int maximum);
    int value() const;

    virtual QString text() const;
    void setTextVisible(bool visible);
    bool isTextVisible() const;
    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment alignment);

public slots:
    void reset();
    void setValue(int value);

signals:
    void valueChanged(int value);
    ...
};

8.2 QAbstractPrintDialog &amp; QAbstractPageSizeDialog
Qt 4.0有2个幽灵类QAbstractPrintDialog和QAbstractPageSizeDialog，作为 QPrintDialog和QPageSizeDialog类的父类。这2个类完全没有用，因为Qt的API没有是QAbstractPrint-或是-PageSizeDialog指针作为参数并执行操作。通过篡改qdoc（Qt文档），我们虽然把这2个类隐藏起来了，却成了无用抽象类的典型案例。
这不是说，好 的抽象是错的，QPrintDialog应该是需要有个工厂或是其它改变的机制 —— 证据就是它声明中的#ifdef QTOPIA_PRINTDIALOG。
8.3 QAbstractItemModel
关于模型/视图（model/view）问题的细节在相应的文档中已经说明得很好了，但作为一个重要的总结这里还需要强调一下：抽象类不应该仅是所有可能子类的并集（union）。这样『合并所有』的父类几乎不可能是一个好的方案。QAbstractItemModel就犯了这个错误 —— 它实际上就是个QTreeOfTablesModel，结果导致了错综复杂（complicated）的API，而这样的API要让 所有本来设计还不错的子类 去继承。
仅仅增加抽象是不会自动就把API变得更好的。
8.4 QLayoutIterator &amp; QGLayoutIterator
在Qt 3，创建自定义的布局类需要同时继承QLayout和QGLayoutIterator（命名中的G是指Generic（通用））。QGLayoutIterator子类的实例指针会包装成QLayoutIterator，这样用户可以像和其它的迭代器（iterator）类一样的方式来使用。通过QLayoutIterator可以写出下面这样的代码：

QLayoutIterator it = layout()-&gt;iterator();
QLayoutItem **child;
while ((child = it.current()) != 0) {
    if (child-&gt;widget() == myWidget) {
        it.takeCurrent();
        return;
    }
    ++it;
}

在Qt 4，我们干掉了QGLayoutIterator类（以及用于盒子布局和格子布局的内部子类），转而是让QLayout的子类重写itemAt()、takeAt()和count()。
8.5 QImageSink
Qt 3有一整套类用来把完成增量加载的图片传递给一个动画 —— QImageSource/Sink/QASyncIO/QASyncImageIO。由于这些类之前只是用于启用动画的QLabel，完全过度设计了（overkill）。
从中得到的教训就是：对于那些未来可能的还不明朗的需求，不要过早地增加抽象设计。当需求真的出现时，比起一个复杂的系统，在简单的系统新增需求要容易得多。

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章从Gitlab误删除数据库想到的关于高可用的系统千万不要把 bool 设计成函数参数Leetcode 编程训练如何写出无法维护的代码一个“蝇量级” C 语言协程库
</content>
</doc><doc>
    <docid>224</docid>
    <url>https://coolshell.cn/articles/17998.html</url>
    <title>Linux PID 1 和 Systemd</title>
    <content>要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：Process identifier）
SysV Init
PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI &#8211; Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 sysvinit，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。
在 sysvint 下，有好几个运行模式，又叫 runlevel。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 /etc/inittab 文件中。

与此配套的还有 /etc/init.d/ 和 /etc/rc[X].d，前者存放各种进程的启停脚本（需要按照规范支持 start，stop子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：/etc/rc3.d 是 runlevel=3 的。 里面的文件主要是 link 到  /etc/init.d/ 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：S01rsyslog，S02ssh。S 表示启动，K表示停止，数字表示执行的顺序。
UpStart
Unix 和 Linux 在 sysvint 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 sysvint 受到了很多挑战。
比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为sysvint 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 /etc/fstab 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。sysvinit 采用 netdev 的方式来解决这个问题，也就是说，需要用户自己在 /etc/fstab 中给相应的硬盘配置上 netdev 属性，于是 sysvint 启动时不会挂载它，只有在网络可用后，由专门的 netfs 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。
所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 upstart 。 upstart 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，udev 得到通知，upstart 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。
upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。
Job 有一般的Job，也有service的Job，并且，upstart 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。
Event 分成三类，signal, method 和 hooks。signal 就是异步消息，method 是同步阻塞的。hooks 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。
但是，upstart 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 sysvinit 来说好太多，所以，也深得欢迎。
Systemd
直到2010的有一天，一个在 RedHat工作的工程师 Lennart Poettering 和 Kay Sievers ，开始引入了一个新的 init 系统—— systemd。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，systemd 不但想取代已有的 init 系统，而且还想干更多的东西。
Lennart 同意 upstart 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 upstart 也有问题，其中最大的问题还是不够快，虽然 upstart 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。  如：NetworkManager 在等 D-Bus 的启动事件，而 D-Bus 在等 syslog 的启动事件。
Lennart 认为，实现上来说，upstart 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，

从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。


Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 sysvint。 也就是说，当用户配置了 “启动 D-Bus 后请启动 NetworkManager”， 这个 upstart 可以干，但是反过来，如果，用户启动 NetworkManager，我们应该先去启动他的前置依赖 D-Bus，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。


最后，upstart 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 upstart 中出现。因为 upstart 被设计为单一的事件，而忽略了逻辑依赖。

当然，如果 systemd 只是解决 upstart 的问题，他就改造 upstart 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。
首先，systemd 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，systemd 的设计理念就是两条：

To start less.
And to start more in parallel.

也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，systemd 借鉴了 MacOS 的 Launchd 的玩法（在Youtube上有一个分享——Launchd: One Program to Rule them All，在苹果的开源网站上也有相关的设计文档——About Daemons and Services）
要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。

Socket依赖。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。systemd 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。

&nbsp;

D-Bus依赖。D-Bus 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 D-Bus 而不是Socket来通信。比如：NetworkManager 就是通过 D-Bus 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 D-Bus 通信。D-Bus 支持 “Bus Activation”的特性。也就是说，A要通过 D-Bus 服务和B通讯，但是B没有启动，那么 D-Bus 可以把B起来，在B启动的过程中，D-Bus 帮你缓存数据。systemd 可以帮你利用好这个特性来并行启动 A 和 B。

&nbsp;

文件系统依赖。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。systemd 参考了 autofs 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。autofs 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open() 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 open() 调用被内核挂起等待，等到挂载完成后，控制权返回给 open() 系统调用，并正常打开文件。这个过程和 autofs 是相似的。

&nbsp;
下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。

除此之外，systemd 还在启动时管理好了一些下面的事。
用C语言取代传统的脚本式的启动。前面说过，sysvint 用 /etc/rcX.d 下的各种脚本启动。然而这些脚本中需要使用 awk, sed, grep, find, xargs 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？
在正常的一个 sysvinit 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，systemd 全面用 C 语言全部取代了。一般来说，sysvinit 下，操作系统启动完成后，用 echo $$ 可以看到，pid 被分配到了上千的样子，而 systemd 的系统只是上百。
另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。

我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的 （具体过程可参看这篇文章“SysV Daemon”）——

进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。
调用 fork() 创建子进程，在子进程中 setsid()，然后父进程退出（为了后台执行）
在子进程中，再调用一次 fork()，创建孙子进程，确定没有交互终端。然后子进程退出。
在孙子进程中，把标准输入标准输出标准错误都连到 /dev/null 上，还要创建 pid 文件，日志文件，处理相关信号 ……
最后才是真正开始提供服务。



&nbsp;

在上面的这个过程中，服务进程除了两次 fork 外还会 fork 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 fork 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。

&nbsp;

为了解决这个问题，upstart 通过变态的 strace 来跟踪进程中的 fork() 和 exec() 或 exit() 等相关的系统调用。这种方法相当笨拙。 systemd 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 cgroup （我在 Docker 的基础技术“cgroup篇”中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 cgroup，所以，systemd 只需要简单的去遍历一下相应的 cgroup 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。

&nbsp;
另外，systemd 简化了整个 daemon 开发的过程：

不需要两次 fork()，只需要实现服务本身的主逻辑就可以了。
不需要 setsid()，systemd 会帮你干
不需要维护 pid文件，systemd 会帮处理。
不需要管理日志文件或是使用syslog，或是处理HUP的日志reload信号。把日志打到 stderr 上，systemd 帮你管理。
处理 SIGTERM 信号，这个信号就是正确退出当前服务，不要做其他的事。
……

除此之外，systemd 还能——

自动检测启动的服务间有没有环形依赖。
内建 autofs 自动挂载管理功能。
日志服务。systemd 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。
快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。
……

还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。
Systemd 争论和八卦
于是 systemd 这个东西成了可能是有史以来口水战最多的一个开源软件了。systemd 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《Unix编程艺术》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “The Biggest Myths”来解释 systemd 并不是这样的，大家可以前往一读。
这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 systemd 来作为标准的 init 守护进程来替换 sysvinit 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，systemd 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！

于是，Lennart 在 Google Plus 上发了贴子，批评整个 Linux 开源社区和 Linus 本人。他大意说，
这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 systemd 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……
这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。
Linus也在被一媒体问起 systemd 这个事来（参看“Torvalds says he has no strong opinions on systemd”），Linus在采访里说，
我对 systemd 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有systemd 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 systemd 没有必要一定要有这样的品味。哦，我说细节了……
今天，systemd 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 systemd。（Ubuntu 还有一个不错的wiki &#8211; Systemd for Upstart Users 阐述了如何在两者间切换）
&nbsp;
其它
还记得在《缓存更新的套路》一文中，我说过，如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？
比如：从 sysvinit 到 upstart 再到 systemd，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？
分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？
嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。
&nbsp;
延伸阅读

Lennert 的博文：Rethinking PID 1
Lennert 的演讲：systemd, beyond init （ PPT ）
Wikipedia：Systemd
LinuxVoice：Lennart Poettering 专访

（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章vfork 挂掉的一个问题Docker基础技术：AUFSDocker基础技术：Linux Namespace（上）Unix传奇(上篇)Docker基础技术：Linux Namespace（下）Docker基础技术：Linux CGroup
</content>
</doc><doc>
    <docid>225</docid>
    <url>https://coolshell.cn/articles/17972.html</url>
    <title>我看绩效考核</title>
    <content>（本来，这篇文章应该在5月份完成，我拖延症让我今天才完成）
前些天，有几个网友找我谈绩效考核的事，都是在绩效上被差评的朋友。在大致了解情况后，我发现他们感到沮丧和郁闷的原因，不全是自己没有做好事情，他们对于自己没有做好公司交给的事，一方面，持一些疑义，因为我很明显地感到他们和公司对一件是否做好的标准定义有误差，另一方面，他们对于自己的工作上的问题也承认。不过，让他们更多感到沮丧的原因则是，公司、经理或HR和他们的谈话，让他们感觉整个人都被完全否定了，甚至有一种被批斗的感觉。这个感觉实在是太糟糕了。
因为我也有相似的经历，所以，我想在这里写下一篇文章，谈谈自己的对一些绩效考核的感受。先放出我的两个观点：
1）制定目标和绩效，目的不是用来考核人的，而用来改善提高组织和人员业绩和效率的。
2）人是复杂的，人是有状态波动的，任何时候都不应该轻易否定人，绩效考核应该考核的是事情，而不是人。
我个人比较坚持的认为——绩效分应该打给项目，打给产品，打给部门，打给代码，而不是打给人。然而现在的管理体制基本上都是打给人，而很多根本不擅长管理的经理和HR以及很多不会独立思考的吃瓜群众基本上都会把矛头指向个人，所以，当然会有开批斗会的感觉。

&nbsp;
举几个例子
为了讲清楚我的上述观点，请让我先铺垫一下，先说几个例子吧，韩寒的例子我就不说了。
苏步青同学在小学时成绩很糟糕，全班倒数第一。
华罗庚同学上学时数学还考不及格，要不是王维克老师的鼓励并让他爱上了数学，他可能也就完全埋没了。
郑渊洁上学时，老师要求写《早起的鸟有虫子吃》，郑渊洁唱反调写《早起的虫子被鸟吃》，再加上数学老师发难，于是被开除了。从此郑渊洁没有上过一天学。
列夫尔斯泰大贵族出身，2岁丧母，9岁丧父，16岁上大学，大学三年级自动退学回家进行改革。在青年时期不好好读书，考试不及格，留级。他赌博、借债、鬼混……
这个的例子太多了，我从另一个方面举几个体育运动相关的例子，可能年轻的朋友都不知道，可以问问你们的父母。
80年代，中国有一批非常优秀的体育运动员，比如：体操王子李宁，打破过世界跳高记录的朱建华，还有乒乓球世界冠军马文革，还有羽毛球世界冠军赵建华，记得有一年参加世界比赛，他们全输了，而输的还很惨。于是国内的一些媒体和民众开始骂他们，甚至说他们是民族的败类、耻辱，还有很多人找上门要教训他们……
如果我们把绩效分比做在学校里的考试分，那么你是否会和我一样认为，考试的成绩只能代表这个人对这些知识点的掌握或理解，而且仅仅在这个时间点，根本不代表这个人根本就不行，更不代表他一直不行。因为挂科太多被学校开除的同学，并不见得这些人在社会上就无活生活下去，反而，他们中的有些人可能会考试成绩好的人还活得好。不是么？这样的例子在我们身边还少吗？
所以，当我看到某HR说某老员工——“他今天要不自己离开，未来一年也一定会因为绩效问题而被公司开了的”，除了感到居然有人类可以预知他人未来的可笑之外，我感到是一种悲哀，一种管理体制上的悲哀，我感到了在这HR考评背后一股非常强的暗流和不可见的力量让她干出了这样一件匪夷所思的事。
好些公司还考评价值观，价值观无可厚非，我觉得一个企业的价值观是非常必要的，但是考核价值观是件非常危险的事情。这个世界上和传统势力唱反调的人实在是太多了，而被定性为价值观有问题被迫害的人也是多了去了。被批斗被侮辱被毒打的老舍；因为同性恋问题，被迫害而自杀的图灵；因为不同意教会观点被监禁8年都不愿意放弃自己的信仰最终被烧死的布鲁诺，…… 这样的事情已经够多了，新的时代里不应该再发生这样的事了，无论大小。
考核价值观最大的问题就是非常容易的上纲上线，也非常容易的被制造政治斗争，也非常容易的扼杀各种不同思想，老实说，这从很大程度上是一种洗脑的手段——通过对人制造一种紧张或恐惧而达到控制思想的目的。
&nbsp;
对公司和管理者想说的话
下面我来谈谈绩效考核我的一些观点。在谈这个观点前，你可以移步看一下这篇新闻报道——《绩效主义毁了索尼》。而近年来，“放弃绩效考核”的斗争已经从科技企业中的Adobe、戴尔、微软、亚马逊，席卷到德勤、埃森哲、普华永道等咨询服务类企业。甚至通用电气（GE）——曾经的绩效管理的鼻祖，也宣布抛弃正式的年度绩效考核。在刚过去的2016年，腾讯的张小龙对微信事业群发出“警惕KPI”的呼声；李彦宏在内部信中将百度的掉队归咎于“从管理层到员工对短期KPI的追逐”；雷军干脆宣布小米“继续坚持‘去KPI’的战略，放下包袱，解掉绳索，开开心心地做事。”；王石也在个人微博中感慨：“绩效主义像企业的脓包”。
绩效考核在本质上就是像学校教育以分数论英雄，而忽略员工的成长和素质教育是一个道理。当学生和老师只关注考试分数时，而只有考试分数来评价老师和学生的优良中差时，老师和学生就会开始使用一些非常形式的方式来达到这个目标，比如：死记硬被，记套路，题海战术…… 而学习的能力的考评彻底地沦为了一种形式主义。反而，分数考的越高，脑子越死。（注：美国现行教育是不允许通过学生考试成绩来评价老师的能力的）
近几年来，一些大公司开始使用 OKR &#8211; Objectives, Key Result ，但是在实践过程中，我发现好些公司用OKR，本质上还是KPI &#8211; Key Performance Indicator， 因为OKR里面有一个Key Result，用来衡量 Objectives 的结果指标。于是，使用者习惯性的设置上了KPI。我个人认为 OKR 有三个非常大的特性：0）由员工提出，1）以目标为导向。2）全员共享。
举个例子，OKR可能会是制定成下面这个样子的：
Objectives：增强用户体验，
Key Results：
1）用户操作步骤减少20%以上，
2）客服减少40%以上工单，
3）用户99.9%的系统操作的响应时间为100ms以下
然后，把这个目标分解给产品、用户体验、技术团队，形成子的Objectives并关连上相应的父级的Key Result，比如，产品部门定义的Objectives：1）优化注册流程，减少2个步骤，2）优化红包算法，让用户更容易理解，3）提高商品质量，减少用户投诉。后端技术团队定义的Objectives： 1）定义SLA以及相关监控指标，2）自动化运维，减少故障恢复时间，3）提高性能，吞吐量在xxxqps下的99.9%的响应时间为xxms ……
这个Objective会从公司最高层一直分解到一线员工，信息完全透明，每个人都可以看到所有人被分解到目标，每个人都知道自己在为什么样的目标而奋头，而每个人也可以质疑，改进，建议调整最高层的目标和方向。而不是领到的是被层层消化过的变味的二手，三手甚至四五手的信息。
而 KPI 最大的问题就是用 OKR 里的 Key Results 拿来当目标，从而导致员工只知道要做什么，不知道为什么，不知道为什么，不能理解目标，工作也就成了实实在在的应付！
松下公司早在1933年，就召集168名员工，把松下未来250年的远景规划目标公布于众，从1956年开始，就定期宣布并解读自身的“五年计划”，帮助每位员工的目光从眼前的短期利益移开，树立自己的理想和目标，也促进了松下的可持续性发展。
然而，今时不同往昔，随着产品周期的不断缩减、竞争对手的持续涌入、高新技术的频频迭代，企业的战略的变化与调整变得更加频繁，朝令夕改的经营策略已经成为兵家常态。 在这一过程中，有多少员工了解调整之后的战略呢？员工的绩效指标又根据战略调整多少次了呢？
KPI本身是一种被动的、后置的考察，在工作完成之后考察员工的行为是否符合标准。因此，员工对于公司的目标漠不关心，只关心自己的KPI，因为这才是自己的最大的利益，为了达到KPI，有的员工开始不思考，并使用一些简单粗暴的玩法，其实这样既害了公司，也害了自己。自己的成长和进步也因为强大的 KPI 而抛在了脑后。
当然，KPI 绩效考核一般来说，不一定会毁掉公司的，相反，对于喜欢使用蛮力的劳动密集型的公司来说，可能还有所帮助，然而，KPI毁掉的一定是团队的文化和团队的挑战精神，以及创新和对事业的热情，甚至会让其中的人失去应有的正常的判断力（分不清充分和必要条件，分不清很多事的因果关系）。
&nbsp;
对职场人想说的话
那么，对于个人来说，如何面对公司给自己的绩效考核呢？如何面对他们的绩效考核呢？
还是用学校考试分数来做对比，如果说，用考试分数论英雄，一个人考高分就是绩效上的人才，考不及格的人就是人渣，这对吗？当然不是。也许仅于对于考试来说可以把人分成三六九等，但是对于整个人生来说，考试成绩和一个人在这个社会里的的成就并没有非常直接的因果关系。面对现实的社会，最终很多成绩好的人为成绩差的人工作的例子也有很多很多了。
我想说什么？我想说的是——用一颗平常心来面对公司给你打的分数，因为那并不代表你的整个人生。但是，你要用一颗非常严肃的心来面对自己的个人发展和成长，因为这才是真正需要认真对待的事。
换句话说，如果要给一个人打绩效分，那不是由一个公司在一个短期的时间时打出来，而是由这个人在一个长期的时间里所能达到的成就得出来的。
就像WhatsApp的联合创始人Brian Acton 在 2009年时面试Facebook时没有面试通过，然而在 5 年以后，他把自己创办的公司以190亿美元卖给了FaceBook。阿里巴巴的马云不也一样吗？找工作各种被拒，开办的第一个公司成绩也不好，20年前，一堆人都说马云这也不行那也不行，然而，后面呢？反过来说，也很多职业经理人在公司里绩效非常好，然后到了创业公司却搞得非常的糟糕，这又说明了什么呢？
这就像动物一样，有的动物适合在水里生活，有的动物适合在陆地上，鱼在陆地上是无法生存的，你让老虎去完成游泳的工作，你让鱼去完成鸟类的工作，你能考核到什么呢？我们每个人都有适合自己的环境，找到适合自己的环境才是最关键的！与其去关注别人对自己的评价，不如去寻找适合自己的环境。
所以，一个特定环境下的绩效考核并不代表什么，而那些妄图用绩效考核去否定一个人的做法，或多或少就是“法西斯”或“红卫兵”的玩法。
好了！让我们不要再说绩效考核了，让我们回到，真正让自己提高，让自己成长，让自己的强的话题上来吧。这里，我需要转引一篇文章《Do the Right Thing, Wait to get fired》，文中提到《 Team Geek》这本书中的一句话
做正确的事情，等着被开除。
谷歌新员工(我们称做“Nooglers”)经常会问我是如何让自己做事这么高效的。我半开玩笑的告诉他们这很简单：我选择做正确的事情，为谷歌，为世界，然后回到座位上，等着被开除。如果没有被开除，那我就是做了正确的事情——为所有人。如果被开除了，那选错了老板。总之，两方面，我都是赢。这是我的职业发展策略。
注明一下，“做正确的事，等着被开除”并不是一句鸡汤，而是让你变强大的话。因为强者自强，只有强者才能追求真理，而不是委曲求全。
嗯，考试分数不是关键，别人对你的评价也不是关键，自己有没有成长有没有提高有没有上一个台阶才是关键。KPI不是关键，OKR也不是关键，有没有在做正确的事，这才是关键！不是这样吗？
其它
我大学四年级时，觉得马上就要离开学校了，当时想干点以后再以没有机会干的事。想来想去，就是上学这么多年来，从来没有不及格过，于是我任性了一把，挂了一个科，去补考了一下。挂科的时候也收到一些同学的笑话，还有老师的批评，不过，这让我感觉我的学校经历更完整了。因为，这让我在22岁的时候，就经历并大概明白了一些人生的道理。
从98年工作到2013年来，就像一个好学生一样，我从来没有出现过任何的工作绩效问题，反正还经常在工作中成为标杠型的人，然并卵，只有自己成长才是最真实的感觉。“做正确的事，等着被开除”，这可能是我迄今为止在职场里做的最疯狂也是最正确的事了。因为，这让我有更多的经历，让我从正确的事中得到提高，也让我内心变得越来越强大，也让我找到了更具挑战的事，更让我对自己有更清楚的认识。
最后，我知道一定会有人来怼我，所以，最后我还想留段话，留给那些还是想通过绩效来否定人的人。
如果你对我的绩效或技术能力有怀疑，没问题，那么希望你能做到下述我已做到的事，再来喷我，谢谢！
“在你40岁，在父亲病重，孩子上学问题、房贷并未还清、你是全家唯一收入来源之类的中年危机的情况下，辞去你现在的工作，不加入任何一家公司，不用自己的任何一分钱积蓄，不要任何人的投资和帮助。只通过自己的技术能力，为别人解决相应的技术难题（不做任何无技术含量的外包项目），来生存养家，并除了能照顾好自己的家人没有降低自己的生活水平之外，还能再养活3个每人年薪36万元的工程师”
请问这样的绩效能打个几分呢？呵呵。
当然，不管怎么说，我还有很多路要走，还有很多不足，我还要继续努力。所以，我挑了一条对我来说最难走的路，作死创业……
（全文完）

 -->
 关注CoolShell微信公众账号和微信小程序

（转载本站文章请注明作者和出处 酷 壳 &#8211; CoolShell ，请勿用于任何商业用途）
——=== 访问 酷壳404页面 寻找遗失儿童。 ===——

相关文章什么是工程师文化？技术人员的发展之路从Code Review 谈如何做技术关于高可用的系统让我们来谈谈分工「我只是认真」聊聊工匠情怀
</content>
</doc>